<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 3. Declaring and validating method constraints</title><link rel="stylesheet" type="text/css" href="css/hibernate.css"/><meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1"/><link rel="home" href="index.html" title="Hibernate Validator 5.2.4.Final"/><link rel="up" href="index.html" title="Hibernate Validator 5.2.4.Final"/><link rel="prev" href="ch02.html" title="Chapter 2. Declaring and validating bean constraints"/><link rel="next" href="ch04.html" title="Chapter 4. Interpolating constraint error messages"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="ch02.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="ch04.html"><strong>Next</strong></a></li></ul><div class="chapter" title="Chapter 3. Declaring and validating method constraints"><div class="titlepage"><div><div><h2 class="title"><a id="chapter-method-constraints"/>Chapter 3. Declaring and validating method constraints</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="ch03.html#section-declaring-method-constraints">3.1. Declaring method constraints</a></span></dt><dd><dl><dt><span class="section"><a href="ch03.html#_parameter_constraints">3.1.1. Parameter constraints</a></span></dt><dt><span class="section"><a href="ch03.html#_return_value_constraints">3.1.2. Return value constraints</a></span></dt><dt><span class="section"><a href="ch03.html#_cascaded_validation">3.1.3. Cascaded validation</a></span></dt><dt><span class="section"><a href="ch03.html#_method_constraints_in_inheritance_hierarchies">3.1.4. Method constraints in inheritance hierarchies</a></span></dt></dl></dd><dt><span class="section"><a href="ch03.html#section-validating-executable-constraints">3.2. Validating method constraints</a></span></dt><dd><dl><dt><span class="section"><a href="ch03.html#section-obtaining-executable-validator">3.2.1. Obtaining an <code class="literal">ExecutableValidator</code> instance</a></span></dt><dt><span class="section"><a href="ch03.html#section-executable-validator-methods">3.2.2. <code class="literal">ExecutableValidator</code> methods</a></span></dt><dt><span class="section"><a href="ch03.html#__literal_constraintviolation_literal_methods_for_method_validation">3.2.3. <code class="literal">ConstraintViolation</code> methods for method validation</a></span></dt></dl></dd><dt><span class="section"><a href="ch03.html#section-builtin-method-constraints">3.3. Built-in method constraints</a></span></dt></dl></div><p>As of Bean Validation 1.1, constraints can not only be applied to JavaBeans and their properties,
but also to the parameters and return values of the methods and constructors of any Java type. That
way Bean Validation constraints can be used to specify</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">the preconditions that must be satisfied by the caller before a method or constructor may be
invoked (by applying constraints to the parameters of an executable)</li><li class="listitem">the postconditions that are guaranteed to the caller after a method or constructor invocation
returns (by applying constraints to the return value of an executable)</li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>For the purpose of this reference guide, the term <span class="emphasis"><em>method constraint</em></span> refers to both, method and
constructor constraints, if not stated otherwise. Occasionally, the term <span class="emphasis"><em>executable</em></span> is used when
referring to methods and constructors.</p></div><p>This approach has several advantages over traditional ways of checking the correctness of parameters
and return values:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">the checks don’t have to be performed manually (e.g. by throwing <code class="literal">IllegalArgumentException</code> or
similar), resulting in less code to write and maintain</li><li class="listitem">an executable’s pre- and postconditions don’t have to be expressed again in its documentation,
since the constraint annotations will automatically be included in the generated JavaDoc. This
avoids redundancies and reduces the chance of inconsistencies between implementation and
documentation</li></ul></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>In order to make annotations show up in the JavaDoc of annotated elements, the annotation types
themselves must be annotated with the meta annotation @Documented. This is the case for all built-in
constraints and is considered a best practice for any custom constraints.</p></div><p>In the remainder of this chapter you will learn how to declare parameter and return value
constraints and how to validate them using the <code class="literal">ExecutableValidator</code> API.</p><div class="section" title="3.1. Declaring method constraints"><div class="titlepage"><div><div><h2 class="title"><a id="section-declaring-method-constraints"/>3.1. Declaring method constraints</h2></div></div></div><div class="section" title="3.1.1. Parameter constraints"><div class="titlepage"><div><div><h3 class="title"><a id="_parameter_constraints"/>3.1.1. Parameter constraints</h3></div></div></div><p>You specify the preconditions of a method or constructor by adding constraint annotations to its
parameters as demonstrated in <a class="xref" href="ch03.html#example-declaring-parameter-constraints" title="Example 3.1. Declaring method and constructor parameter constraints">Example 3.1, “Declaring method and constructor parameter constraints”</a>.</p><div class="example"><a id="example-declaring-parameter-constraints"/><p class="title"><strong>Example 3.1. Declaring method and constructor parameter constraints</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter03.parameter;

public class RentalStation {

	public RentalStation(@NotNull String name) {
		//...
	}

	public void rentCar(
			@NotNull Customer customer,
			@NotNull @Future Date startDate,
			@Min(1) int durationInDays) {
		//...
	}
}</code></pre></div></div><br class="example-break"/><p>The following preconditions are declared here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The <code class="literal">name</code> passed to the <code class="literal">RentalCar</code> constructor must not be <code class="literal">null</code></li><li class="listitem">When invoking the <code class="literal">rentCar()</code> method, the given <code class="literal">customer</code> must not be <code class="literal">null</code>, the rental’s start
date must not be <code class="literal">null</code> as well as be in the future and finally the rental duration must be at least
one day</li></ul></div><p>Note that declaring method or constructor constraints itself does not automatically cause their
validation upon invocation of the executable. Instead, the <code class="literal">ExecutableValidator</code> API (see
<a class="xref" href="ch03.html#section-validating-executable-constraints" title="3.2. Validating method constraints">Section 3.2, “Validating method constraints”</a>) must be used to perform the validation, which is
often done using a method interception facility such as AOP, proxy objects etc.</p><p>Constraints may only be applied to instance methods, i.e. declaring constraints on static methods is
not supported. Depending on the interception facility you use for triggering method validation,
additional restrictions may apply, e.g. with respect to the visibility of methods supported as
target of interception. Refer to the documentation of the interception technology to find out
whether any such limitations exist.</p><div class="section" title="3.1.1.1. Cross-parameter constraints"><div class="titlepage"><div><div><h4 class="title"><a id="_cross_parameter_constraints"/>3.1.1.1. Cross-parameter constraints</h4></div></div></div><p>Sometimes validation does not only depend on a single parameter but on several or even all
parameters of a method or constructor. This kind of requirement can be fulfilled with help of a
cross-parameter constraint.</p><p>Cross-parameter constraints can be considered as the method validation equivalent to class-level
constraints. Both can be used to implement validation requirements which are based on several
elements. While class-level constraints apply to several properties of a bean, cross-parameter
constraints apply to several parameters of an executable.</p><p>In contrast to single-parameter constraints, cross-parameter constraints are declared on the method
or constructor as you can see in <a class="xref" href="ch03.html#example-using-cross-parameter-constraint" title="Example 3.2. Declaring a cross-parameter constraint">Example 3.2, “Declaring a cross-parameter constraint”</a>. Here the cross-
parameter constraint <code class="literal">@LuggageCountMatchesPassengerCount</code> declared on the <code class="literal">load()</code> method is used to
ensure that no passenger has more than two pieces of luggage.</p><div class="example"><a id="example-using-cross-parameter-constraint"/><p class="title"><strong>Example 3.2. Declaring a cross-parameter constraint</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter03.crossparameter;

public class Car {

	@LuggageCountMatchesPassengerCount(piecesOfLuggagePerPassenger = 2)
	public void load(List&lt;Person&gt; passengers, List&lt;PieceOfLuggage&gt; luggage) {
		//...
	}
}</code></pre></div></div><br class="example-break"/><p>As you will learn in the next section, return value constraints are also declared on the method
level. In order to distinguish cross-parameter constraints from return value constraints, the
constraint target is configured in the <code class="literal">ConstraintValidator</code> implementation using the
<code class="literal">@SupportedValidationTarget</code> annotation. You can find out about the details in
<a class="xref" href="ch06.html#section-cross-parameter-constraints" title="6.3. Cross-parameter constraints">Section 6.3, “Cross-parameter constraints”</a> which shows how to implement your own cross-parameter constraint.</p><p>In some cases a constraint can be applied to an executable’s parameters (i.e. it is a cross-
parameter constraint), but also to the return value. One example for this are custom constraints
which allow to specify validation rules using expression or script languages.</p><p>Such constraints must define a member <code class="literal">validationAppliesTo()</code> which can be used at declaration time to
specify the constraint target. As shown in <a class="xref" href="ch03.html#example-specifying-constraint-target" title="Example 3.3. Specifying a constraint’s target">Example 3.3, “Specifying a constraint’s target”</a> you apply the
constraint to an executable’s parameters by specifying
<code class="literal">validationAppliesTo = ConstraintTarget.PARAMETERS</code>, while <code class="literal">ConstraintTarget.RETURN_VALUE</code> is used
to apply the constraint to the executable return value.</p><div class="example"><a id="example-specifying-constraint-target"/><p class="title"><strong>Example 3.3. Specifying a constraint’s target</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter03.crossparameter.constrainttarget;

public class Garage {

	@ELAssert(expression = "...", validationAppliesTo = ConstraintTarget.PARAMETERS)
	public Car buildCar(List&lt;Part&gt; parts) {
		//...
	}

	@ELAssert(expression = "...", validationAppliesTo = ConstraintTarget.RETURN_VALUE)
	public Car paintCar(int color) {
		//...
	}
}</code></pre></div></div><br class="example-break"/><p>Although such a constraint is applicable to the parameters and return value of an executable, the
target can often be inferred automatically. This is the case, if the constraint is declared on</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">a void method with parameters (the constraint applies to the parameters)</li><li class="listitem">an executable with return value but no parameters (the constraint applies to the return value)</li><li class="listitem">neither a method nor a constructor, but a field, parameter etc. (the constraint applies to the
annotated element)</li></ul></div><p>In these situations you don’t have to specify the constraint target. It is still recommended to do
so if it increases readability of the source code. If the constraint target is not specified in
situations where it can’t be determined automatically, a ConstraintDeclarationException is raised.</p></div></div><div class="section" title="3.1.2. Return value constraints"><div class="titlepage"><div><div><h3 class="title"><a id="_return_value_constraints"/>3.1.2. Return value constraints</h3></div></div></div><p>The postconditions of a method or constructor are declared by adding constraint annotations to the
executable as shown in <a class="xref" href="ch03.html#example-declaring-return-value-constraints" title="Example 3.4. Declaring method and constructor return value constraints">Example 3.4, “Declaring method and constructor return value constraints”</a>.</p><div class="example"><a id="example-declaring-return-value-constraints"/><p class="title"><strong>Example 3.4. Declaring method and constructor return value constraints</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter03.returnvalue;

public class RentalStation {

	@ValidRentalStation
	public RentalStation() {
		//...
	}

	@NotNull
	@Size(min = 1)
	public List&lt;Customer&gt; getCustomers() {
		//...
	}
}</code></pre></div></div><br class="example-break"/><p>The following constraints apply to the executables of RentalStation:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Any newly created <code class="literal">RentalStation</code> object must satisfy the <code class="literal">@ValidRentalStation</code> constraint</li><li class="listitem">The customer list returned by <code class="literal">getCustomers()</code> must not be <code class="literal">null</code> and must contain at least on element</li></ul></div></div><div class="section" title="3.1.3. Cascaded validation"><div class="titlepage"><div><div><h3 class="title"><a id="_cascaded_validation"/>3.1.3. Cascaded validation</h3></div></div></div><p>Similar to the cascaded validation of JavaBeans properties (see
<a class="xref" href="ch02.html#section-object-graph-validation" title="2.1.6. Object graphs">Section 2.1.6, “Object graphs”</a>), the <code class="literal">@Valid</code> annotation can be used to mark executable
parameters and return values for cascaded validation. When validating a parameter or return value
annotated with <code class="literal">@Valid</code>, the constraints declared on the parameter or return value object are
validated as well.</p><p>In <a class="xref" href="ch03.html#example-cascaded-executable-validation" title="Example 3.5. Marking executable parameters and return values for cascaded validation">Example 3.5, “Marking executable parameters and return values for cascaded validation”</a>, the <code class="literal">car</code> parameter of the method <code class="literal">Garage#checkCar()</code> as
well as the return value of the <code class="literal">Garage</code> constructor are marked for cascaded validation.</p><div class="example"><a id="example-cascaded-executable-validation"/><p class="title"><strong>Example 3.5. Marking executable parameters and return values for cascaded validation</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter03.cascaded;

public class Garage {

	@NotNull
	private String name;

	@Valid
	public Garage(String name) {
		this.name = name;
	}

	public boolean checkCar(@Valid @NotNull Car car) {
		//...
	}
}</code></pre><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter03.cascaded;

public class Car {

	@NotNull
	private String manufacturer;

	@NotNull
	@Size(min = 2, max = 14)
	private String licensePlate;

	public Car(String manufacturer, String licencePlate) {
		this.manufacturer = manufacturer;
		this.licensePlate = licencePlate;
	}

	//getters and setters ...
}</code></pre></div></div><br class="example-break"/><p>When validating the arguments of the <code class="literal">checkCar()</code> method, the constraints on the properties of the
passed <code class="literal">Car</code> object are evaluated as well. Similarly, the <code class="literal">@NotNull</code> constraint on the name field of
<code class="literal">Garage</code> is checked when validating the return value of the <code class="literal">Garage</code> constructor.</p><p>Generally, the cascaded validation works for executables in exactly the same way as it does for
JavaBeans properties.</p><p>In particular, <code class="literal">null</code> values are ignored during cascaded validation (naturally this can’t happen
during constructor return value validation) and cascaded validation is performed recursively, i.e.
if a parameter or return value object which is marked for cascaded validation itself has properties
marked with <code class="literal">@Valid</code>, the constraints declared on the referenced elements will be validated as well.</p><p>Cascaded validation can not only be applied to simple object references but also to collection-typed
parameters and return values. This means when putting the <code class="literal">@Valid</code> annotation to a parameter or return
value which</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">is an array</li><li class="listitem">implements <code class="literal">java.lang.Iterable</code></li><li class="listitem">or implements <code class="literal">java.util.Map</code></li></ul></div><p>each contained element gets validated. So when validating the arguments of the <code class="literal">checkCars()</code> method in
<a class="xref" href="ch03.html#example-cascaded-executable-validation-listtyped" title="Example 3.6. List-typed method parameter marked for cascaded validation">Example 3.6, “List-typed method parameter marked for cascaded validation”</a>, each element instance of the passed list will
be validated and a <code class="literal">ConstraintViolation</code> created when any of the contained <code class="literal">Car</code> instances is invalid.</p><div class="example"><a id="example-cascaded-executable-validation-listtyped"/><p class="title"><strong>Example 3.6. List-typed method parameter marked for cascaded validation</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter03.cascaded.collection;

public class Garage {

	public boolean checkCars(@Valid @NotNull List&lt;Car&gt; cars) {
		//...
	}
}</code></pre></div></div><br class="example-break"/></div><div class="section" title="3.1.4. Method constraints in inheritance hierarchies"><div class="titlepage"><div><div><h3 class="title"><a id="_method_constraints_in_inheritance_hierarchies"/>3.1.4. Method constraints in inheritance hierarchies</h3></div></div></div><p>When declaring method constraints in inheritance hierarchies, it is important to be aware of the
following rules:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The preconditions to be satisfied by the caller of a method may not be strengthened in subtypes</li><li class="listitem">The postconditions guaranteed to the caller of a method may not be weakened in subtypes</li></ul></div><p>These rules are motivated by the concept of <span class="emphasis"><em>behavioral subtyping</em></span> which requires that wherever a
type <code class="literal">T</code> is used, also a subtype <code class="literal">S</code> of <code class="literal">T</code> may be used without altering the program’s behavior.</p><p>As an example, consider a class invoking a method on an object with the static type <code class="literal">T</code>. If the
runtime type of that object was <code class="literal">S</code> and <code class="literal">S</code> imposed additional preconditions, the client class might
fail to satisfy these preconditions as is not aware of them. The rules of behavioral subtyping are
also known as the <a class="link" href="http://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov
substitution principle</a>.</p><p>The Bean Validation specification implements the first rule by disallowing parameter constraints on
methods which override or implement a method declared in a supertype (superclass or interface).
<a class="xref" href="ch03.html#example-illegal-parameter-constraints" title="Example 3.7. Illegal method parameter constraint in subtype">Example 3.7, “Illegal method parameter constraint in subtype”</a> shows a violation of this rule.</p><div class="example"><a id="example-illegal-parameter-constraints"/><p class="title"><strong>Example 3.7. Illegal method parameter constraint in subtype</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter03.inheritance.parameter;

public interface Vehicle {

    void drive(@Max(75) int speedInMph);
}</code></pre><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter03.inheritance.parameter;

public class Car implements Vehicle {

	@Override
	public void drive(@Max(55) int speedInMph) {
		//...
	}
}</code></pre></div></div><br class="example-break"/><p>The <code class="literal">@Max</code> constraint on <code class="literal">Car#drive()</code> is illegal since this method implements the interface method
<code class="literal">Vehicle#drive()</code>. Note that parameter constraints on overriding methods are also disallowed, if the
supertype method itself doesn’t declare any parameter constraints.</p><p>Furthermore, if a method overrides or implements a method declared in several parallel supertypes
(e.g. two interfaces not extending each other or a class and an interface not implemented by that
class), no parameter constraints may be specified for the method in any of the involved types. The
types in <a class="xref" href="ch03.html#example-illegal-parameter-constraints-parallel-types" title="Example 3.8. Illegal method parameter constraint in parallel types of a hierarchy">Example 3.8, “Illegal method parameter constraint in parallel types of a hierarchy”</a> demonstrate a violation of that
rule. The method <code class="literal">RacingCar#drive()</code> overrides <code class="literal">Vehicle#drive()</code> as well as <code class="literal">Car#drive()</code>.
Therefore the constraint on <code class="literal">Vehicle#drive()</code> is illegal.</p><div class="example"><a id="example-illegal-parameter-constraints-parallel-types"/><p class="title"><strong>Example 3.8. Illegal method parameter constraint in parallel types of a hierarchy</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter03.inheritance.parallel;

public interface Vehicle {

	void drive(@Max(75) int speedInMph);
}</code></pre><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter03.inheritance.parallel;

public interface Car {

	public void drive(int speedInMph);
}</code></pre><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter03.inheritance.parallel;

public class RacingCar implements Car, Vehicle {

	@Override
	public void drive(int speedInMph) {
		//...
	}
}</code></pre></div></div><br class="example-break"/><p>The previously described restrictions only apply to parameter constraints. In contrast, return value
constraints may be added in methods overriding or implementing any supertype methods.</p><p>In this case, all the method’s return value constraints apply for the subtype method, i.e. the
constraints declared on the subtype method itself as well as any return value constraints on
overridden/implemented supertype methods. This is legal as putting additional return value
constraints in place may never represent a weakening of the postconditions guaranteed to the caller
of a method.</p><p>So when validating the return value of the method <code class="literal">Car#getPassengers()</code> shown in
<a class="xref" href="ch03.html#example-return-value-constraints-in-hierarchy" title="Example 3.9. Return value constraints on supertype and subtype method">Example 3.9, “Return value constraints on supertype and subtype method”</a>, the <code class="literal">@Size</code> constraint on the method itself as well
as the <code class="literal">@NotNull</code> constraint on the implemented interface method <code class="literal">Vehicle#getPassengers()</code> apply.</p><div class="example"><a id="example-return-value-constraints-in-hierarchy"/><p class="title"><strong>Example 3.9. Return value constraints on supertype and subtype method</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter03.inheritance.returnvalue;

public interface Vehicle {

	@NotNull
	List&lt;Person&gt; getPassengers();
}</code></pre><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter03.inheritance.returnvalue;

public class Car implements Vehicle {

	@Override
	@Size(min = 1)
	public List&lt;Person&gt; getPassengers() {
		//...
	}
}</code></pre></div></div><br class="example-break"/><p>If the validation engine detects a violation of any of the aforementioned rules, a
<code class="literal">ConstraintDeclarationException</code> will be raised.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>The rules described in this section only apply to methods but not constructors. By definition,
constructors never override supertype constructors. Therefore, when validating the parameters or the
return value of a constructor invocation only the constraints declared on the constructor itself
apply, but never any constraints declared on supertype constructors.</p></div></div></div><div class="section" title="3.2. Validating method constraints"><div class="titlepage"><div><div><h2 class="title"><a id="section-validating-executable-constraints"/>3.2. Validating method constraints</h2></div></div></div><p>The validation of method constraints is done using the <code class="literal">ExecutableValidator</code> interface.</p><p>In <a class="xref" href="ch03.html#section-obtaining-executable-validator" title="3.2.1. Obtaining an ExecutableValidator instance">Section 3.2.1, “Obtaining an <code class="literal">ExecutableValidator</code> instance”</a> you will learn how to obtain an <code class="literal">ExecutableValidator</code>
instance while <a class="xref" href="ch03.html#section-executable-validator-methods" title="3.2.2. ExecutableValidator methods">Section 3.2.2, “<code class="literal">ExecutableValidator</code> methods”</a> shows how to use the different methods
offered by this interface.</p><p>Instead of calling the <code class="literal">ExecutableValidator</code> methods directly from within application code, they are
usually invoked via a method interception technology such as AOP, proxy objects, etc. This causes
executable constraints to be validated automatically and transparently upon method or constructor
invocation. Typically a <code class="literal">ConstraintViolationException</code> is raised by the integration layer in case any
of the constraints is violated.</p><div class="section" title="3.2.1. Obtaining an ExecutableValidator instance"><div class="titlepage"><div><div><h3 class="title"><a id="section-obtaining-executable-validator"/>3.2.1. Obtaining an <code class="literal">ExecutableValidator</code> instance</h3></div></div></div><p>You can retrieve an <code class="literal">ExecutableValidator</code> instance via <code class="literal">Validator#forExecutables()</code> as shown in
<a class="xref" href="ch03.html#example-obtaining-executable-validator" title="Example 3.10. Obtaining an ExecutableValidator instance">Example 3.10, “Obtaining an <code class="literal">ExecutableValidator</code> instance”</a>.</p><div class="example"><a id="example-obtaining-executable-validator"/><p class="title"><strong>Example 3.10. Obtaining an <code class="literal">ExecutableValidator</code> instance</strong></p><div class="example-contents"><pre><code class="language-java">ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
executableValidator = factory.getValidator().forExecutables();</code></pre></div></div><br class="example-break"/><p>In the example the executable validator is retrieved from the default validator factory, but if
required you could also bootstrap a specifically configured factory as described in
<a class="xref" href="ch08.html" title="Chapter 8. Bootstrapping">Chapter 8, <em>Bootstrapping</em></a>, for instance in order to use a specific parameter name provider
(see <a class="xref" href="ch08.html#section-parameter-name-provider" title="8.2.4. ParameterNameProvider">Section 8.2.4, “<code class="literal">ParameterNameProvider</code>”</a>).</p></div><div class="section" title="3.2.2. ExecutableValidator methods"><div class="titlepage"><div><div><h3 class="title"><a id="section-executable-validator-methods"/>3.2.2. <code class="literal">ExecutableValidator</code> methods</h3></div></div></div><p>The <code class="literal">ExecutableValidator</code> interface offers altogether four methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">validateParameters()</code> and <code class="literal">validateReturnValue()</code> for method validation</li><li class="listitem"><code class="literal">validateConstructorParameters()</code> and <code class="literal">validateConstructorReturnValue()</code> for constructor validation</li></ul></div><p>Just as the methods on <code class="literal">Validator</code>, all these methods return a <code class="literal">Set&lt;ConstraintViolation&gt;</code> which contains
a <code class="literal">ConstraintViolation</code> instance for each violated constraint and which is empty if the validation
succeeds. Also all the methods have a var-args groups parameter by which you can pass the validation
groups to be considered for validation.</p><p>The examples in the following sections are based on the methods on constructors of the <code class="literal">Car</code> class
shown in <a class="xref" href="ch03.html#example-executable-validator-class-car" title="Example 3.11. Class Car with constrained methods and constructors">Example 3.11, “Class <code class="literal">Car</code> with constrained methods and constructors”</a>.</p><div class="example"><a id="example-executable-validator-class-car"/><p class="title"><strong>Example 3.11. Class <code class="literal">Car</code> with constrained methods and constructors</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter03.validation;

public class Car {

	public Car(@NotNull String manufacturer) {
		//...
	}

	@ValidRacingCar
	public Car(String manufacturer, String team) {
		//...
	}

	public void drive(@Max(75) int speedInMph) {
		//...
	}

	@Size(min = 1)
	public List&lt;Passenger&gt; getPassengers() {
		//...
	}
}</code></pre></div></div><br class="example-break"/><div class="section" title="3.2.2.1. ExecutableValidator#validateParameters()"><div class="titlepage"><div><div><h4 class="title"><a id="__literal_executablevalidator_validateparameters_literal"/>3.2.2.1. <code class="literal">ExecutableValidator#validateParameters()</code></h4></div></div></div><p>The method <code class="literal">validateParameters()</code> is used to validate the arguments of a method invocation.
<a class="xref" href="ch03.html#example-executable-validator-validate-parameters" title="Example 3.12. Using ExecutableValidator#validateParameters()">Example 3.12, “Using <code class="literal">ExecutableValidator#validateParameters()</code>”</a> shows an example. The validation results in a
violation of the <code class="literal">@Max</code> constraint on the parameter of the <code class="literal">drive()</code> method.</p><div class="example"><a id="example-executable-validator-validate-parameters"/><p class="title"><strong>Example 3.12. Using <code class="literal">ExecutableValidator#validateParameters()</code></strong></p><div class="example-contents"><pre><code class="language-java">Car object = new Car( "Morris" );
Method method = Car.class.getMethod( "drive", int.class );
Object[] parameterValues = { 80 };
Set&lt;ConstraintViolation&lt;Car&gt;&gt; violations = executableValidator.validateParameters(
		object,
		method,
		parameterValues
);

assertEquals( 1, violations.size() );
Class&lt;? extends Annotation&gt; constraintType = violations.iterator()
		.next()
		.getConstraintDescriptor()
		.getAnnotation()
		.annotationType();
assertEquals( Max.class, constraintType );</code></pre></div></div><br class="example-break"/><p>Note that <code class="literal">validateParameters()</code> validates all the parameter constraints of a method, i.e. constraints
on individual parameters as well as cross-parameter constraints.</p></div><div class="section" title="3.2.2.2. ExecutableValidator#validateReturnValue()"><div class="titlepage"><div><div><h4 class="title"><a id="__literal_executablevalidator_validatereturnvalue_literal"/>3.2.2.2. <code class="literal">ExecutableValidator#validateReturnValue()</code></h4></div></div></div><p>Using <code class="literal">validateReturnValue()</code> the return value of a method can can be validated. The validation in
<a class="xref" href="ch03.html#example-executable-validator-validate-return-value" title="Example 3.13. Using ExecutableValidator#validateReturnValue()">Example 3.13, “Using <code class="literal">ExecutableValidator#validateReturnValue()</code>”</a> yields one constraint violation since the
<code class="literal">getPassengers()</code> method is expect to return at least one <code class="literal">Passenger</code> instance.</p><div class="example"><a id="example-executable-validator-validate-return-value"/><p class="title"><strong>Example 3.13. Using <code class="literal">ExecutableValidator#validateReturnValue()</code></strong></p><div class="example-contents"><pre><code class="language-java">Car object = new Car( "Morris" );
Method method = Car.class.getMethod( "getPassengers" );
Object returnValue = Collections.&lt;Passenger&gt;emptyList();
Set&lt;ConstraintViolation&lt;Car&gt;&gt; violations = executableValidator.validateReturnValue(
		object,
		method,
		returnValue
);

assertEquals( 1, violations.size() );
Class&lt;? extends Annotation&gt; constraintType = violations.iterator()
		.next()
		.getConstraintDescriptor()
		.getAnnotation()
		.annotationType();
assertEquals( Size.class, constraintType );</code></pre></div></div><br class="example-break"/></div><div class="section" title="3.2.2.3. ExecutableValidator#validateConstructorParameters()"><div class="titlepage"><div><div><h4 class="title"><a id="__literal_executablevalidator_validateconstructorparameters_literal"/>3.2.2.3. <code class="literal">ExecutableValidator#validateConstructorParameters()</code></h4></div></div></div><p>The arguments of constructor invocations can be validated with <code class="literal">validateConstructorParameters()</code> as
shown in method <a class="xref" href="ch03.html#example-executable-validator-validate-constructor-parameters" title="Example 3.14. Using ExecutableValidator#validateConstructorParameters()">Example 3.14, “Using <code class="literal">ExecutableValidator#validateConstructorParameters()</code>”</a>. Due to the
<code class="literal">@NotNull</code> constraint on the manufacturer parameter, the validation call returns one constraint
violation.</p><div class="example"><a id="example-executable-validator-validate-constructor-parameters"/><p class="title"><strong>Example 3.14. Using <code class="literal">ExecutableValidator#validateConstructorParameters()</code></strong></p><div class="example-contents"><pre><code class="language-java">Constructor&lt;Car&gt; constructor = Car.class.getConstructor( String.class );
Object[] parameterValues = { null };
Set&lt;ConstraintViolation&lt;Car&gt;&gt; violations = executableValidator.validateConstructorParameters(
		constructor,
		parameterValues
);

assertEquals( 1, violations.size() );
Class&lt;? extends Annotation&gt; constraintType = violations.iterator()
		.next()
		.getConstraintDescriptor()
		.getAnnotation()
		.annotationType();
assertEquals( NotNull.class, constraintType );</code></pre></div></div><br class="example-break"/></div><div class="section" title="3.2.2.4. ExecutableValidator#validateConstructorReturnValue()"><div class="titlepage"><div><div><h4 class="title"><a id="__literal_executablevalidator_validateconstructorreturnvalue_literal"/>3.2.2.4. <code class="literal">ExecutableValidator#validateConstructorReturnValue()</code></h4></div></div></div><p>Finally, by using <code class="literal">validateConstructorReturnValue()</code> you can validate a constructor’s return value. In
<a class="xref" href="ch03.html#example-executable-validator-validate-constructor-return-value" title="Example 3.15. Using ExecutableValidator#validateConstructorReturnValue()">Example 3.15, “Using <code class="literal">ExecutableValidator#validateConstructorReturnValue()</code>”</a>, <code class="literal">validateConstructorReturnValue()</code>
returns one constraint violation, since the <code class="literal">Car</code> instance returned by the constructor doesn’t satisfy
the <code class="literal">@ValidRacingCar</code> constraint (not shown).</p><div class="example"><a id="example-executable-validator-validate-constructor-return-value"/><p class="title"><strong>Example 3.15. Using <code class="literal">ExecutableValidator#validateConstructorReturnValue()</code></strong></p><div class="example-contents"><pre><code class="language-java">//constructor for creating racing cars
Constructor&lt;Car&gt; constructor = Car.class.getConstructor( String.class, String.class );
Car createdObject = new Car( "Morris", null );
Set&lt;ConstraintViolation&lt;Car&gt;&gt; violations = executableValidator.validateConstructorReturnValue(
		constructor,
		createdObject
);

assertEquals( 1, violations.size() );
Class&lt;? extends Annotation&gt; constraintType = violations.iterator()
		.next()
		.getConstraintDescriptor()
		.getAnnotation()
		.annotationType();
assertEquals( ValidRacingCar.class, constraintType );</code></pre></div></div><br class="example-break"/></div></div><div class="section" title="3.2.3. ConstraintViolation methods for method validation"><div class="titlepage"><div><div><h3 class="title"><a id="__literal_constraintviolation_literal_methods_for_method_validation"/>3.2.3. <code class="literal">ConstraintViolation</code> methods for method validation</h3></div></div></div><p>In addition to the methods introduced in <a class="xref" href="ch02.html#section-constraint-violation-methods" title="2.2.3. ConstraintViolation methods">Section 2.2.3, “<code class="literal">ConstraintViolation</code> methods”</a>,
<code class="literal">ConstraintViolation</code> provides two more methods specific to the validation of executable parameters
and return values.</p><p><code class="literal">ConstraintViolation#getExecutableParameters()</code> returns the validated parameter array in case of
method or constructor parameter validation, while <code class="literal">ConstraintViolation#getExecutableReturnValue()</code>
provides access to the validated object in case of return value validation.</p><p>All the other <code class="literal">ConstraintViolation</code> methods generally work for method validation in the same way as
for validation of beans. Refer to the <a class="link" href="http://docs.jboss.org/hibernate/beanvalidation/spec/1.1 /api/index.html?javax/validation/metadata/BeanDescriptor.html">JavaDoc</a> to learn more about the
behavior of the individual methods and their return values during bean and method validation.</p><p>Note that <code class="literal">getPropertyPath()</code> can be very useful in order to obtain detailed information about the
validated parameter or return value, e.g. for logging purposes. In particular, you can retrieve name
and argument types of the concerned method as well as the index of the concerned parameter from the
path nodes. How this can be done is shown in <a class="xref" href="ch03.html#example-executable-validation-property-path" title="Example 3.16. Retrieving method and parameter information">Example 3.16, “Retrieving method and parameter information”</a>.</p><div class="example"><a id="example-executable-validation-property-path"/><p class="title"><strong>Example 3.16. Retrieving method and parameter information</strong></p><div class="example-contents"><pre><code class="language-java">Car object = new Car( "Morris" );
Method method = Car.class.getMethod( "drive", int.class );
Object[] parameterValues = { 80 };
Set&lt;ConstraintViolation&lt;Car&gt;&gt; violations = executableValidator.validateParameters(
		object,
		method,
		parameterValues
);

assertEquals( 1, violations.size() );
Iterator&lt;Node&gt; propertyPath = violations.iterator()
		.next()
		.getPropertyPath()
		.iterator();

MethodNode methodNode = propertyPath.next().as( MethodNode.class );
assertEquals( "drive", methodNode.getName() );
assertEquals( Arrays.&lt;Class&lt;?&gt;&gt;asList( int.class ), methodNode.getParameterTypes() );

ParameterNode parameterNode = propertyPath.next().as( ParameterNode.class );
assertEquals( "arg0", parameterNode.getName() );
assertEquals( 0, parameterNode.getParameterIndex() );</code></pre></div></div><br class="example-break"/><p>The parameter name is determined using the current <code class="literal">ParameterNameProvider</code> (see
<a class="xref" href="ch08.html#section-parameter-name-provider" title="8.2.4. ParameterNameProvider">Section 8.2.4, “<code class="literal">ParameterNameProvider</code>”</a>) and defaults to <code class="literal">arg0</code>, <code class="literal">arg1</code> etc.</p></div></div><div class="section" title="3.3. Built-in method constraints"><div class="titlepage"><div><div><h2 class="title"><a id="section-builtin-method-constraints"/>3.3. Built-in method constraints</h2></div></div></div><p>In addition to the built-in bean and property-level constraints discussed in
<a class="xref" href="ch02.html#section-builtin-constraints" title="2.3. Built-in constraints">Section 2.3, “Built-in constraints”</a>, Hibernate Validator currently provides one method-level constraint,
<code class="literal">@ParameterScriptAssert</code>. This is a generic cross-parameter constraint which allows to implement
validation routines using any JSR 223 compatible ("Scripting for the Java<sup>TM</sup> Platform") scripting
language, provided an engine for this language is available on the classpath.</p><p>To refer to the executable’s parameters from within the expression, use their name as obtained from
the active parameter name provider (see <a class="xref" href="ch08.html#section-parameter-name-provider" title="8.2.4. ParameterNameProvider">Section 8.2.4, “<code class="literal">ParameterNameProvider</code>”</a>).
<a class="xref" href="ch03.html#example-parameterscriptassert" title="Example 3.17. Using @ParameterScriptAssert">Example 3.17, “Using <code class="literal">@ParameterScriptAssert</code>”</a> shows how the validation logic of the <code class="literal">@LuggageCountMatchesPassengerCount</code>
constraint from <a class="xref" href="ch03.html#example-using-cross-parameter-constraint" title="Example 3.2. Declaring a cross-parameter constraint">Example 3.2, “Declaring a cross-parameter constraint”</a> could be expressed with the help of
<code class="literal">@ParameterScriptAssert</code>.</p><div class="example"><a id="example-parameterscriptassert"/><p class="title"><strong>Example 3.17. Using <code class="literal">@ParameterScriptAssert</code></strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter03.parametersscriptassert;

public class Car {

	@ParameterScriptAssert(lang = "javascript", script = "arg1.size() &lt;= arg0.size() * 2")
	public void load(List&lt;Person&gt; passengers, List&lt;PieceOfLuggage&gt; luggage) {
		//...
	}
}</code></pre></div></div><br class="example-break"/></div></div><script xmlns="" xmlns:d="http://docbook.org/ns/docbook" type="text/javascript" src="highlight.js/highlight.pack.js"> </script><script xmlns="" xmlns:d="http://docbook.org/ns/docbook" type="text/javascript">hljs.initHighlightingOnLoad();</script><script type="text/javascript">
dataLayer = [{'channel' : 'Hibernate', 'additional_tracking_code' : 'UA-45270411-3'}];
(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-NJWS5L');</script><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-NJWS5L" height="0" width="0" style="display:none;visibility:hidden"> </iframe></noscript><hr xmlns="" xmlns:d="http://docbook.org/ns/docbook"/><a xmlns="" xmlns:d="http://docbook.org/ns/docbook" href="legalnotice.html"/><ul class="docnav"><li class="previous"><a accesskey="p" href="ch02.html"><strong>Prev</strong>Chapter 2. Declaring and validating bean constrai...</a></li><li class="up"><a accesskey="u" href="#"><strong>Up</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Home</strong></a></li><li class="next"><a accesskey="n" href="ch04.html"><strong>Next</strong>Chapter 4. Interpolating constraint error messages</a></li></ul></body></html>