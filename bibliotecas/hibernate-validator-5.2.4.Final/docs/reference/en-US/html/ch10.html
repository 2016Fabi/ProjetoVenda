<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Chapter 10. Integrating with other frameworks</title><link rel="stylesheet" type="text/css" href="css/hibernate.css"/><meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1"/><link rel="home" href="index.html" title="Hibernate Validator 5.2.4.Final"/><link rel="up" href="index.html" title="Hibernate Validator 5.2.4.Final"/><link rel="prev" href="ch09.html" title="Chapter 9. Using constraint metadata"/><link rel="next" href="ch11.html" title="Chapter 11. Hibernate Validator Specifics"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/></head><body><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><ul class="docnav"><li class="previous"><a accesskey="p" href="ch09.html"><strong>Prev</strong></a></li><li class="next"><a accesskey="n" href="ch11.html"><strong>Next</strong></a></li></ul><div class="chapter" title="Chapter 10. Integrating with other frameworks"><div class="titlepage"><div><div><h2 class="title"><a id="validator-integration"/>Chapter 10. Integrating with other frameworks</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="ch10.html#validator-checkconstraints-orm">10.1. ORM integration</a></span></dt><dd><dl><dt><span class="section"><a href="ch10.html#validator-checkconstraints-db">10.1.1. Database schema-level validation</a></span></dt><dt><span class="section"><a href="ch10.html#validator-checkconstraints-orm-hibernateevent">10.1.2. Hibernate event-based validation</a></span></dt><dt><span class="section"><a href="ch10.html#_jpa">10.1.3. JPA</a></span></dt></dl></dd><dt><span class="section"><a href="ch10.html#section-presentation-layer">10.2. JSF &amp; Seam</a></span></dt><dt><span class="section"><a href="ch10.html#section-integration-with-cdi">10.3. CDI</a></span></dt><dd><dl><dt><span class="section"><a href="ch10.html#_dependency_injection">10.3.1. Dependency injection</a></span></dt><dt><span class="section"><a href="ch10.html#_method_validation">10.3.2. Method validation</a></span></dt></dl></dd><dt><span class="section"><a href="ch10.html#_java_ee">10.4. Java EE</a></span></dt><dt><span class="section"><a href="ch10.html#_javafx">10.5. JavaFX</a></span></dt></dl></div><p>Hibernate Validator is intended to be used to implement multi-layered data validation, where
constraints are expressed in a single place (the annotated domain model) and checked in various
different layers of the application. For this reason there are multiple integration points with
other technologies.</p><div class="section" title="10.1. ORM integration"><div class="titlepage"><div><div><h2 class="title"><a id="validator-checkconstraints-orm"/>10.1. ORM integration</h2></div></div></div><p>Hibernate Validator integrates with both Hibernate and all pure Java Persistence providers.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>When lazy loaded associations are supposed to be validated it is recommended to place the constraint
on the getter of the association. Hibernate replaces lazy loaded associations with proxy instances
which get initialized/loaded when requested via the getter. If, in such a case, the constraint is
placed on field level the actual proxy instance is used which will lead to validation errors.</p></div><div class="section" title="10.1.1. Database schema-level validation"><div class="titlepage"><div><div><h3 class="title"><a id="validator-checkconstraints-db"/>10.1.1. Database schema-level validation</h3></div></div></div><p>Out of the box, Hibernate (as of version 3.5.x) will translate the constraints you have defined for
your entities into mapping metadata. For example, if a property of your entity is annotated
<code class="literal">@NotNull</code>, its columns will be declared as <code class="literal">not null</code> in the DDL schema generated by Hibernate.</p><p>If, for some reason, the feature needs to be disabled, set <code class="literal">hibernate.validator.apply_to_ddl</code> to
<code class="literal">false</code>. See also <a class="xref" href="ch02.html#table-spec-constraints" title="Table 2.2. Bean Validation constraints">Table 2.2, “Bean Validation constraints”</a> and <a class="xref" href="ch02.html#table-custom-constraints" title="Table 2.3. Custom constraints">Table 2.3, “Custom constraints”</a>.</p><p>You can also limit the DDL constraint generation to a subset of the defined constraints by setting
the property <code class="literal">org.hibernate.validator.group.ddl</code>. The property specifies the comma-separated, fully
specified class names of the groups a constraint has to be part of in order to be considered for DDL
schema generation.</p></div><div class="section" title="10.1.2. Hibernate event-based validation"><div class="titlepage"><div><div><h3 class="title"><a id="validator-checkconstraints-orm-hibernateevent"/>10.1.2. Hibernate event-based validation</h3></div></div></div><p>Hibernate Validator has a built-in Hibernate event listener -
<code class="literal"><a class="link" href="https://github.com/hibernate/hibernate-orm/blob/master/hibernate-core/src/main/java/org/hibernate/cfg/beanvalidation/BeanValidationEventListener.java">org.hibernate.cfg.beanvalidation.BeanValidationEventListener</a></code> -
which is part of Hibernate ORM. Whenever a <code class="literal">PreInsertEvent</code>,
<code class="literal">PreUpdateEvent</code> or <code class="literal">PreDeleteEvent</code> occurs, the listener will verify all constraints of the entity
instance and throw an exception if any constraint is violated. Per default objects will be checked
before any inserts or updates are made by Hibernate. Pre deletion events will per default not
trigger a validation. You can configure the groups to be validated per event type using the
properties <code class="literal">javax.persistence.validation.group.pre-persist</code>,
<code class="literal">javax.persistence.validation.group.pre-update</code> and <code class="literal">javax.persistence.validation.group.pre-remove</code>.
The values of these properties are the comma-separated, fully specified class names of the groups
to validate. <a class="xref" href="ch10.html#example-beanvalidationeventlistener-config" title="Example 10.1. Manual configuration of BeanValidationEvenListener">Example 10.1, “Manual configuration of <code class="literal">BeanValidationEvenListener</code>”</a> shows the default values for these
properties. In this case they could also be omitted.</p><p>On constraint violation, the event will raise a runtime <code class="literal">ConstraintViolationException</code> which contains
a set of <code class="literal">ConstraintViolation</code> instances describing each failure.</p><p>If Hibernate Validator is present in the classpath, Hibernate ORM will use it transparently.
To avoid validation even though Hibernate Validator is in the classpath set
<code class="literal">javax.persistence.validation.mode</code> to none.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>If the beans are not annotated with validation annotations, there is no runtime performance cost.</p></div><p>In case you need to manually set the event listeners for Hibernate ORM, use the following
configuration in <span class="emphasis"><em>hibernate.cfg.xml</em></span>:</p><div class="example"><a id="example-beanvalidationeventlistener-config"/><p class="title"><strong>Example 10.1. Manual configuration of <code class="literal">BeanValidationEvenListener</code></strong></p><div class="example-contents"><pre><code class="language-xml">&lt;hibernate-configuration&gt;
    &lt;session-factory&gt;
        ...
        &lt;property name="javax.persistence.validation.group.pre-persist"&gt;
            javax.validation.groups.Default
        &lt;/property&gt;
        &lt;property name="javax.persistence.validation.group.pre-update"&gt;
            javax.validation.groups.Default
        &lt;/property&gt;
        &lt;property name="javax.persistence.validation.group.pre-remove"&gt;&lt;/property&gt;
        ...
        &lt;event type="pre-update"&gt;
            &lt;listener class="org.hibernate.cfg.beanvalidation.BeanValidationEventListener"/&gt;
        &lt;/event&gt;
        &lt;event type="pre-insert"&gt;
            &lt;listener class="org.hibernate.cfg.beanvalidation.BeanValidationEventListener"/&gt;
        &lt;/event&gt;
        &lt;event type="pre-delete"&gt;
            &lt;listener class="org.hibernate.cfg.beanvalidation.BeanValidationEventListener"/&gt;
        &lt;/event&gt;
    &lt;/session-factory&gt;
&lt;/hibernate-configuration&gt;</code></pre></div></div><br class="example-break"/></div><div class="section" title="10.1.3. JPA"><div class="titlepage"><div><div><h3 class="title"><a id="_jpa"/>10.1.3. JPA</h3></div></div></div><p>If you are using JPA 2 and Hibernate Validator is in the classpath the JPA2 specification requires
that Bean Validation gets enabled. The properties <code class="literal">javax.persistence.validation.group.pre-persist</code>,
<code class="literal">javax.persistence.validation.group.pre-update</code> and <code class="literal">javax.persistence.validation.group.pre-remove</code> as
described in <a class="xref" href="ch10.html#validator-checkconstraints-orm-hibernateevent" title="10.1.2. Hibernate event-based validation">Section 10.1.2, “Hibernate event-based validation”</a> can in this case be configured in
<span class="emphasis"><em>persistence.xml</em></span>. <span class="emphasis"><em>persistence.xml</em></span> also defines a node validation-mode which can be set to <code class="literal">AUTO</code>,
<code class="literal">CALLBACK</code>, <code class="literal">NONE</code>. The default is <code class="literal">AUTO</code>.</p><p>In a JPA 1 you will have to create and register Hibernate Validator yourself. In case you are using
Hibernate EntityManager you can add a customized version of the <code class="literal">BeanValidationEventListener</code>
described in <a class="xref" href="ch10.html#validator-checkconstraints-orm-hibernateevent" title="10.1.2. Hibernate event-based validation">Section 10.1.2, “Hibernate event-based validation”</a> to your project and register it
manually.</p></div></div><div class="section" title="10.2. JSF &amp; Seam"><div class="titlepage"><div><div><h2 class="title"><a id="section-presentation-layer"/>10.2. JSF &amp; Seam</h2></div></div></div><p>When working with JSF2 or JBoss Seam and Hibernate Validator (Bean Validation) is present in the
runtime environment, validation is triggered for every field in the application. <a class="xref" href="ch10.html#example-jsf2" title="Example 10.2. Usage of Bean Validation within JSF2">Example 10.2, “Usage of Bean Validation within JSF2”</a>
shows an example of the <code class="literal">f:validateBean</code> tag in a JSF page. The <code class="literal">validationGroups</code> attribute is optional
and can be used to specify a comma separated list of validation groups. The default is
<code class="literal">javax.validation.groups.Default</code>. For more information refer to the Seam documentation or the JSF 2
specification.</p><div class="example"><a id="example-jsf2"/><p class="title"><strong>Example 10.2. Usage of Bean Validation within JSF2</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;h:form&gt;

  &lt;f:validateBean validationGroups="javax.validation.groups.Default"&gt;

    &lt;h:inputText value=#{model.property}/&gt;
    &lt;h:selectOneRadio value=#{model.radioProperty}&gt; ... &lt;/h:selectOneRadio&gt;
    &lt;!-- other input components here --&gt;

  &lt;/f:validateBean&gt;

&lt;/h:form&gt;</code></pre></div></div><br class="example-break"/><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>The integration between JSF 2 and Bean Validation is described in the "Bean Validation Integration"
chapter of <a class="link" href="http://jcp.org/en/jsr/detail?id=314">JSR-314</a>. It is interesting to know that JSF
2 implements a custom <code class="literal">MessageInterpolator</code> to ensure ensure proper localization. To encourage the use
of the Bean Validation message facility, JSF 2 will per default only display the generated Bean
Validation message. This can, however, be configured via the application resource bundle by
providing the following configuration (<code class="literal">{0}</code> is replaced with the Bean Validation message and <code class="literal">{1}</code> is
replaced with the JSF component label):</p><pre class="screen">javax.faces.validator.BeanValidator.MESSAGE={1}: {0}</pre><p>The default is:</p><pre class="screen">javax.faces.validator.BeanValidator.MESSAGE={0}</pre></div></div><div class="section" title="10.3. CDI"><div class="titlepage"><div><div><h2 class="title"><a id="section-integration-with-cdi"/>10.3. CDI</h2></div></div></div><p>As of version 1.1, Bean Validation is integrated with CDI (Contexts and Dependency Injection for
Java<sup>TM</sup> EE).</p><p>This integration provides CDI managed beans for <code class="literal">Validator</code> and <code class="literal">ValidatorFactory</code> and enables
dependency injection in constraint validators as well as custom message interpolators, traversable
resolvers, constraint validator factories and parameter name providers.</p><p>Furthermore, parameter and return value constraints on the methods and constructors of CDI managed
beans will automatically be validated upon invocation.</p><p>When your application runs on a Jave EE container, this integration is enabled by default. When
working with CDI in a Servlet container or in a pure Java SE environment, you can use the CDI
portable extension provided by Hibernate Validator. To do so, add the portable extension to your
class path as described in <a class="xref" href="ch01.html#section-getting-started-cdi" title="1.1.2. CDI">Section 1.1.2, “CDI”</a>.</p><div class="section" title="10.3.1. Dependency injection"><div class="titlepage"><div><div><h3 class="title"><a id="_dependency_injection"/>10.3.1. Dependency injection</h3></div></div></div><p>CDI’s dependency injection mechanism makes it very easy to retrieve <code class="literal">ValidatorFactory</code> and <code class="literal">Validator</code>
instances and use them in your managed beans. Just annotate instance fields of your bean with
<code class="literal">@javax.inject.Inject</code> as shown in <a class="xref" href="ch10.html#example-dependency-injection" title="Example 10.3. Retrieving validator factory and validator via @Inject">Example 10.3, “Retrieving validator factory and validator via <code class="literal">@Inject</code>”</a>.</p><div class="example"><a id="example-dependency-injection"/><p class="title"><strong>Example 10.3. Retrieving validator factory and validator via <code class="literal">@Inject</code></strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter10.cdi.validator;

@ApplicationScoped
public class RentalStation {

	@Inject
	private ValidatorFactory validatorFactory;

	@Inject
	private Validator validator;

	//...
}</code></pre></div></div><br class="example-break"/><p>The injected beans are the default validator factory and validator instances. In order to configure
them - e.g. to use a custom message interpolator - you can use the Bean Validation XML descriptors
as discussed in <a class="xref" href="ch07.html" title="Chapter 7. Configuring via XML">Chapter 7, <em>Configuring via XML</em></a>.</p><p>If you are working with several Bean Validation providers you can make sure that factory and
validator from Hibernate Validator are injected by annotating the injection points with the
<code class="literal">@HibernateValidator</code> qualifier which is demonstrated in <a class="xref" href="ch10.html#example-dependency-injection-using-hv" title="Example 10.4. Using the @HibernateValidator qualifier annotation">Example 10.4, “Using the <code class="literal">@HibernateValidator</code> qualifier annotation”</a>.</p><div class="example"><a id="example-dependency-injection-using-hv"/><p class="title"><strong>Example 10.4. Using the <code class="literal">@HibernateValidator</code> qualifier annotation</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter10.cdi.validator.qualifier;

@ApplicationScoped
public class RentalStation {

	@Inject
	@HibernateValidator
	private ValidatorFactory validatorFactory;

	@Inject
	@HibernateValidator
	private Validator validator;

	//...
}</code></pre></div></div><br class="example-break"/><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>The fully-qualified name of the qualifier annotation is
<code class="literal">org.hibernate.validator.cdi.HibernateValidator</code>. Be sure to not import
<code class="literal">org.hibernate.validator.HibernateValidator</code> instead which is the <code class="literal">ValidationProvider</code> implementation
used for selecting Hibernate Validator when working with the bootstrapping API (see
<a class="xref" href="ch08.html#section-retrieving-validator-factory-validator" title="8.1. Retrieving ValidatorFactory and Validator">Section 8.1, “Retrieving <code class="literal">ValidatorFactory</code> and <code class="literal">Validator</code>”</a>).</p></div><p>Via <code class="literal">@Inject</code> you also can inject dependencies into constraint validators and other Bean Validation
objects such as <code class="literal">MessageInterpolator</code> implementations etc.</p><p><a class="xref" href="ch10.html#example-constraint-validator-injected-bean" title="Example 10.5. Constraint validator with injected bean">Example 10.5, “Constraint validator with injected bean”</a>
demonstrates how an injected CDI bean is used in a <code class="literal">ConstraintValidator</code> implementation to determine
whether the given constraint is valid or not. As the example shows, you also can work with the
<code class="literal">@PostConstruct</code> and <code class="literal">@PreDestroy</code> callbacks to implement any required construction and destruction
logic.</p><div class="example"><a id="example-constraint-validator-injected-bean"/><p class="title"><strong>Example 10.5. Constraint validator with injected bean</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter10.cdi.injection;

public class ValidLicensePlateValidator
		implements ConstraintValidator&lt;ValidLicensePlate, String&gt; {

	@Inject
	private VehicleRegistry vehicleRegistry;

	@PostConstruct
	public void postConstruct() {
		//do initialization logic...
	}

	@PreDestroy
	public void preDestroy() {
		//do destruction logic...
	}

	@Override
	public void initialize(ValidLicensePlate constraintAnnotation) {
	}

	@Override
	public boolean isValid(String licensePlate, ConstraintValidatorContext constraintContext) {
		return vehicleRegistry.isValidLicensePlate( licensePlate );
	}
}</code></pre></div></div><br class="example-break"/></div><div class="section" title="10.3.2. Method validation"><div class="titlepage"><div><div><h3 class="title"><a id="_method_validation"/>10.3.2. Method validation</h3></div></div></div><p>The method interception facilities of CDI allow for a very tight integration with Bean Validation’s
method validation functionality. Just put constraint annotations to the parameters and return values
of the executables of your CDI beans and they will be validated automatically before (parameter
constraints) and after (return value constraints) a method or constructor is invoked.</p><p>Note that no explicit interceptor binding is required, instead the required method validation
interceptor will automatically be registered for all managed beans with constrained methods and
constructors.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>The interceptor <code class="literal">org.hibernate.validator.internal.cdi.interceptor.ValidationInterceptor</code> is
registered by <code class="literal">org.hibernate.validator.internal.cdi.ValidationExtension</code>. This happens implicitly
within a Java EE 7 runtime environment or explicitly by adding the <span class="emphasis"><em>hibernate-validator-cdi</em></span> artifact
- see <a class="xref" href="ch01.html#section-getting-started-cdi" title="1.1.2. CDI">Section 1.1.2, “CDI”</a></p></div><p>You can see an example in <a class="xref" href="ch10.html#example-cdi-method-validation" title="Example 10.6. CDI managed beans with method-level constraints">Example 10.6, “CDI managed beans with method-level constraints”</a>.</p><div class="example"><a id="example-cdi-method-validation"/><p class="title"><strong>Example 10.6. CDI managed beans with method-level constraints</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter10.cdi.methodvalidation;

@ApplicationScoped
public class RentalStation {

	@Valid
	public RentalStation() {
		//...
	}

	@NotNull
	@Valid
	public Car rentCar(
			@NotNull Customer customer,
			@NotNull @Future Date startDate,
			@Min(1) int durationInDays) {
		//...
	}

	@NotNull
	List&lt;Car&gt; getAvailableCars() {
		//...
	}
}</code></pre><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter10.cdi.methodvalidation;

@RequestScoped
public class RentCarRequest {

	@Inject
	private RentalStation rentalStation;

	public void rentCar(String customerId, Date startDate, int duration) {
		//causes ConstraintViolationException
		rentalStation.rentCar( null, null, -1 );
	}
}</code></pre></div></div><br class="example-break"/><p>Here the <code class="literal">RentalStation</code> bean hosts several method constraints. When invoking one of the <code class="literal">RentalStation</code>
methods from another bean such as <code class="literal">RentCarRequest</code>, the constraints of the invoked method are
automatically validated. If any illegal parameter values are passed as in the example, a
<code class="literal">ConstraintViolationException</code> will be thrown by the method interceptor, providing detailed
information on the violated constraints. The same is the case if the method’s return value violates
any return value constraints.</p><p>Similarly, constructor constraints are validated automatically upon invocation. In the example the
<code class="literal">RentalStation</code> object returned by the constructor will be validated since the constructor return
value is marked with <code class="literal">@Valid</code>.</p><div class="section" title="10.3.2.1. Validated executable types"><div class="titlepage"><div><div><h4 class="title"><a id="_validated_executable_types"/>10.3.2.1. Validated executable types</h4></div></div></div><p>Bean Validation allows for a fine-grained control of the executable types which are automatically
validated. By default, constraints on constructors and non-getter methods are validated. Therefore
the <code class="literal">@NotNull</code> constraint on the method <code class="literal">RentalStation#getAvailableCars()</code> in
<a class="xref" href="ch10.html#example-cdi-method-validation" title="Example 10.6. CDI managed beans with method-level constraints">Example 10.6, “CDI managed beans with method-level constraints”</a> gets not validated when the method is invoked.</p><p>You have the following options to configure which types of executables are validated upon
invocation:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Configure the executable types globally via the XML descriptor <span class="emphasis"><em>META-INF/validation.xml</em></span>;
see <a class="xref" href="ch07.html#section-configuration-validation-xml" title="7.1. Configuring the validator factory in validation.xml">Section 7.1, “Configuring the validator factory in <span class="emphasis"><em>validation.xml</em></span>”</a> for an example</li><li class="listitem">Use the <code class="literal">@ValidateOnExecution</code> annotation on the executable or type level</li></ul></div><p>If several sources of configuration are specified for a given executable, <code class="literal">@ValidateOnExecutionn on
the executable level takes precedence over `@ValidateOnExecution</code> on the type level and
<code class="literal">@ValidateOnExecution</code> generally takes precedence over the globally configured types in <span class="emphasis"><em>META-
INF/validation.xml</em></span>.</p><p><a class="xref" href="ch10.html#example-using-validateonexecution" title="Example 10.7. Using @ValidateOnExecution">Example 10.7, “Using <code class="literal">@ValidateOnExecution</code>”</a> shows how to use the <code class="literal">@ValidateOnExecution</code> annotation:</p><div class="example"><a id="example-using-validateonexecution"/><p class="title"><strong>Example 10.7. Using <code class="literal">@ValidateOnExecution</code></strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter10.cdi.methodvalidation.configuration;

@ApplicationScoped
@ValidateOnExecution(type = ExecutableType.ALL)
public class RentalStation {

	@Valid
	public RentalStation() {
		//...
	}

	@NotNull
	@Valid
	@ValidateOnExecution(type = ExecutableType.NONE)
	public Car rentCar(
			@NotNull Customer customer,
			@NotNull @Future Date startDate,
			@Min(1) int durationInDays) {
		//...
	}

	@NotNull
	public List&lt;Car&gt; getAvailableCars() {
		//...
	}
}</code></pre></div></div><br class="example-break"/><p>Here the method <code class="literal">rentCar()</code> won’t be validated upon invocation because it is annotated with
<code class="literal">@ValidateOnExecution(type = ExecutableType.NONE)</code>. In contrast, the constructor and the
method <code class="literal">getAvailableCars()</code> will be validated due to <code class="literal">@ValidateOnExecution(type =
ExecutableType.ALL)</code> being given on the type level. <code class="literal">ExecutableType.ALL</code> is a more compact form for
explicitly specifying all the types <code class="literal">CONSTRUCTORS</code>, <code class="literal">GETTER_METHODS</code> and <code class="literal">NON_GETTER_METHODS</code>.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>Executable validation can be turned off globally by specifying
<code class="literal">&lt;executable-validation enabled="false"/&gt;</code> in <span class="emphasis"><em>META-INF/validation.xml</em></span>. In this case, any
<code class="literal">@ValidateOnExecution</code> annotations are ignored.</p></div><p>Note that when a method overrides or implements a super-type method the configuration will be taken
from that overridden or implemented method (as given via <code class="literal">@ValidateOnExecution</code> on the method itself
or on the super-type). This protects a client of the super-type method from an unexpected alteration
of the configuration, e.g. disabling validation of an overridden executable in a sub-type.</p><p>In case a CDI managed bean overrides or implements a super-type method and this super-type method
hosts any constraints, it can happen that the validation interceptor is not properly registered with
the bean, resulting in the bean’s methods not being validated upon invocation. In this case you can
specify the executable type <code class="literal">IMPLICIT</code> on the sub-class as shown in
<a class="xref" href="ch10.html#example-using-executabletype-implicit" title="Example 10.8. Using ExecutableType.IMPLICIT">Example 10.8, “Using <code class="literal">ExecutableType.IMPLICIT</code>”</a>, which makes sure that all required metadata is discovered
an the validation interceptor kicks in when the methods on <code class="literal">ExpressRentalStation</code> are invoked.</p><div class="example"><a id="example-using-executabletype-implicit"/><p class="title"><strong>Example 10.8. Using <code class="literal">ExecutableType.IMPLICIT</code></strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter10.cdi.methodvalidation.implicit;

@ValidateOnExecution(type = ExecutableType.ALL)
public interface RentalStation {

	@NotNull
	@Valid
	Car rentCar(
			@NotNull Customer customer,
			@NotNull @Future Date startDate,
			@Min(1) int durationInDays);
}</code></pre><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter10.cdi.methodvalidation.implicit;

@ApplicationScoped
@ValidateOnExecution(type = ExecutableType.IMPLICIT)
public class ExpressRentalStation implements RentalStation {

	@Override
	public Car rentCar(Customer customer, Date startDate, @Min(1) int durationInDays) {
		//...
	}
}</code></pre></div></div><br class="example-break"/></div></div></div><div class="section" title="10.4. Java EE"><div class="titlepage"><div><div><h2 class="title"><a id="_java_ee"/>10.4. Java EE</h2></div></div></div><p>When your application runs on a Java EE application server such as <a class="link" href="WildFly"/><a class="link" href="http://wildfly.org/">http://wildfly.org/</a><a class="link" href="WildFly"/>,
you also can obtain <code class="literal">Validator</code> and <code class="literal">ValidatorFactory</code> instances via <code class="literal">@Resource</code> injection in
managed objects such as EJBs etc., as shown in <a class="xref" href="ch10.html#example-validator-resource-injection" title="Example 10.9. Retrieving Validator and ValidatorFactory via @Resource injection">Example 10.9, “Retrieving <code class="literal">Validator</code> and <code class="literal">ValidatorFactory</code> via <code class="literal">@Resource</code> injection”</a>.</p><div class="example"><a id="example-validator-resource-injection"/><p class="title"><strong>Example 10.9. Retrieving <code class="literal">Validator</code> and <code class="literal">ValidatorFactory</code> via <code class="literal">@Resource</code> injection</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter10.javaee;

@Stateless
public class RentalStationBean {

	@Resource
	private ValidatorFactory validatorFactory;

	@Resource
	private Validator validator;

	//...
}</code></pre></div></div><br class="example-break"/><p>Alternatively you can obtain a validator and a validator factory from JNDI under the names
"<span class="emphasis"><em>java:comp/Validator</em></span>" and "<span class="emphasis"><em>java:comp/ValidatorFactory</em></span>", respectively.</p><p>Similar to CDI-based injection via <code class="literal">@Inject</code>, these objects represent default validator and validator
factory and thus can be configured using the XML descriptor <span class="emphasis"><em>META-INF/validation.xml</em></span> (see
<a class="xref" href="ch07.html" title="Chapter 7. Configuring via XML">Chapter 7, <em>Configuring via XML</em></a>).</p><p>When your application is CDI-enabled, the injected objects are CDI-aware as well and e.g. support
dependency injection in constraint validators.</p></div><div class="section" title="10.5. JavaFX"><div class="titlepage"><div><div><h2 class="title"><a id="_javafx"/>10.5. JavaFX</h2></div></div></div><p>Hibernate Validator also provides support for the unwrapping of JavaFX properties. If JavaFX is present
on the classpath a <code class="literal">ValidatedValueUnwrapper</code> for JavaFX properties is automatically registered. In some
cases, however, it is also necessary to explicitly use <code class="literal">@UnwrapValidatedValue</code>. This is required if
the constraint validator resolution is not unique and there is a potential constraint validator for
the actual JavaFX property as well as the contained property value itself.
See <a class="xref" href="ch11.html#section-javafx-unwrapper" title="11.11.2. JavaFX unwrapper">Section 11.11.2, “JavaFX unwrapper”</a> for examples and further discussion.</p></div></div><script xmlns="" xmlns:d="http://docbook.org/ns/docbook" type="text/javascript" src="highlight.js/highlight.pack.js"> </script><script xmlns="" xmlns:d="http://docbook.org/ns/docbook" type="text/javascript">hljs.initHighlightingOnLoad();</script><script type="text/javascript">
dataLayer = [{'channel' : 'Hibernate', 'additional_tracking_code' : 'UA-45270411-3'}];
(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-NJWS5L');</script><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-NJWS5L" height="0" width="0" style="display:none;visibility:hidden"> </iframe></noscript><hr xmlns="" xmlns:d="http://docbook.org/ns/docbook"/><a xmlns="" xmlns:d="http://docbook.org/ns/docbook" href="legalnotice.html"/><ul class="docnav"><li class="previous"><a accesskey="p" href="ch09.html"><strong>Prev</strong>Chapter 9. Using constraint metadata</a></li><li class="up"><a accesskey="u" href="#"><strong>Up</strong></a></li><li class="home"><a accesskey="h" href="index.html"><strong>Home</strong></a></li><li class="next"><a accesskey="n" href="ch11.html"><strong>Next</strong>Chapter 11. Hibernate Validator Specifics</a></li></ul></body></html>