<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<!DOCTYPE html
  PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Hibernate Validator 5.2.4.Final</title><link rel="stylesheet" type="text/css" href="css/hibernate-single.css"/><meta name="generator" content="DocBook XSL-NS Stylesheets V1.76.1"/><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/></head><body><div xml:lang="en" class="book" title="Hibernate Validator 5.2.4.Final"><div class="titlepage"><div><p id="title"><a href="http://www.hibernate.org" class="site_href"><strong>Hibernate.org</strong></a><a href="http://hibernate.org/Documentation/DocumentationOverview" class="doc_href"><strong>Community Documentation</strong></a></p><div><h1 class="title"><a id="d0e3"/>Hibernate Validator 5.2.4.Final</h1></div><div><h2 class="subtitle">JSR 349 Reference Implementation</h2></div><div><h2 class="subtitle">Reference Guide</h2></div><div><div class="authorgroup"><div class="author"><h3 class="author"><span class="firstname">Hardy</span> <span class="surname">Ferentschik</span></h3></div><div class="author"><h3 class="author"><span class="firstname">Gunnar</span> <span class="surname">Morling</span></h3></div></div></div><div><p class="pubdate">2016-02-17</p></div></div><hr/></div><div class="toc"><dl><dt><span class="preface"><a href="#preface">Preface</a></span></dt><dt><span class="chapter"><a href="#validator-gettingstarted">1. Getting started</a></span></dt><dd><dl><dt><span class="section"><a href="#validator-gettingstarted-createproject">1.1. Project set up</a></span></dt><dd><dl><dt><span class="section"><a href="#validator-gettingstarted-uel">1.1.1. Unified EL</a></span></dt><dt><span class="section"><a href="#section-getting-started-cdi">1.1.2. CDI</a></span></dt><dt><span class="section"><a href="#section-getting-started-security-manager">1.1.3. Running with a security manager</a></span></dt></dl></dd><dt><span class="section"><a href="#validator-gettingstarted-createmodel">1.2. Applying constraints</a></span></dt><dt><span class="section"><a href="#_validating_constraints">1.3. Validating constraints</a></span></dt><dt><span class="section"><a href="#_java_8_support">1.4. Java 8 support</a></span></dt><dd><dl><dt><span class="section"><a href="#_type_arguments_constraints">1.4.1. Type arguments constraints</a></span></dt><dt><span class="section"><a href="#_actual_parameter_names">1.4.2. Actual parameter names</a></span></dt><dt><span class="section"><a href="#_new_date_time_api">1.4.3. New date/time API</a></span></dt><dt><span class="section"><a href="#_optional_type">1.4.4. Optional type</a></span></dt></dl></dd><dt><span class="section"><a href="#validator-gettingstarted-whatsnext">1.5. Where to go next?</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chapter-bean-constraints">2. Declaring and validating bean constraints</a></span></dt><dd><dl><dt><span class="section"><a href="#section-declaring-bean-constraints">2.1. Declaring bean constraints</a></span></dt><dd><dl><dt><span class="section"><a href="#_field_level_constraints">2.1.1. Field-level constraints</a></span></dt><dt><span class="section"><a href="#_property_level_constraints">2.1.2. Property-level constraints</a></span></dt><dt><span class="section"><a href="#type-arguments-constraints">2.1.3. Type argument constraints</a></span></dt><dt><span class="section"><a href="#validator-usingvalidator-classlevel">2.1.4. Class-level constraints</a></span></dt><dt><span class="section"><a href="#section-constraint-inheritance">2.1.5. Constraint inheritance</a></span></dt><dt><span class="section"><a href="#section-object-graph-validation">2.1.6. Object graphs</a></span></dt></dl></dd><dt><span class="section"><a href="#section-validating-bean-constraints">2.2. Validating bean constraints</a></span></dt><dd><dl><dt><span class="section"><a href="#section-obtaining-validator">2.2.1. Obtaining a <code class="literal">Validator</code> instance</a></span></dt><dt><span class="section"><a href="#_validator_methods">2.2.2. Validator methods</a></span></dt><dt><span class="section"><a href="#section-constraint-violation-methods">2.2.3. <code class="literal">ConstraintViolation</code> methods</a></span></dt></dl></dd><dt><span class="section"><a href="#section-builtin-constraints">2.3. Built-in constraints</a></span></dt><dd><dl><dt><span class="section"><a href="#validator-defineconstraints-spec">2.3.1. Bean Validation constraints</a></span></dt><dt><span class="section"><a href="#validator-defineconstraints-hv-constraints">2.3.2. Additional constraints</a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#chapter-method-constraints">3. Declaring and validating method constraints</a></span></dt><dd><dl><dt><span class="section"><a href="#section-declaring-method-constraints">3.1. Declaring method constraints</a></span></dt><dd><dl><dt><span class="section"><a href="#_parameter_constraints">3.1.1. Parameter constraints</a></span></dt><dt><span class="section"><a href="#_return_value_constraints">3.1.2. Return value constraints</a></span></dt><dt><span class="section"><a href="#_cascaded_validation">3.1.3. Cascaded validation</a></span></dt><dt><span class="section"><a href="#_method_constraints_in_inheritance_hierarchies">3.1.4. Method constraints in inheritance hierarchies</a></span></dt></dl></dd><dt><span class="section"><a href="#section-validating-executable-constraints">3.2. Validating method constraints</a></span></dt><dd><dl><dt><span class="section"><a href="#section-obtaining-executable-validator">3.2.1. Obtaining an <code class="literal">ExecutableValidator</code> instance</a></span></dt><dt><span class="section"><a href="#section-executable-validator-methods">3.2.2. <code class="literal">ExecutableValidator</code> methods</a></span></dt><dt><span class="section"><a href="#__literal_constraintviolation_literal_methods_for_method_validation">3.2.3. <code class="literal">ConstraintViolation</code> methods for method validation</a></span></dt></dl></dd><dt><span class="section"><a href="#section-builtin-method-constraints">3.3. Built-in method constraints</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chapter-message-interpolation">4. Interpolating constraint error messages</a></span></dt><dd><dl><dt><span class="section"><a href="#section-message-interpolation">4.1. Default message interpolation</a></span></dt><dd><dl><dt><span class="section"><a href="#section-special-characters">4.1.1. Special characters</a></span></dt><dt><span class="section"><a href="#section-interpolation-with-message-expressions">4.1.2. Interpolation with message expressions</a></span></dt><dt><span class="section"><a href="#_examples">4.1.3. Examples</a></span></dt></dl></dd><dt><span class="section"><a href="#section-custom-message-interpolation">4.2. Custom message interpolation</a></span></dt><dd><dl><dt><span class="section"><a href="#section-resource-bundle-locator">4.2.1. <code class="literal">ResourceBundleLocator</code></a></span></dt></dl></dd></dl></dd><dt><span class="chapter"><a href="#chapter-groups">5. Grouping constraints</a></span></dt><dd><dl><dt><span class="section"><a href="#_requesting_groups">5.1. Requesting groups</a></span></dt><dt><span class="section"><a href="#section-defining-group-sequences">5.2. Defining group sequences</a></span></dt><dt><span class="section"><a href="#section-default-group-class">5.3. Redefining the default group sequence</a></span></dt><dd><dl><dt><span class="section"><a href="#__literal_groupsequence_literal">5.3.1. <code class="literal">@GroupSequence</code></a></span></dt><dt><span class="section"><a href="#__literal_groupsequenceprovider_literal">5.3.2. <code class="literal">@GroupSequenceProvider</code></a></span></dt></dl></dd><dt><span class="section"><a href="#section-group-conversion">5.4. Group conversion</a></span></dt></dl></dd><dt><span class="chapter"><a href="#validator-customconstraints">6. Creating custom constraints</a></span></dt><dd><dl><dt><span class="section"><a href="#validator-customconstraints-simple">6.1. Creating a simple constraint</a></span></dt><dd><dl><dt><span class="section"><a href="#validator-customconstraints-constraintannotation">6.1.1. The constraint annotation</a></span></dt><dt><span class="section"><a href="#section-constraint-validator">6.1.2. The constraint validator</a></span></dt><dt><span class="section"><a href="#validator-customconstraints-errormessage">6.1.3. The error message</a></span></dt><dt><span class="section"><a href="#validator-customconstraints-using">6.1.4. Using the constraint</a></span></dt></dl></dd><dt><span class="section"><a href="#section-class-level-constraints">6.2. Class-level constraints</a></span></dt><dd><dl><dt><span class="section"><a href="#section-custom-property-paths">6.2.1. Custom property paths</a></span></dt></dl></dd><dt><span class="section"><a href="#section-cross-parameter-constraints">6.3. Cross-parameter constraints</a></span></dt><dt><span class="section"><a href="#section-constraint-composition">6.4. Constraint composition</a></span></dt></dl></dd><dt><span class="chapter"><a href="#chapter-xml-configuration">7. Configuring via XML</a></span></dt><dd><dl><dt><span class="section"><a href="#section-configuration-validation-xml">7.1. Configuring the validator factory in <span class="emphasis"><em>validation.xml</em></span></a></span></dt><dt><span class="section"><a href="#section-mapping-xml-constraints">7.2. Mapping constraints via <code class="literal">constraint-mappings</code></a></span></dt></dl></dd><dt><span class="chapter"><a href="#chapter-bootstrapping">8. Bootstrapping</a></span></dt><dd><dl><dt><span class="section"><a href="#section-retrieving-validator-factory-validator">8.1. Retrieving <code class="literal">ValidatorFactory</code> and <code class="literal">Validator</code></a></span></dt><dd><dl><dt><span class="section"><a href="#section-validation-provider-resolver">8.1.1. <code class="literal">ValidationProviderResolver</code></a></span></dt></dl></dd><dt><span class="section"><a href="#section-configuring-validator-factory">8.2. Configuring a <code class="literal">ValidatorFactory</code></a></span></dt><dd><dl><dt><span class="section"><a href="#section-validator-factory-message-interpolator">8.2.1. <code class="literal">MessageInterpolator</code></a></span></dt><dt><span class="section"><a href="#__literal_traversableresolver_literal">8.2.2. <code class="literal">TraversableResolver</code></a></span></dt><dt><span class="section"><a href="#__literal_constraintvalidatorfactory_literal">8.2.3. <code class="literal">ConstraintValidatorFactory</code></a></span></dt><dt><span class="section"><a href="#section-parameter-name-provider">8.2.4. <code class="literal">ParameterNameProvider</code></a></span></dt><dt><span class="section"><a href="#_adding_mapping_streams">8.2.5. Adding mapping streams</a></span></dt><dt><span class="section"><a href="#section-provider-specific-settings">8.2.6. Provider-specific settings</a></span></dt></dl></dd><dt><span class="section"><a href="#section-configuring-validator">8.3. Configuring a Validator</a></span></dt></dl></dd><dt><span class="chapter"><a href="#validator-metadata-api">9. Using constraint metadata</a></span></dt><dd><dl><dt><span class="section"><a href="#__literal_beandescriptor_literal">9.1. <code class="literal">BeanDescriptor</code></a></span></dt><dt><span class="section"><a href="#section-property-descriptor">9.2. <code class="literal">PropertyDescriptor</code></a></span></dt><dt><span class="section"><a href="#__literal_methoddescriptor_literal_and_literal_constructordescriptor_literal">9.3. <code class="literal">MethodDescriptor</code> and <code class="literal">ConstructorDescriptor</code></a></span></dt><dt><span class="section"><a href="#validator-metadata-api-elementdescriptor">9.4. <code class="literal">ElementDescriptor</code></a></span></dt><dt><span class="section"><a href="#section-group-conversion-descriptor">9.5. <code class="literal">GroupConversionDescriptor</code></a></span></dt><dt><span class="section"><a href="#section-constraint-descriptor">9.6. <code class="literal">ConstraintDescriptor</code></a></span></dt></dl></dd><dt><span class="chapter"><a href="#validator-integration">10. Integrating with other frameworks</a></span></dt><dd><dl><dt><span class="section"><a href="#validator-checkconstraints-orm">10.1. ORM integration</a></span></dt><dd><dl><dt><span class="section"><a href="#validator-checkconstraints-db">10.1.1. Database schema-level validation</a></span></dt><dt><span class="section"><a href="#validator-checkconstraints-orm-hibernateevent">10.1.2. Hibernate event-based validation</a></span></dt><dt><span class="section"><a href="#_jpa">10.1.3. JPA</a></span></dt></dl></dd><dt><span class="section"><a href="#section-presentation-layer">10.2. JSF &amp; Seam</a></span></dt><dt><span class="section"><a href="#section-integration-with-cdi">10.3. CDI</a></span></dt><dd><dl><dt><span class="section"><a href="#_dependency_injection">10.3.1. Dependency injection</a></span></dt><dt><span class="section"><a href="#_method_validation">10.3.2. Method validation</a></span></dt></dl></dd><dt><span class="section"><a href="#_java_ee">10.4. Java EE</a></span></dt><dt><span class="section"><a href="#_javafx">10.5. JavaFX</a></span></dt></dl></dd><dt><span class="chapter"><a href="#validator-specifics">11. Hibernate Validator Specifics</a></span></dt><dd><dl><dt><span class="section"><a href="#_public_api">11.1. Public API</a></span></dt><dt><span class="section"><a href="#section-fail-fast">11.2. Fail fast mode</a></span></dt><dt><span class="section"><a href="#section-programmatic-api">11.3. Programmatic constraint declaration</a></span></dt><dt><span class="section"><a href="#section-programmatic-api-contributor">11.4. Applying programmatic constraint declarations to the default validator factory</a></span></dt><dt><span class="section"><a href="#section-advanced-constraint-composition">11.5. Advanced constraint composition features</a></span></dt><dd><dl><dt><span class="section"><a href="#_validation_target_specification_for_purely_composed_constraints">11.5.1. Validation target specification for purely composed constraints</a></span></dt><dt><span class="section"><a href="#section-boolean-constraint-composition">11.5.2. Boolean composition of constraints</a></span></dt></dl></dd><dt><span class="section"><a href="#section-extensions-path-api">11.6. Extensions of the Path API</a></span></dt><dt><span class="section"><a href="#non-el-message-interpolator">11.7. <code class="literal">ParameterMessageInterpolator</code></a></span></dt><dt><span class="section"><a href="#__literal_resourcebundlelocator_literal">11.8. <code class="literal">ResourceBundleLocator</code></a></span></dt><dt><span class="section"><a href="#_custom_contexts">11.9. Custom contexts</a></span></dt><dd><dl><dt><span class="section"><a href="#section-hibernateconstraintvalidatorcontext">11.9.1. <code class="literal">HibernateConstraintValidatorContext</code></a></span></dt><dt><span class="section"><a href="#__literal_hibernatemessageinterpolatorcontext_literal">11.9.2. <code class="literal">HibernateMessageInterpolatorContext</code></a></span></dt></dl></dd><dt><span class="section"><a href="#section-paranamer-parameternameprovider">11.10. ParaNamer based <code class="literal">ParameterNameProvider</code></a></span></dt><dt><span class="section"><a href="#section-value-handling">11.11. Unwrapping values</a></span></dt><dd><dl><dt><span class="section"><a href="#section-optional-unwrapper">11.11.1. Optional unwrapper</a></span></dt><dt><span class="section"><a href="#section-javafx-unwrapper">11.11.2. JavaFX unwrapper</a></span></dt><dt><span class="section"><a href="#_unwrapping_object_graphs">11.11.3. Unwrapping object graphs</a></span></dt></dl></dd><dt><span class="section"><a href="#section-constraint-definition-contribution">11.12. Providing constraint definitions</a></span></dt><dd><dl><dt><span class="section"><a href="#_constraint_definitions_via_literal_serviceloader_literal">11.12.1. Constraint definitions via <code class="literal">ServiceLoader</code></a></span></dt><dt><span class="section"><a href="#section-constraint-definition-contributor">11.12.2. Constraint definitions via <code class="literal">ConstraintDefinitionContributor</code></a></span></dt></dl></dd><dt><span class="section"><a href="#section-constraint-customizing-class-loading">11.13. Customizing class-loading</a></span></dt><dt><span class="section"><a href="#section-time-provider">11.14. Time providers for <code class="literal">@Future</code> and <code class="literal">@Past</code></a></span></dt></dl></dd><dt><span class="chapter"><a href="#validator-annotation-processor">12. Annotation Processor</a></span></dt><dd><dl><dt><span class="section"><a href="#validator-annotationprocessor-prerequisites">12.1. Prerequisites</a></span></dt><dt><span class="section"><a href="#validator-annotationprocessor-features">12.2. Features</a></span></dt><dt><span class="section"><a href="#validator-annotationprocessor-options">12.3. Options</a></span></dt><dt><span class="section"><a href="#validator-annotationprocessor-usage">12.4. Using the Annotation Processor</a></span></dt><dd><dl><dt><span class="section"><a href="#validator-annotationprocessor-commandline">12.4.1. Command line builds</a></span></dt><dt><span class="section"><a href="#validator-annotationprocessor-ide">12.4.2. IDE builds</a></span></dt></dl></dd><dt><span class="section"><a href="#validator-annotationprocessor-known-issues">12.5. Known issues</a></span></dt></dl></dd><dt><span class="chapter"><a href="#validator-further-reading">13. Further reading</a></span></dt></dl></div><div class="preface" title="Preface"><div class="titlepage"><div><div><h2 class="title"><a id="preface"/>Preface</h2></div></div></div><p>Validating data is a common task that occurs throughout all application layers, from the
presentation to the persistence layer. Often the same validation logic is implemented in each layer
which is time consuming and error-prone. To avoid duplication of these validations, developers often
bundle validation logic directly into the domain model, cluttering domain classes with validation
code which is really metadata about the class itself.</p><div class="informalfigure"><div class="mediaobject"><img src="images/application-layers.png" alt="application layers"/></div></div><p>JSR 349 - Bean Validation 1.1 - defines a metadata model and API for entity and method validation.
The default metadata source are annotations, with the ability to override and extend the meta-data
through the use of XML. The API is not tied to a specific application tier nor programming model. It
is specifically not tied to either web or persistence tier, and is available for both server-side
application programming, as well as rich client Swing application developers.</p><div class="informalfigure"><div class="mediaobject"><img src="images/application-layers2.png" alt="application layers2"/></div></div><p>Hibernate Validator is the reference implementation of this JSR 349. The implementation itself as
well as the Bean Validation API and TCK are all provided and distributed under the
<a class="link" href="http://www.apache.org/licenses/LICENSE-2.0">Apache Software License 2.0</a>.</p></div><div class="chapter" title="Chapter 1. Getting started"><div class="titlepage"><div><div><h2 class="title"><a id="validator-gettingstarted"/>Chapter 1. Getting started</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#validator-gettingstarted-createproject">1.1. Project set up</a></span></dt><dd><dl><dt><span class="section"><a href="#validator-gettingstarted-uel">1.1.1. Unified EL</a></span></dt><dt><span class="section"><a href="#section-getting-started-cdi">1.1.2. CDI</a></span></dt><dt><span class="section"><a href="#section-getting-started-security-manager">1.1.3. Running with a security manager</a></span></dt></dl></dd><dt><span class="section"><a href="#validator-gettingstarted-createmodel">1.2. Applying constraints</a></span></dt><dt><span class="section"><a href="#_validating_constraints">1.3. Validating constraints</a></span></dt><dt><span class="section"><a href="#_java_8_support">1.4. Java 8 support</a></span></dt><dd><dl><dt><span class="section"><a href="#_type_arguments_constraints">1.4.1. Type arguments constraints</a></span></dt><dt><span class="section"><a href="#_actual_parameter_names">1.4.2. Actual parameter names</a></span></dt><dt><span class="section"><a href="#_new_date_time_api">1.4.3. New date/time API</a></span></dt><dt><span class="section"><a href="#_optional_type">1.4.4. Optional type</a></span></dt></dl></dd><dt><span class="section"><a href="#validator-gettingstarted-whatsnext">1.5. Where to go next?</a></span></dt></dl></div><p>This chapter will show you how to get started with Hibernate Validator, the reference implementation (RI) of Bean Validation. For the following quick-start you need:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">A JDK &gt;= 6</li><li class="listitem"><a class="link" href="http://maven.apache.org/">Apache Maven</a></li><li class="listitem">An Internet connection (Maven has to download all required libraries)</li></ul></div><div class="section" title="1.1. Project set up"><div class="titlepage"><div><div><h2 class="title"><a id="validator-gettingstarted-createproject"/>1.1. Project set up</h2></div></div></div><p>In order to use Hibernate Validator within a Maven project, simply add the following dependency to
your <span class="emphasis"><em>pom.xml</em></span>:</p><div class="example"><a id="d0e84"/><p class="title"><strong>Example 1.1. Hibernate Validator Maven dependency</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;
    &lt;version&gt;5.2.4.Final&lt;/version&gt;
&lt;/dependency&gt;</code></pre></div></div><br class="example-break"/><p>This transitively pulls in the dependency to the Bean Validation API
(<code class="literal">javax.validation:validation-api:1.1.0.Final</code>).</p><div class="section" title="1.1.1. Unified EL"><div class="titlepage"><div><div><h3 class="title"><a id="validator-gettingstarted-uel"/>1.1.1. Unified EL</h3></div></div></div><p>Hibernate Validator requires an implementation of the Unified Expression Language
(<a class="link" href="http://jcp.org/en/jsr/detail?id=341">JSR 341</a>) for evaluating dynamic expressions in constraint
violation messages (see <a class="xref" href="#section-message-interpolation" title="4.1. Default message interpolation">Section 4.1, “Default message interpolation”</a>). When your application runs in a Java EE
container such as JBoss AS, an EL implementation is already provided by the container. In a Java SE
environment, however, you have to add an implementation as dependency to your POM file. For instance
you can add the following two dependencies to use the JSR 341 <a class="link" href="http://uel.java.net/">reference
implementation</a>:</p><div class="example"><a id="d0e107"/><p class="title"><strong>Example 1.2. Maven dependencies for Unified EL reference implementation</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;javax.el&lt;/groupId&gt;
    &lt;artifactId&gt;javax.el-api&lt;/artifactId&gt;
    &lt;version&gt;2.2.4&lt;/version&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.glassfish.web&lt;/groupId&gt;
    &lt;artifactId&gt;javax.el&lt;/artifactId&gt;
    &lt;version&gt;2.2.4&lt;/version&gt;
&lt;/dependency&gt;</code></pre></div></div><br class="example-break"/><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>For environments where one cannot provide a EL implementation Hibernate Validator is offering a
<a class="xref" href="#non-el-message-interpolator" title="11.7. ParameterMessageInterpolator">Section 11.7, “<code class="literal">ParameterMessageInterpolator</code>”</a>. However, the use of this interpolator
is not Bean Validation specification compliant.</p></div></div><div class="section" title="1.1.2. CDI"><div class="titlepage"><div><div><h3 class="title"><a id="section-getting-started-cdi"/>1.1.2. CDI</h3></div></div></div><p>Bean Validation defines integration points with CDI (Contexts and Dependency Injection for Java <sup>TM</sup>
EE, <a class="link" href="http://jcp.org/en/jsr/detail?id=346">JSR 346</a>). If your application runs in an
environment which does not provide this integration out of the box, you may use the Hibernate
Validator CDI portable extension by adding the following Maven dependency to your POM:</p><div class="example"><a id="d0e128"/><p class="title"><strong>Example 1.3. Hibernate Validator CDI portable extension Maven dependency</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-validator-cdi&lt;/artifactId&gt;
    &lt;version&gt;5.2.4.Final&lt;/version&gt;
&lt;/dependency&gt;</code></pre></div></div><br class="example-break"/><p>Note that adding this dependency is usually not required for applications running on a Java EE
application server. You can learn more about the integration of Bean Validation and CDI in
<a class="xref" href="#section-integration-with-cdi" title="10.3. CDI">Section 10.3, “CDI”</a>.</p></div><div class="section" title="1.1.3. Running with a security manager"><div class="titlepage"><div><div><h3 class="title"><a id="section-getting-started-security-manager"/>1.1.3. Running with a security manager</h3></div></div></div><p>Hibernate Validator supports running with a <a class="link" href="http://docs.oracle.com/javase/8/docs/technotes/guides/security/index.html">security manager</a> being enabled.
To do so, you must assign several permissions to the Hibernate Validator and the Bean Validation API code bases.
The following shows how to do this via a <a class="link" href="http://docs.oracle.com/javase/8/docs/technotes/guides/security/PolicyFiles.html">policy file</a> as processed by the Java default policy implementation:</p><div class="example"><a id="d0e148"/><p class="title"><strong>Example 1.4. Policy file for using Hibernate Validator with a security manager</strong></p><div class="example-contents"><pre><code class="language-xml">grant codeBase "file:path/to/hibernate-validator-5.2.4.Final.jar" {
    permission java.lang.reflect.ReflectPermission "suppressAccessChecks";
    permission java.lang.RuntimePermission "accessDeclaredMembers";

    // Only needed when working with XML descriptors (validation.xml or XML constraint mappings)
    permission java.util.PropertyPermission "mapAnyUriToUri", "read";
};

grant codeBase "file:path/to/validation-api-1.1.0.Final.jar" {
    permission java.io.FilePermission "path/to/hibernate-validator-5.2.4.Final.jar", "read";
};</code></pre></div></div><br class="example-break"/><p>All API invocations requiring special permissions are done via privileged actions.
This means only Hibernate Validator and the Bean Validation API themselves need the listed permissions.
You don’t need to assign any permissions to other code bases calling Hibernate Validator.</p></div></div><div class="section" title="1.2. Applying constraints"><div class="titlepage"><div><div><h2 class="title"><a id="validator-gettingstarted-createmodel"/>1.2. Applying constraints</h2></div></div></div><p>Lets dive directly into an example to see how to apply constraints.</p><div class="example"><a id="example-class-car"/><p class="title"><strong>Example 1.5. Class Car annotated with constraints</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter01;

import javax.validation.constraints.Min;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Size;

public class Car {

    @NotNull
    private String manufacturer;

    @NotNull
    @Size(min = 2, max = 14)
    private String licensePlate;

    @Min(2)
    private int seatCount;

    public Car(String manufacturer, String licencePlate, int seatCount) {
        this.manufacturer = manufacturer;
        this.licensePlate = licencePlate;
        this.seatCount = seatCount;
    }

    //getters and setters ...
}</code></pre></div></div><br class="example-break"/><p>The <code class="literal">@NotNull</code>, <code class="literal">@Size</code> and <code class="literal">@Min</code> annotations are used to declare the constraints which should be applied
to the fields of a Car instance:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">manufacturer</code> must never be <code class="literal">null</code></li><li class="listitem"><code class="literal">licensePlate</code> must never be <code class="literal">null</code> and must be between 2 and 14 characters long</li><li class="listitem"><code class="literal">seatCount</code> must be at least 2</li></ul></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>You can find the complete source code of all examples used in this reference guide in the Hibernate
Validator
<a class="link" href="https://github.com/hibernate/hibernate-validator/tree/master/documentation/src/test">source repository</a>
on GitHub.</p></div></div><div class="section" title="1.3. Validating constraints"><div class="titlepage"><div><div><h2 class="title"><a id="_validating_constraints"/>1.3. Validating constraints</h2></div></div></div><p>To perform a validation of these constraints, you use a <code class="literal">Validator</code> instance. Let’s have a look at a
unit test for <code class="literal">Car</code>:</p><div class="example"><a id="d0e214"/><p class="title"><strong>Example 1.6. Class CarTest showing validation examples</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter01;

import java.util.Set;
import javax.validation.ConstraintViolation;
import javax.validation.Validation;
import javax.validation.Validator;
import javax.validation.ValidatorFactory;

import org.junit.BeforeClass;
import org.junit.Test;

import static org.junit.Assert.assertEquals;

public class CarTest {

    private static Validator validator;

    @BeforeClass
    public static void setUpValidator() {
        ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
        validator = factory.getValidator();
    }

    @Test
    public void manufacturerIsNull() {
        Car car = new Car( null, "DD-AB-123", 4 );

        Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations =
                validator.validate( car );

        assertEquals( 1, constraintViolations.size() );
        assertEquals( "may not be null", constraintViolations.iterator().next().getMessage() );
    }

    @Test
    public void licensePlateTooShort() {
        Car car = new Car( "Morris", "D", 4 );

        Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations =
                validator.validate( car );

        assertEquals( 1, constraintViolations.size() );
        assertEquals(
                "size must be between 2 and 14",
                constraintViolations.iterator().next().getMessage()
        );
    }

    @Test
    public void seatCountTooLow() {
        Car car = new Car( "Morris", "DD-AB-123", 1 );

        Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations =
                validator.validate( car );

        assertEquals( 1, constraintViolations.size() );
        assertEquals(
                "must be greater than or equal to 2",
                constraintViolations.iterator().next().getMessage()
        );
    }

    @Test
    public void carIsValid() {
        Car car = new Car( "Morris", "DD-AB-123", 2 );

        Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations =
                validator.validate( car );

        assertEquals( 0, constraintViolations.size() );
    }
}</code></pre></div></div><br class="example-break"/><p>In the <code class="literal">setUp()</code> method a <code class="literal">Validator</code> object is retrieved from the <code class="literal">ValidatorFactory</code>. A <code class="literal">Validator</code>
instance is thread-safe and may be reused multiple times. It thus can safely be stored in a static
field and be used in the test methods to validate the different <code class="literal">Car</code> instances.</p><p>The <code class="literal">validate()</code> method returns a set of <code class="literal">ConstraintViolation</code> instances, which you can iterate over in
order to see which validation errors occurred. The first three test methods show some expected
constraint violations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The <code class="literal">@NotNull</code> constraint on <code class="literal">manufacturer</code> is violated in <code class="literal">manufacturerIsNull()</code></li><li class="listitem">The <code class="literal">@Size</code> constraint on <code class="literal">licensePlate</code> is violated in <code class="literal">licensePlateTooShort()</code></li><li class="listitem">The <code class="literal">@Min</code> constraint on <code class="literal">seatCount</code> is violated in <code class="literal">seatCountTooLow()</code></li></ul></div><p>If the object validates successfully, <code class="literal">validate()</code> returns an empty set as you can see in <code class="literal">carIsValid()</code>.</p><p>Note that only classes from the package <code class="literal">javax.validation</code> are used. These are provided from the Bean
Validation API. No classes from Hibernate Validator are directly referenced, resulting in portable
code.</p></div><div class="section" title="1.4. Java 8 support"><div class="titlepage"><div><div><h2 class="title"><a id="_java_8_support"/>1.4. Java 8 support</h2></div></div></div><p>Java 8 introduces several enhancements which are valuable from a Hibernate Validator point of view.
This section briefly introduces the Hibernate Validator features based on Java 8.
They are only available in Hibernate Validator 5.2 and later.</p><div class="section" title="1.4.1. Type arguments constraints"><div class="titlepage"><div><div><h3 class="title"><a id="_type_arguments_constraints"/>1.4.1. Type arguments constraints</h3></div></div></div><p>In Java 8 it is possible to use annotations in any location a type is used. This includes type
arguments. Hibernate Validator supports the validation of constraints defined on type arguments
of collections, maps, and custom parameterized types. The <a class="xref" href="#type-arguments-constraints" title="2.1.3. Type argument constraints">Section 2.1.3, “Type argument constraints”</a> chapter
provides further information on how to apply and use type argument constraints.</p></div><div class="section" title="1.4.2. Actual parameter names"><div class="titlepage"><div><div><h3 class="title"><a id="_actual_parameter_names"/>1.4.2. Actual parameter names</h3></div></div></div><p>The Java 8 Reflection API can now retrieve the actual parameter names of a method or constructor.
Hibernate Validator uses this ability to report the actual parameter names instead of <code class="literal">arg0</code>,
<code class="literal">arg1</code>, etc. The <a class="xref" href="#section-parameter-name-provider" title="8.2.4. ParameterNameProvider">Section 8.2.4, “<code class="literal">ParameterNameProvider</code>”</a> chapter explains how to use the new reflection
based parameter name provider.</p></div><div class="section" title="1.4.3. New date/time API"><div class="titlepage"><div><div><h3 class="title"><a id="_new_date_time_api"/>1.4.3. New date/time API</h3></div></div></div><p>Java 8 introduces a new date/time API. Hibernate Validator provides full support for the new API
where <code class="literal">@Future</code> and <code class="literal">@Past</code> constraints can be applied on the new types. The table
<a class="xref" href="#table-spec-constraints" title="Table 2.2. Bean Validation constraints">Table 2.2, “Bean Validation constraints”</a> shows the types supported for <code class="literal">@Future</code> and <code class="literal">@Past</code>, including the types
from the new API.</p></div><div class="section" title="1.4.4. Optional type"><div class="titlepage"><div><div><h3 class="title"><a id="_optional_type"/>1.4.4. Optional type</h3></div></div></div><p>Hibernate Validator provides also support for Java 8 <code class="literal">Optional</code> type, by unwrapping the <code class="literal">Optional</code>
instance and validating the internal value. <a class="xref" href="#section-optional-unwrapper" title="11.11.1. Optional unwrapper">Section 11.11.1, “Optional unwrapper”</a> provides examples and a
further discussion.</p></div></div><div class="section" title="1.5. Where to go next?"><div class="titlepage"><div><div><h2 class="title"><a id="validator-gettingstarted-whatsnext"/>1.5. Where to go next?</h2></div></div></div><p>That concludes the 5 minute tour through the world of Hibernate Validator and Bean Validation.
Continue exploring the code examples or look at further examples referenced in
<a class="xref" href="#validator-further-reading" title="Chapter 13. Further reading">Chapter 13, <em>Further reading</em></a>.</p><p>To learn more about the validation of beans and properties, just continue reading
<a class="xref" href="#chapter-bean-constraints" title="Chapter 2. Declaring and validating bean constraints">Chapter 2, <em>Declaring and validating bean constraints</em></a>. If you are interested in using Bean Validation for the validation of
method pre- and postcondition refer to <a class="xref" href="#chapter-method-constraints" title="Chapter 3. Declaring and validating method constraints">Chapter 3, <em>Declaring and validating method constraints</em></a>. In case your application has
specific validation requirements have a look at <a class="xref" href="#validator-customconstraints" title="Chapter 6. Creating custom constraints">Chapter 6, <em>Creating custom constraints</em></a>.</p></div></div><div class="chapter" title="Chapter 2. Declaring and validating bean constraints"><div class="titlepage"><div><div><h2 class="title"><a id="chapter-bean-constraints"/>Chapter 2. Declaring and validating bean constraints</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#section-declaring-bean-constraints">2.1. Declaring bean constraints</a></span></dt><dd><dl><dt><span class="section"><a href="#_field_level_constraints">2.1.1. Field-level constraints</a></span></dt><dt><span class="section"><a href="#_property_level_constraints">2.1.2. Property-level constraints</a></span></dt><dt><span class="section"><a href="#type-arguments-constraints">2.1.3. Type argument constraints</a></span></dt><dt><span class="section"><a href="#validator-usingvalidator-classlevel">2.1.4. Class-level constraints</a></span></dt><dt><span class="section"><a href="#section-constraint-inheritance">2.1.5. Constraint inheritance</a></span></dt><dt><span class="section"><a href="#section-object-graph-validation">2.1.6. Object graphs</a></span></dt></dl></dd><dt><span class="section"><a href="#section-validating-bean-constraints">2.2. Validating bean constraints</a></span></dt><dd><dl><dt><span class="section"><a href="#section-obtaining-validator">2.2.1. Obtaining a <code class="literal">Validator</code> instance</a></span></dt><dt><span class="section"><a href="#_validator_methods">2.2.2. Validator methods</a></span></dt><dt><span class="section"><a href="#section-constraint-violation-methods">2.2.3. <code class="literal">ConstraintViolation</code> methods</a></span></dt></dl></dd><dt><span class="section"><a href="#section-builtin-constraints">2.3. Built-in constraints</a></span></dt><dd><dl><dt><span class="section"><a href="#validator-defineconstraints-spec">2.3.1. Bean Validation constraints</a></span></dt><dt><span class="section"><a href="#validator-defineconstraints-hv-constraints">2.3.2. Additional constraints</a></span></dt></dl></dd></dl></div><p>In this chapter you will learn how to declare (see <a class="xref" href="#section-declaring-bean-constraints" title="2.1. Declaring bean constraints">Section 2.1, “Declaring bean constraints”</a>) and
validate (see <a class="xref" href="#section-validating-bean-constraints" title="2.2. Validating bean constraints">Section 2.2, “Validating bean constraints”</a>) bean constraints.
<a class="xref" href="#section-builtin-constraints" title="2.3. Built-in constraints">Section 2.3, “Built-in constraints”</a> provides an overview of all built-in constraints coming with
Hibernate Validator.</p><p>If you are interested in applying constraints to method parameters and return values, refer to
<a class="xref" href="#chapter-method-constraints" title="Chapter 3. Declaring and validating method constraints">Chapter 3, <em>Declaring and validating method constraints</em></a>.</p><div class="section" title="2.1. Declaring bean constraints"><div class="titlepage"><div><div><h2 class="title"><a id="section-declaring-bean-constraints"/>2.1. Declaring bean constraints</h2></div></div></div><p>Constraints in Bean Validation are expressed via Java annotations. In this section you will learn
how to enhance an object model with these annotations. There are the following three types of bean
constraints:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">field constraints</li><li class="listitem">property constraints</li><li class="listitem">class constraints</li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>Not all constraints can be placed on all of these levels. In fact, none of the default constraints
defined by Bean Validation can be placed at class level. The <code class="literal">java.lang.annotation.Target</code> annotation
in the constraint annotation itself determines on which elements a constraint can be placed. See
<a class="xref" href="#validator-customconstraints" title="Chapter 6. Creating custom constraints">Chapter 6, <em>Creating custom constraints</em></a> for more information.</p></div><div class="section" title="2.1.1. Field-level constraints"><div class="titlepage"><div><div><h3 class="title"><a id="_field_level_constraints"/>2.1.1. Field-level constraints</h3></div></div></div><p>Constraints can be expressed by annotating a field of a class. <a class="xref" href="#example-field-level" title="Example 2.1. Field-level constraints">Example 2.1, “Field-level constraints”</a> shows a field
level configuration example:</p><div class="example"><a id="example-field-level"/><p class="title"><strong>Example 2.1. Field-level constraints</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter02.fieldlevel;

public class Car {

	@NotNull
	private String manufacturer;

	@AssertTrue
	private boolean isRegistered;

	public Car(String manufacturer, boolean isRegistered) {
		this.manufacturer = manufacturer;
		this.isRegistered = isRegistered;
	}

	//getters and setters...
}</code></pre></div></div><br class="example-break"/><p>When using field-level constraints field access strategy is used to access the value to be
validated. This means the validation engine directly accesses the instance variable and does not
invoke the property accessor method even if such an accessor exists.</p><p>Constraints can be applied to fields of any access type (public, private etc.). Constraints on
static fields are not supported, though.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>When validating byte code enhanced objects property level constraints should be used, because the
byte code enhancing library won’t be able to determine a field access via reflection.</p></div></div><div class="section" title="2.1.2. Property-level constraints"><div class="titlepage"><div><div><h3 class="title"><a id="_property_level_constraints"/>2.1.2. Property-level constraints</h3></div></div></div><p>If your model class adheres to the
<a class="link" href="http://java.sun.com/javase/technologies/desktop/javabeans/index.jsp">JavaBeans</a> standard, it
is also possible to annotate the properties of a bean class instead of its fields.
<a class="xref" href="#example-property-level" title="Example 2.2. Property-level constraints">Example 2.2, “Property-level constraints”</a> uses the same entity as in <a class="xref" href="#example-field-level" title="Example 2.1. Field-level constraints">Example 2.1, “Field-level constraints”</a>, however, property level
constraints are used.</p><div class="example"><a id="example-property-level"/><p class="title"><strong>Example 2.2. Property-level constraints</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter02.propertylevel;

public class Car {

	private String manufacturer;

	private boolean isRegistered;

	public Car(String manufacturer, boolean isRegistered) {
		this.manufacturer = manufacturer;
		this.isRegistered = isRegistered;
	}

	@NotNull
	public String getManufacturer() {
		return manufacturer;
	}

	public void setManufacturer(String manufacturer) {
		this.manufacturer = manufacturer;
	}

	@AssertTrue
	public boolean isRegistered() {
		return isRegistered;
	}

	public void setRegistered(boolean isRegistered) {
		this.isRegistered = isRegistered;
	}
}</code></pre></div></div><br class="example-break"/><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>The property’s getter method has to be annotated, not its setter. That way also read-only properties
can be constrained which have no setter method.</p></div><p>When using property level constraints property access strategy is used to access the value to be
validated, i.e. the validation engine accesses the state via the property accessor method.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>It is recommended to stick either to field <span class="emphasis"><em>or</em></span> property annotations within one class. It is not
recommended to annotate a field <span class="emphasis"><em>and</em></span> the accompanying getter method as this would cause the field
to be validated twice.</p></div></div><div class="section" title="2.1.3. Type argument constraints"><div class="titlepage"><div><div><h3 class="title"><a id="type-arguments-constraints"/>2.1.3. Type argument constraints</h3></div></div></div><p>Starting from Java 8, it is possible to specify constraints directly on the type argument of a
parameterized type. However, this requires that <code class="literal">ElementType.TYPE_USE</code> is specified via <code class="literal">@Target</code>
in the constraint definition. To maintain backwards compatibility, built-in Bean Validation as well as
Hibernate Validator specific constraints do not yet specify <code class="literal">ElementType.TYPE_USE</code>. To make use of
type argument constraints, custom constraints must be used (see <a class="xref" href="#validator-customconstraints" title="Chapter 6. Creating custom constraints">Chapter 6, <em>Creating custom constraints</em></a>).</p><p>Hibernate Validator validates type arguments constraints specified on collections, map values,
<code class="literal">java.util.Optional</code>, and custom parameterized types.</p><div class="section" title="2.1.3.1. With Iterable"><div class="titlepage"><div><div><h4 class="title"><a id="_with_literal_iterable_literal"/>2.1.3.1. With <code class="literal">Iterable</code></h4></div></div></div><p>When applying constraints on an <code class="literal">Iterable</code> type argument, Hibernate Validator will validate each
element. <a class="xref" href="#example-type-arguments-constraints-collections" title="Example 2.3. Type argument constraint on List">Example 2.3, “Type argument constraint on <code class="literal">List</code>”</a> shows an example of a
<code class="literal">List</code> with a type argument constraint.</p><div class="example"><a id="example-type-arguments-constraints-collections"/><p class="title"><strong>Example 2.3. Type argument constraint on <code class="literal">List</code></strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter02.typeargument;

public class Car {

	@Valid
	private List&lt;@ValidPart String&gt; parts = new ArrayList&lt;&gt;();

	public void addPart(String part) {
		parts.add( part );
	}

	//...
}</code></pre><pre><code class="language-java">Car car = Car();
car.addPart( "Wheel" );
car.addPart( null );

Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );

assertEquals( 1, constraintViolations.size() );
assertEquals(
		"'null' is not a valid car part.",
		constraintViolations.iterator().next().getMessage()
);
assertEquals( "parts[1]", constraintViolations.iterator().next().getPropertyPath().toString() );</code></pre></div></div><br class="example-break"/></div><div class="section" title="2.1.3.2. With Map"><div class="titlepage"><div><div><h4 class="title"><a id="_with_literal_map_literal"/>2.1.3.2. With <code class="literal">Map</code></h4></div></div></div><p>Type argument constraints are also validated for map values. Constraints on the key are ignored.
<a class="xref" href="#example-type-arguments-constraints-map" title="Example 2.4. Type argument constraint on maps">Example 2.4, “Type argument constraint on maps”</a> shows an example of a <code class="literal">Map</code> value with a type
argument constraint.</p><div class="example"><a id="example-type-arguments-constraints-map"/><p class="title"><strong>Example 2.4. Type argument constraint on maps</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter02.typeargument;

public class Car {

	public static enum FuelConsumption {
		CITY,
		HIGHWAY
	}

	@Valid
	private EnumMap&lt;FuelConsumption, @MaxAllowedFuelConsumption Integer&gt; fuelConsumption = new EnumMap&lt;&gt;( FuelConsumption.class );

	public void setFuelConsumption(FuelConsumption consumption, int value) {
		fuelConsumption.put( consumption, value );
	}

    //...
}</code></pre><pre><code class="language-java">Car car = new Car();
car.setFuelConsumption( Car.FuelConsumption.HIGHWAY, 20 );

Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );

assertEquals( 1, constraintViolations.size() );
assertEquals( "20 is outside the max fuel consumption.", constraintViolations.iterator().next().getMessage() );</code></pre></div></div><br class="example-break"/></div><div class="section" title="2.1.3.3. With java.util.Optional"><div class="titlepage"><div><div><h4 class="title"><a id="_with_literal_java_util_optional_literal"/>2.1.3.3. With <code class="literal">java.util.Optional</code></h4></div></div></div><p>When applying a constraint on the type argument of <code class="literal">Optional</code>, Hibernate Validator will automatically
unwrap the type and validate the internal value. <a class="xref" href="#example-type-arguments-constraints-optional" title="Example 2.5. Type argument constraint on Optional">Example 2.5, “Type argument constraint on Optional”</a> shows
an example of an <code class="literal">Optional</code> with a type argument constraint.</p><div class="example"><a id="example-type-arguments-constraints-optional"/><p class="title"><strong>Example 2.5. Type argument constraint on Optional</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter02.typeargument;

import java.util.ArrayList;
import java.util.EnumMap;
import java.util.List;
import java.util.Optional;
import javax.validation.Valid;

public class Car {

	private Optional&lt;@MinTowingCapacity(1000) Integer&gt; towingCapacity = Optional.empty();

	public void setTowingCapacity(Integer alias) {
		towingCapacity = Optional.of( alias );
	}

    //...
}</code></pre><pre><code class="language-java">Car car = Car();
car.setTowingCapacity( 100 );

Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );

assertEquals( 1, constraintViolations.size() );
assertEquals( "Not enough towing capacity.", constraintViolations.iterator().next().getMessage() );
assertEquals( "towingCapacity", constraintViolations.iterator().next().getPropertyPath().toString() );</code></pre></div></div><br class="example-break"/></div><div class="section" title="2.1.3.4. With custom parameterized types"><div class="titlepage"><div><div><h4 class="title"><a id="_with_custom_parameterized_types"/>2.1.3.4. With custom parameterized types</h4></div></div></div><p>Type arguments constraints can with two restrictions also be used with custom types. First, a
<code class="literal">ValidatedValueUnwrapper</code> must be registered for the custom type allowing to retrieve
the value to validate (see <a class="xref" href="#section-value-handling" title="11.11. Unwrapping values">Section 11.11, “Unwrapping values”</a>). Second, only types with one type arguments
are supported. Parameterized types with two or more type arguments are not checked for type argument
constraints. This limitation might change in future versions.</p><p><a class="xref" href="#example-type-arguments-constraints-custom-parameterized-type" title="Example 2.6. Type argument constraint on custom parameterized type">Example 2.6, “Type argument constraint on custom parameterized type”</a> shows an example of a custom
parameterized type with a type argument constraint.</p><div class="example"><a id="example-type-arguments-constraints-custom-parameterized-type"/><p class="title"><strong>Example 2.6. Type argument constraint on custom parameterized type</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter02.typeargument;

public class Car {

	private GearBox&lt;@MinTorque(100) Gear&gt; gearBox;

	public void setGearBox(GearBox&lt;Gear&gt; gearBox) {
		this.gearBox = gearBox;
	}

	//...
}</code></pre><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter02.typeargument;

public class GearBox&lt;T extends Gear&gt; {

	private final T gear;

	public GearBox(T gear) {
		this.gear = gear;
	}

	public Gear getGear() {
		return this.gear;
	}
}</code></pre><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter02.typeargument;

public class Gear {
	private final Integer torque;

	public Gear(Integer torque) {
		this.torque = torque;
	}

	public Integer getTorque() {
		return torque;
	}

	public static class AcmeGear extends Gear {
		public AcmeGear() {
			super( 100 );
		}
	}
}</code></pre><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter02.typeargument;

public class GearBoxUnwrapper extends ValidatedValueUnwrapper&lt;GearBox&gt; {
	@Override
	public Object handleValidatedValue(GearBox gearBox) {
		return gearBox == null ? null : gearBox.getGear();
	}

	@Override
	public Type getValidatedValueType(Type valueType) {
		return Gear.class;
	}
}</code></pre><pre><code class="language-java">Car car = Car();
car.setGearBox( new GearBox&lt;&gt;( new Gear.AcmeGear() ) );

Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );
assertEquals( 1, constraintViolations.size() );
assertEquals( "Gear is not providing enough torque.", constraintViolations.iterator().next().getMessage() );
assertEquals( "gearBox", constraintViolations.iterator().next().getPropertyPath().toString() );</code></pre></div></div><br class="example-break"/></div></div><div class="section" title="2.1.4. Class-level constraints"><div class="titlepage"><div><div><h3 class="title"><a id="validator-usingvalidator-classlevel"/>2.1.4. Class-level constraints</h3></div></div></div><p>Last but not least, a constraint can also be placed on the class level. In this case not a single
property is subject of the validation but the complete object. Class-level constraints are useful if
the validation depends on a correlation between several properties of an object.</p><p>The Car class in <a class="xref" href="#example-class-level" title="Example 2.7. Class-level constraint">Example 2.7, “Class-level constraint”</a> has the two attributes <code class="literal">seatCount</code> and <code class="literal">passengers</code> and it
should be ensured that the list of passengers has not more entries than seats are available. For
that purpose the <code class="literal">@ValidPassengerCount</code> constraint is added on the class level. The validator of that
constraint has access to the complete <code class="literal">Car</code> object, allowing to compare the numbers of seats and
passengers.</p><p>Refer to <a class="xref" href="#section-class-level-constraints" title="6.2. Class-level constraints">Section 6.2, “Class-level constraints”</a> to learn in detail how to implement this custom
constraint.</p><div class="example"><a id="example-class-level"/><p class="title"><strong>Example 2.7. Class-level constraint</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter02.classlevel;

@ValidPassengerCount
public class Car {

	private int seatCount;

	private List&lt;Person&gt; passengers;

	//...
}</code></pre></div></div><br class="example-break"/></div><div class="section" title="2.1.5. Constraint inheritance"><div class="titlepage"><div><div><h3 class="title"><a id="section-constraint-inheritance"/>2.1.5. Constraint inheritance</h3></div></div></div><p>When a class implements an interface or extends another class, all constraint annotations declared
on the super-type apply in the same manner as the constraints specified on the class itself. To make
things clearer let’s have a look at the following example:</p><div class="example"><a id="d0e598"/><p class="title"><strong>Example 2.8. Constraint inheritance</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter02.inheritance;

public class Car {

	private String manufacturer;

	@NotNull
	public String getManufacturer() {
		return manufacturer;
	}

	//...
}</code></pre><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter02.inheritance;

public class RentalCar extends Car {

	private String rentalStation;

	@NotNull
	public String getRentalStation() {
		return rentalStation;
	}

	//...
}</code></pre></div></div><br class="example-break"/><p>Here the class <code class="literal">RentalCar</code> is a subclass of <code class="literal">Car</code> and adds the property <code class="literal">rentalStation</code>. If an instance of
<code class="literal">RentalCar</code> is validated, not only the <code class="literal">@NotNull</code> constraint on <code class="literal">rentalStation</code> is evaluated, but also the
constraint on <code class="literal">manufacturer</code> from the parent class.</p><p>The same would be true, if <code class="literal">Car</code> was not a superclass but an interface implemented by <code class="literal">RentalCar</code>.</p><p>Constraint annotations are aggregated if methods are overridden. So if <code class="literal">RentalCar</code> overrode the
<code class="literal">getManufacturer()</code> method from <code class="literal">Car</code>, any constraints annotated at the overriding method would be
evaluated in addition to the <code class="literal">@NotNull</code> constraint from the superclass.</p></div><div class="section" title="2.1.6. Object graphs"><div class="titlepage"><div><div><h3 class="title"><a id="section-object-graph-validation"/>2.1.6. Object graphs</h3></div></div></div><p>The Bean Validation API does not only allow to validate single class instances but also complete
object graphs (cascaded validation). To do so, just annotate a field or property representing a
reference to another object with <code class="literal">@Valid</code> as demonstrated in <a class="xref" href="#example-cascaded-validation" title="Example 2.9. Cascaded validation">Example 2.9, “Cascaded validation”</a>.</p><div class="example"><a id="example-cascaded-validation"/><p class="title"><strong>Example 2.9. Cascaded validation</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter02.objectgraph;

public class Car {

	@NotNull
	@Valid
	private Person driver;

	//...
}</code></pre><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter02.objectgraph;

public class Person {

	@NotNull
	private String name;

	//...
}</code></pre></div></div><br class="example-break"/><p>If an instance of <code class="literal">Car</code> is validated, the referenced <code class="literal">Person</code> object will be validated as well, as the
<code class="literal">driver</code> field is annotated with <code class="literal">@Valid</code>. Therefore the validation of a <code class="literal">Car</code> will fail if the <code class="literal">name</code> field
of the referenced <code class="literal">Person</code> instance is <code class="literal">null</code>.</p><p>The validation of object graphs is recursive, i.e. if a reference marked for cascaded validation
points to an object which itself has properties annotated with <code class="literal">@Valid</code>, these references will be
followed up by the validation engine as well. The validation engine will ensure that no infinite
loops occur during cascaded validation, for example if two objects hold references to each other.</p><p>Note that <code class="literal">null</code> values are getting ignored during cascaded validation.</p><p>Object graph validation also works for collection-typed fields. That means any attributes that</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">are arrays</li><li class="listitem">implement <code class="literal">java.lang.Iterable</code> (especially <code class="literal">Collection</code>, <code class="literal">List</code> and <code class="literal">Set</code>)</li><li class="listitem">implement <code class="literal">java.util.Map</code></li></ul></div><p>can be annotated with <code class="literal">@Valid</code>, which will cause each contained element to be validated, when the
parent object is validated.</p><div class="example"><a id="example-cascaded-validation-list"/><p class="title"><strong>Example 2.10. Cascaded validation of a collection</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter02.objectgraph.list;

public class Car {

	@NotNull
	@Valid
	private List&lt;Person&gt; passengers = new ArrayList&lt;Person&gt;();

	//...
}</code></pre></div></div><br class="example-break"/><p>So when validating an instance of the <code class="literal">Car</code> class shown in <a class="xref" href="#example-cascaded-validation-list" title="Example 2.10. Cascaded validation of a collection">Example 2.10, “Cascaded validation of a collection”</a>, a
<code class="literal">ConstraintViolation</code> will be created, if any of the <code class="literal">Person</code> objects contained in the passengers list
has a <code class="literal">null</code> name.</p></div></div><div class="section" title="2.2. Validating bean constraints"><div class="titlepage"><div><div><h2 class="title"><a id="section-validating-bean-constraints"/>2.2. Validating bean constraints</h2></div></div></div><p>The <code class="literal">Validator</code> interface is the most important object in Bean Validation. The next section shows how
to obtain an <code class="literal">Validator</code> instance. Afterwards you’ll learn how to use the different methods of the
<code class="literal">Validator</code> interface.</p><div class="section" title="2.2.1. Obtaining a Validator instance"><div class="titlepage"><div><div><h3 class="title"><a id="section-obtaining-validator"/>2.2.1. Obtaining a <code class="literal">Validator</code> instance</h3></div></div></div><p>The first step towards validating an entity instance is to get hold of a <code class="literal">Validator</code> instance. The
road to this instance leads via the <code class="literal">Validation</code> class and a <code class="literal">ValidatorFactory</code>. The easiest way is to
use the static method <code class="literal">Validation#buildDefaultValidatorFactory()</code>:</p><div class="example"><a id="d0e789"/><p class="title"><strong>Example 2.11. <code class="literal">Validation#buildDefaultValidatorFactory()</code></strong></p><div class="example-contents"><pre><code class="language-java">ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
Validator validator = factory.getValidator();</code></pre></div></div><br class="example-break"/><p>This bootstraps a validator in the default configuration. Refer to <a class="xref" href="#chapter-bootstrapping" title="Chapter 8. Bootstrapping">Chapter 8, <em>Bootstrapping</em></a> to
learn more about the different bootstrapping methods and how to obtain a specifically configured
<code class="literal">Validator</code> instance.</p></div><div class="section" title="2.2.2. Validator methods"><div class="titlepage"><div><div><h3 class="title"><a id="_validator_methods"/>2.2.2. Validator methods</h3></div></div></div><p>The <code class="literal">Validator</code> interface contains three methods that can be used to either validate entire entities
or just single properties of the entity.</p><p>All three methods return a <code class="literal">Set&lt;ConstraintViolation&gt;</code>. The set is empty, if the validation succeeds.
Otherwise a <code class="literal">ConstraintViolation</code> instance is added for each violated constraint.</p><p>All the validation methods have a var-args parameter which can be used to specify, which validation
groups shall be considered when performing the validation. If the parameter is not specified the
default validation group (<code class="literal">javax.validation.groups.Default</code>) is used. The topic of validation groups
is discussed in detail in <a class="xref" href="#chapter-groups" title="Chapter 5. Grouping constraints">Chapter 5, <em>Grouping constraints</em></a>.</p><div class="section" title="2.2.2.1. Validator#validate()"><div class="titlepage"><div><div><h4 class="title"><a id="__literal_validator_validate_literal"/>2.2.2.1. <code class="literal">Validator#validate()</code></h4></div></div></div><p>Use the <code class="literal">validate()</code> method to perform validation of all constraints of a given bean.
<a class="xref" href="#example-validator-validate" title="Example 2.12. Using Validator#validate()">Example 2.12, “Using <code class="literal">Validator#validate()</code>”</a> shows the validation of an instance of the <code class="literal">Car</code> class from
<a class="xref" href="#example-property-level" title="Example 2.2. Property-level constraints">Example 2.2, “Property-level constraints”</a> which fails to satisfy the <code class="literal">@NotNull</code> constraint on the <code class="literal">manufacturer</code>
property. The validation call therefore returns one <code class="literal">ConstraintViolation</code> object.</p><div class="example"><a id="example-validator-validate"/><p class="title"><strong>Example 2.12. Using <code class="literal">Validator#validate()</code></strong></p><div class="example-contents"><pre><code class="language-java">Car car = new Car( null, true );

Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );

assertEquals( 1, constraintViolations.size() );
assertEquals( "may not be null", constraintViolations.iterator().next().getMessage() );</code></pre></div></div><br class="example-break"/></div><div class="section" title="2.2.2.2. Validator#validateProperty()"><div class="titlepage"><div><div><h4 class="title"><a id="__literal_validator_validateproperty_literal"/>2.2.2.2. <code class="literal">Validator#validateProperty()</code></h4></div></div></div><p>With help of the <code class="literal">validateProperty()</code> you can validate a single named property of a given object. The
property name is the JavaBeans property name.</p><div class="example"><a id="d0e866"/><p class="title"><strong>Example 2.13. Using <code class="literal">Validator#validateProperty()</code></strong></p><div class="example-contents"><pre><code class="language-java">Car car = new Car( null, true );

Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validateProperty(
		car,
		"manufacturer"
);

assertEquals( 1, constraintViolations.size() );
assertEquals( "may not be null", constraintViolations.iterator().next().getMessage() );</code></pre></div></div><br class="example-break"/></div><div class="section" title="2.2.2.3. Validator#validateValue()"><div class="titlepage"><div><div><h4 class="title"><a id="__literal_validator_validatevalue_literal"/>2.2.2.3. <code class="literal">Validator#validateValue()</code></h4></div></div></div><p>By using the <code class="literal">validateValue()</code> method you can check whether a single property of a given class can be
validated successfully, if the property had the specified value:</p><div class="example"><a id="d0e882"/><p class="title"><strong>Example 2.14. Using <code class="literal">Validator#validateValue()</code></strong></p><div class="example-contents"><pre><code class="language-java">Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validateValue(
		Car.class,
		"manufacturer",
		null
);

assertEquals( 1, constraintViolations.size() );
assertEquals( "may not be null", constraintViolations.iterator().next().getMessage() );
---</code></pre></div></div><br class="example-break"/><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p><code class="literal">@Valid</code> is not honored by <code class="literal">validateProperty()</code> or <code class="literal">validateValue()</code>.</p></div><p><code class="literal">Validator#validateProperty()</code> is for example used in the integration of Bean Validation into JSF 2
(see <a class="xref" href="#section-presentation-layer" title="10.2. JSF &amp; Seam">Section 10.2, “JSF &amp; Seam”</a>) to perform a validation of the values entered into a form
before they are propagated to the model.</p></div></div><div class="section" title="2.2.3. ConstraintViolation methods"><div class="titlepage"><div><div><h3 class="title"><a id="section-constraint-violation-methods"/>2.2.3. <code class="literal">ConstraintViolation</code> methods</h3></div></div></div><p>Now it is time to have a closer look at what a <code class="literal">ConstraintViolation</code> is. Using the different methods
of <code class="literal">ConstraintViolation</code> a lot of useful information about the cause of the validation failure can be
determined. <a class="xref" href="#table-constraint-violation" title="Table 2.1. The various ConstraintViolation methods">Table 2.1, “The various <code class="literal">ConstraintViolation</code> methods”</a> gives an overview of these methods. The values in the
"Example" column refer to <a class="xref" href="#example-validator-validate" title="Example 2.12. Using Validator#validate()">Example 2.12, “Using <code class="literal">Validator#validate()</code>”</a>.</p><div class="table"><a id="table-constraint-violation"/><p class="title"><strong>Table 2.1. The various <code class="literal">ConstraintViolation</code> methods</strong></p><div class="table-contents"><table summary="The various ConstraintViolation methods" border="1"><colgroup><col width="33*" class="col_1"/><col width="33*" class="col_2"/><col width="33*" class="col_3"/></colgroup><thead><tr><th align="left" valign="top">Method</th><th align="left" valign="top">Usage</th><th align="left" valign="top">Example</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">getMessage()</code></p></td><td align="left" valign="top"><p>The interpolated error message</p></td><td align="left" valign="top"><p>"may not be null"</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">getMessageTemplate()</code></p></td><td align="left" valign="top"><p>The non-interpolated error message</p></td><td align="left" valign="top"><p>"{…​ NotNull.message}"</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">getRootBean()</code></p></td><td align="left" valign="top"><p>The root bean being validated</p></td><td align="left" valign="top"><p>car</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">getRootBeanClass()</code></p></td><td align="left" valign="top"><p>The class of the root bean being validated</p></td><td align="left" valign="top"><p><code class="literal">Car.class</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">getLeafBean()</code></p></td><td align="left" valign="top"><p>If a bean constraint, the bean instance the constraint is
              applied on; If a property constraint, the bean instance hosting
              the property the constraint is applied on</p></td><td align="left" valign="top"><p><code class="literal">car</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">getPropertyPath()</code></p></td><td align="left" valign="top"><p>The property path to the validated value from root
              bean</p></td><td align="left" valign="top"><p>contains one node with kind
              <code class="literal">PROPERTY</code> and name "manufacturer"</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">getInvalidValue()</code></p></td><td align="left" valign="top"><p>The value failing to pass the constraint</p></td><td align="left" valign="top"><p><code class="literal">null</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">getConstraintDescriptor()</code></p></td><td align="left" valign="top"><p>Constraint metadata reported to fail</p></td><td align="left" valign="top"><p>descriptor for <code class="literal">@NotNull</code></p></td></tr></tbody></table></div></div><br class="table-break"/></div></div><div class="section" title="2.3. Built-in constraints"><div class="titlepage"><div><div><h2 class="title"><a id="section-builtin-constraints"/>2.3. Built-in constraints</h2></div></div></div><p>Hibernate Validator comprises a basic set of commonly used constraints. These are foremost the
constraints defined by the Bean Validation specification (see <a class="xref" href="#table-spec-constraints" title="Table 2.2. Bean Validation constraints">Table 2.2, “Bean Validation constraints”</a>).
Additionally, Hibernate Validator provides useful custom constraints (see
<a class="xref" href="#table-custom-constraints" title="Table 2.3. Custom constraints">Table 2.3, “Custom constraints”</a> and <a class="xref" href="#table-custom-country-constraints" title="Table 2.4. Custom country specific constraints">Table 2.4, “Custom country specific constraints”</a>).</p><div class="section" title="2.3.1. Bean Validation constraints"><div class="titlepage"><div><div><h3 class="title"><a id="validator-defineconstraints-spec"/>2.3.1. Bean Validation constraints</h3></div></div></div><p><a class="xref" href="#table-spec-constraints" title="Table 2.2. Bean Validation constraints">Table 2.2, “Bean Validation constraints”</a> shows purpose and supported data types of all constraints specified in
the Bean Validation API. All these constraints apply to the field/property level, there are no
class-level constraints defined in the Bean Validation specification. If you are using the Hibernate
object-relational mapper, some of the constraints are taken into account when creating the DDL for
your model (see column "Hibernate metadata impact").</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>Hibernate Validator allows some constraints to be applied to more data types than required by the
Bean Validation specification (e.g. <code class="literal">@Max</code> can be applied to strings). Relying on this feature can
impact portability of your application between Bean Validation providers.</p></div><div class="table"><a id="table-spec-constraints"/><p class="title"><strong>Table 2.2. Bean Validation constraints</strong></p><div class="table-contents"><table summary="Bean Validation constraints" border="1"><colgroup><col width="25*" class="col_1"/><col width="25*" class="col_2"/><col width="25*" class="col_3"/><col width="25*" class="col_4"/></colgroup><thead><tr><th align="left" valign="top">Annotation</th><th align="left" valign="top">Supported data types</th><th align="left" valign="top">Use</th><th align="left" valign="top">Hibernate metadata impact</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">@AssertFalse</code></p></td><td align="left" valign="top"><p><code class="literal">Boolean</code>,
              <code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Checks that the annotated element is
              false</p></td><td align="left" valign="top"><p>None</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">@AssertTrue</code></p></td><td align="left" valign="top"><p><code class="literal">Boolean</code>,
              <code class="literal">boolean</code></p></td><td align="left" valign="top"><p>Checks that the annotated element is
              true</p></td><td align="left" valign="top"><p>None</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">@DecimalMax(value=,inclusive=)</code></p></td><td align="left" valign="top"><p><code class="literal">BigDecimal</code>,
              <code class="literal">BigInteger</code>,
              <code class="literal">CharSequence</code>,
              <code class="literal">byte</code>, <code class="literal">short</code>,
              <code class="literal">int</code>, <code class="literal">long</code> and the
              respective wrappers of the primitive types; Additionally
              supported by HV: any sub-type of
              <code class="literal">Number</code></p></td><td align="left" valign="top"><p>Checks whether the annotated value is less than the
              specified maximum, when inclusive=false.
              Otherwise whether the value is less than or equal to the
              specified maximum. The parameter value is
              the string representation of the max value according to the
              <code class="literal">BigDecimal</code> string representation.</p></td><td align="left" valign="top"><p>None</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">@DecimalMin(value=,inclusive=)</code></p></td><td align="left" valign="top"><p><code class="literal">BigDecimal</code>,
              <code class="literal">BigInteger</code>,
              <code class="literal">CharSequence</code>,
              <code class="literal">byte</code>, <code class="literal">short</code>,
              <code class="literal">int</code>, <code class="literal">long</code> and the
              respective wrappers of the primitive types; Additionally
              supported by HV: any sub-type of
              <code class="literal">Number</code></p></td><td align="left" valign="top"><p>Checks whether the annotated value is larger than the
              specified minimum, when inclusive=false.
              Otherwise whether the value is larger than or equal to the
              specified minimum. The parameter value is
              the string representation of the min value according to the
              <code class="literal">BigDecimal</code> string representation.</p></td><td align="left" valign="top"><p>None</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">@Digits(integer=,fraction=)</code></p></td><td align="left" valign="top"><p>BigDecimal,
              <code class="literal">BigInteger</code>,
              <code class="literal">CharSequence</code>,
              <code class="literal">byte</code>, <code class="literal">short</code>,
              <code class="literal">int</code>, <code class="literal">long</code> and the
              respective wrappers of the primitive types; Additionally
              supported by HV: any sub-type of
              <code class="literal">Number</code></p></td><td align="left" valign="top"><p>Checks whether the annotated value is a number having up to
              <code class="literal">integer</code> digits and
              <code class="literal">fraction</code> fractional digits</p></td><td align="left" valign="top"><p>Defines column precision and scale</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">@Future</code></p></td><td align="left" valign="top"><p><code class="literal">java.util.Date</code>,
              <code class="literal">java.util.Calendar</code>,
              <code class="literal">java.time.chrono.ChronoZonedDateTime</code>,
              <code class="literal">java.time.Instant</code>,
              <code class="literal">java.time.OffsetDateTime</code>; Additionally
              supported by HV, if the <a class="link" href="http://joda-time.sourceforge.net/">Joda Time</a>
              date/time API is on the class path: any implementations of
              <code class="literal">ReadablePartial</code> and
              <code class="literal">ReadableInstant</code></p></td><td align="left" valign="top"><p>Checks whether the annotated date is in the
              future</p></td><td align="left" valign="top"><p>None</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">@Max(value=)</code></p></td><td align="left" valign="top"><p><code class="literal">BigDecimal</code>,
              <code class="literal">BigInteger</code>, <code class="literal">byte</code>,
              <code class="literal">short</code>, <code class="literal">int</code>,
              <code class="literal">long</code> and the respective wrappers of the
              primitive types; Additionally supported by HV: any sub-type of
              <code class="literal">CharSequence</code> (the numeric value
              represented by the character sequence is evaluated), any
              sub-type of <code class="literal">Number</code></p></td><td align="left" valign="top"><p>Checks whether the annotated value is less than or equal
              to the specified maximum</p></td><td align="left" valign="top"><p>Adds a check constraint on the column</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">@Min(value=)</code></p></td><td align="left" valign="top"><p><code class="literal">BigDecimal</code>,
              <code class="literal">BigInteger</code>, <code class="literal">byte</code>,
              <code class="literal">short</code>, <code class="literal">int</code>,
              <code class="literal">long</code> and the respective wrappers of the
              primitive types; Additionally supported by HV: any sub-type of
              <code class="literal">CharSequence</code> (the numeric value
              represented by the char sequence is evaluated), any sub-type of
              <code class="literal">Number</code></p></td><td align="left" valign="top"><p>Checks whether the annotated value is higher than or
              equal to the specified minimum</p></td><td align="left" valign="top"><p>Adds a check constraint on the column</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">@NotNull</code></p></td><td align="left" valign="top"><p>Any type</p></td><td align="left" valign="top"><p>Checks that the annotated value is not
              <code class="literal">null</code>.</p></td><td align="left" valign="top"><p>Column(s) are not nullable</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">@Null</code></p></td><td align="left" valign="top"><p>Any type</p></td><td align="left" valign="top"><p>Checks that the annotated value is
              <code class="literal">null</code></p></td><td align="left" valign="top"><p>None</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">@Past</code></p></td><td align="left" valign="top"><p><code class="literal">java.util.Date</code>,
              <code class="literal">java.util.Calendar</code>,
              <code class="literal">java.time.chrono.ChronoZonedDateTime</code>,
              <code class="literal">java.time.Instant</code>,
              <code class="literal">java.time.OffsetDateTime</code>; Additionally
              supported by HV, if the <a class="link" href="http://joda-time.sourceforge.net/">Joda Time</a>
              date/time API is on the class path: any implementations of
              <code class="literal">ReadablePartial</code> and
              <code class="literal">ReadableInstant</code></p></td><td align="left" valign="top"><p>Checks whether the annotated date is in the past</p></td><td align="left" valign="top"><p>None</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">@Pattern(regex=,flag=)</code></p></td><td align="left" valign="top"><p><code class="literal">CharSequence</code></p></td><td align="left" valign="top"><p>Checks if the annotated string matches the regular
              expression <code class="literal">regex</code> considering the given
              flag <code class="literal">match</code></p></td><td align="left" valign="top"><p>None</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">@Size(min=, max=)</code></p></td><td align="left" valign="top"><p><code class="literal">CharSequence</code>,
              <code class="literal">Collection</code>, <code class="literal">Map</code>
              and arrays</p></td><td align="left" valign="top"><p>Checks if the annotated element’s size is between <code class="literal">min</code> and
              <code class="literal">max</code> (inclusive)</p></td><td align="left" valign="top"><p>Column length will be set to
              <code class="literal">max</code></p></td></tr><tr><td align="left" valign="top"><p><code class="literal">@Valid</code></p></td><td align="left" valign="top"><p>Any non-primitive type</p></td><td align="left" valign="top"><p>Performs validation recursively on the associated object.
              If the object is a collection or an array, the elements are
              validated recursively. If the object is a map, the value
              elements are validated recursively.</p></td><td align="left" valign="top"><p>None</p></td></tr></tbody></table></div></div><br class="table-break"/><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>On top of the parameters indicated in <a class="xref" href="#table-spec-constraints" title="Table 2.2. Bean Validation constraints">Table 2.2, “Bean Validation constraints”</a> each constraint has the parameters
message, groups and payload. This is a requirement of the Bean Validation specification.</p></div></div><div class="section" title="2.3.2. Additional constraints"><div class="titlepage"><div><div><h3 class="title"><a id="validator-defineconstraints-hv-constraints"/>2.3.2. Additional constraints</h3></div></div></div><p>In addition to the constraints defined by the Bean Validation API Hibernate Validator provides
several useful custom constraints which are listed in <a class="xref" href="#table-custom-constraints" title="Table 2.3. Custom constraints">Table 2.3, “Custom constraints”</a>. With one
exception also these constraints apply to the field/property level, only <code class="literal">@ScriptAssert</code> is a class-
level constraint.</p><div class="table"><a id="table-custom-constraints"/><p class="title"><strong>Table 2.3. Custom constraints</strong></p><div class="table-contents"><table summary="Custom constraints" border="1"><colgroup><col width="25*" class="col_1"/><col width="25*" class="col_2"/><col width="25*" class="col_3"/><col width="25*" class="col_4"/></colgroup><thead><tr><th align="left" valign="top">Annotation</th><th align="left" valign="top">Supported data types</th><th align="left" valign="top">Use</th><th align="left" valign="top">Hibernate metadata impact</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">@CreditCardNumber(ignoreNonDigitCharacters=)</code></p></td><td align="left" valign="top"><p><code class="literal">CharSequence</code></p></td><td align="left" valign="top"><p>Checks that the annotated character sequence passes the
 Luhn checksum test. Note, this validation aims to check for user
 mistakes, not credit card validity! See also
 <a class="link" href="http://www.merriampark.com/anatomycc.htm">Anatomy of Credit Card Numbers</a>. <code class="literal">ignoreNonDigitCharacters</code>
 allows to ignore non digit characters. The default is <code class="literal">false</code>.</p></td><td align="left" valign="top"><p>None</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">@EAN</code></p></td><td align="left" valign="top"><p><code class="literal">CharSequence</code></p></td><td align="left" valign="top"><p>Checks that the annotated character sequence is a valid
<a class="link" href="http://en.wikipedia.org/wiki/International_Article_Number_%28EAN%29">EAN</a> barcode.
type determines the type of barcode. The default is EAN-13.</p></td><td align="left" valign="top"><p>None</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">@Email</code></p></td><td align="left" valign="top"><p><code class="literal">CharSequence</code></p></td><td align="left" valign="top"><p>Checks whether the specified character sequence is a valid email address. The optional parameters
<code class="literal">regexp</code> and <code class="literal">flags</code> allow to specify an additional regular expression (including regular expression
flags) which the email must match.</p></td><td align="left" valign="top"><p>None</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">@Length(min=,<br/>
         max=)</code></p></td><td align="left" valign="top"><p><code class="literal">CharSequence</code></p></td><td align="left" valign="top"><p>Validates that the annotated character sequence is
              between <code class="literal">min</code> and
              <code class="literal">max</code> included</p></td><td align="left" valign="top"><p>Column length will be set to max</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">@LuhnCheck(startIndex= ,<br/>
            endIndex=,<br/>
            checkDigitIndex=,<br/>
            ignoreNonDigitCharacters=)</code></p></td><td align="left" valign="top"><p><code class="literal">CharSequence</code></p></td><td align="left" valign="top"><p>Checks that the digits within the annotated character
sequence pass the Luhn checksum algorithm (see also
<a class="link" href="http://en.wikipedia.org/wiki/Luhn_algorithm">Luhn algorithm</a>). <code class="literal">startIndex</code> and
<code class="literal">endIndex</code> allow to only run the algorithm on
the specified sub-string. <code class="literal">checkDigitIndex</code>
allows to use an arbitrary digit within the character sequence
as the check digit. If not specified it is assumed that the
check digit is part of the specified range. Last but not least,
<code class="literal">ignoreNonDigitCharacters</code> allows to ignore
non digit characters.</p></td><td align="left" valign="top"><p>None</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">@Mod10Check(multiplier=,<br/>
             weight=,<br/>
             startIndex=,<br/>
             endIndex=,<br/>
             checkDigitIndex=,<br/>
             ignoreNonDigitCharacters=)</code></p></td><td align="left" valign="top"><p><code class="literal">CharSequence</code></p></td><td align="left" valign="top"><p>Checks that the digits within the annotated character
sequence pass the generic mod 10 checksum algorithm.
<code class="literal">multiplier</code> determines the multiplier for
odd numbers (defaults to 3), <code class="literal">weight</code> the
weight for even numbers (defaults to 1).
<code class="literal">startIndex</code> and
<code class="literal">endIndex</code> allow to only run the algorithm on
the specified sub-string. <code class="literal">checkDigitIndex</code>
allows to use an arbitrary digit within the character sequence
as the check digit. If not specified it is assumed that the
check digit is part of the specified range. Last but not least,
<code class="literal">ignoreNonDigitCharacters</code> allows to ignore
non digit characters.</p></td><td align="left" valign="top"><p>None</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">@Mod11Check(threshold=,<br/>
             startIndex=,<br/>
             endIndex=,<br/>
             checkDigitIndex=,<br/>
             ignoreNonDigitCharacters=,<br/>
             treatCheck10As=,<br/>
             treatCheck11As=)</code></p></td><td align="left" valign="top"><p><code class="literal">CharSequence</code></p></td><td align="left" valign="top"><p>Checks that the digits within the annotated character
sequence pass the mod 11 checksum algorithm.
<code class="literal">threshold</code> specifies the threshold for the
mod11 multiplier growth; if no value is specified the multiplier
will grow indefinitely. <code class="literal">treatCheck10As</code>
and <code class="literal">treatCheck11As</code> specify the check
digits to be used when the mod 11 checksum equals 10 or 11,
respectively. Default to X and 0, respectively.
<code class="literal">startIndex</code>, <code class="literal">endIndex</code>
<code class="literal">checkDigitIndex</code> and
<code class="literal">ignoreNonDigitCharacters</code> carry the same
semantics as in <code class="literal">@Mod10Check</code>.</p></td><td align="left" valign="top"><p>None</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">@NotBlank</code></p></td><td align="left" valign="top"><p><code class="literal">CharSequence</code></p></td><td align="left" valign="top"><p>Checks that the annotated character sequence is not null
and the trimmed length is greater than 0. The difference to
<code class="literal">@NotEmpty</code> is that this constraint can
only be applied on strings and that trailing white-spaces are
ignored.</p></td><td align="left" valign="top"><p>None</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">@NotEmpty</code></p></td><td align="left" valign="top"><p><code class="literal">CharSequence</code>, <code class="literal">Collection</code>, <code class="literal">Map</code> and arrays</p></td><td align="left" valign="top"><p>Checks whether the annotated element is not null nor empty</p></td><td align="left" valign="top"><p>None</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">@Range(min=,<br/>
        max=)</code></p></td><td align="left" valign="top"><p><code class="literal">BigDecimal</code>, <code class="literal">BigInteger</code>, <code class="literal">CharSequence</code>, <code class="literal">byte</code>, <code class="literal">short</code>, <code class="literal">int</code>, <code class="literal">long</code> and the respective wrappers of the
primitive types</p></td><td align="left" valign="top"><p>Checks whether the annotated value lies between (inclusive) the specified minimum and maximum</p></td><td align="left" valign="top"><p>None</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">@SafeHtml(whitelistType= ,<br/>
           additionalTags=,<br/>
           additionalTagsWithAttributes=)</code></p></td><td align="left" valign="top"><p><code class="literal">CharSequence</code></p></td><td align="left" valign="top"><p>Checks whether the annotated value
contains potentially malicious fragments such as <code class="literal">&lt;script/&gt;</code>. In order to use this
constraint, the
<a class="link" href="http://jsoup.org/">jsoup</a> library must be part of the class path.
With the <code class="literal">whitelistType</code> attribute a predefined whitelist type can be chosen which can
be refined via <code class="literal">additionalTags</code> or <code class="literal">additionalTagsWithAttributes</code>. The former allows to
add tags without any attributes, whereas the latter allows to specify tags and
optionally allowed attributes using the annotation <code class="literal">@SafeHtml.Tag</code>.</p></td><td align="left" valign="top"><p>None</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">@ScriptAssert(lang=,<br/>
              script=,<br/>
              alias=)</code></p></td><td align="left" valign="top"><p>Any type</p></td><td align="left" valign="top"><p>Checks whether the given script can successfully be
evaluated against the annotated element. In order to use this
constraint, an implementation of the Java Scripting API as
defined by JSR 223 ("Scripting for the
Java<sup>TM</sup> Platform") must part of the
class path. The expressions to be evaluated can be written in
any scripting or expression language, for which a JSR 223
compatible engine can be found in the class path.</p></td><td align="left" valign="top"><p>None</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">@URL(protocol=,<br/>
      host=,<br/>
      port=,<br/>
      regexp=,<br/>
      flags=)</code></p></td><td align="left" valign="top"><p><code class="literal">CharSequence</code></p></td><td align="left" valign="top"><p>Checks if the annotated character sequence is a valid URL
according to RFC2396. If any of the optional parameters
<code class="literal">protocol</code>, <code class="literal">host</code> or
<code class="literal">port</code> are specified, the corresponding URL
fragments must match the specified values. The optional
parameters <code class="literal">regexp</code> and
<code class="literal">flags</code> allow to specify an additional
regular expression (including regular expression flags) which
the URL must match. Per default this constraint used the <code class="literal">java.net.URL</code> constructor to
verify whether a given string represents a valid URL. A regular expression based version is also
available - <code class="literal">RegexpURLValidator</code> - which can be configured via XML
(see <a class="xref" href="#section-mapping-xml-constraints" title="7.2. Mapping constraints via constraint-mappings">Section 7.2, “Mapping constraints via <code class="literal">constraint-mappings</code>”</a>) or a <code class="literal">ConstraintDefinitionContributor</code>
(see <a class="xref" href="#section-constraint-definition-contributor" title="11.12.2. Constraint definitions via ConstraintDefinitionContributor">Section 11.12.2, “Constraint definitions via <code class="literal">ConstraintDefinitionContributor</code>”</a>).</p></td><td align="left" valign="top"><p>None</p></td></tr></tbody></table></div></div><br class="table-break"/><div class="section" title="2.3.2.1. Country specific constraints"><div class="titlepage"><div><div><h4 class="title"><a id="_country_specific_constraints"/>2.3.2.1. Country specific constraints</h4></div></div></div><p>Hibernate Validator offers also some country specific constraints, e.g. for the validation of social
security numbers.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>If you have to implement a country specific constraint, consider making it a contribution to
Hibernate Validator!</p></div><div class="table"><a id="table-custom-country-constraints"/><p class="title"><strong>Table 2.4. Custom country specific constraints</strong></p><div class="table-contents"><table summary="Custom country specific constraints" border="1"><colgroup><col width="20*" class="col_1"/><col width="20*" class="col_2"/><col width="20*" class="col_3"/><col width="20*" class="col_4"/><col width="20*" class="col_5"/></colgroup><thead><tr><th align="left" valign="top">Annotation</th><th align="left" valign="top">Supported data types</th><th align="left" valign="top">Use</th><th align="left" valign="top">Country</th><th align="left" valign="top">Hibernate metadata impact</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">@CNPJ</code></p></td><td align="left" valign="top"><p><code class="literal">CharSequence</code></p></td><td align="left" valign="top"><p>Checks that the annotated character sequence represents
                a Brazilian corporate tax payer registry number (Cadastro de
                Pessoa Juríeddica)</p></td><td align="left" valign="top"><p>Brazil</p></td><td align="left" valign="top"><p>None</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">@CPF</code></p></td><td align="left" valign="top"><p><code class="literal">CharSequence</code></p></td><td align="left" valign="top"><p>Checks that the annotated character sequence represents
                a Brazilian individual taxpayer registry number (Cadastro de
                Pessoa Fídsica)</p></td><td align="left" valign="top"><p>Brazil</p></td><td align="left" valign="top"><p>None</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">@TituloEleitoral</code></p></td><td align="left" valign="top"><p><code class="literal">CharSequence</code></p></td><td align="left" valign="top"><p>Checks that the annotated character sequence represents
                a Brazilian voter ID card number (<a class="link" href="http://ghiorzi.org/cgcancpf.htm">Título Eleitoral</a>)</p></td><td align="left" valign="top"><p>Brazil</p></td><td align="left" valign="top"><p>None</p></td></tr></tbody></table></div></div><br class="table-break"/><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>In some cases neither the Bean Validation constraints nor the custom constraints provided by
Hibernate Validator will fulfill your requirements. In this case you can easily write your own
constraint. You can find more information in <a class="xref" href="#validator-customconstraints" title="Chapter 6. Creating custom constraints">Chapter 6, <em>Creating custom constraints</em></a>.</p></div></div></div></div></div><div class="chapter" title="Chapter 3. Declaring and validating method constraints"><div class="titlepage"><div><div><h2 class="title"><a id="chapter-method-constraints"/>Chapter 3. Declaring and validating method constraints</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#section-declaring-method-constraints">3.1. Declaring method constraints</a></span></dt><dd><dl><dt><span class="section"><a href="#_parameter_constraints">3.1.1. Parameter constraints</a></span></dt><dt><span class="section"><a href="#_return_value_constraints">3.1.2. Return value constraints</a></span></dt><dt><span class="section"><a href="#_cascaded_validation">3.1.3. Cascaded validation</a></span></dt><dt><span class="section"><a href="#_method_constraints_in_inheritance_hierarchies">3.1.4. Method constraints in inheritance hierarchies</a></span></dt></dl></dd><dt><span class="section"><a href="#section-validating-executable-constraints">3.2. Validating method constraints</a></span></dt><dd><dl><dt><span class="section"><a href="#section-obtaining-executable-validator">3.2.1. Obtaining an <code class="literal">ExecutableValidator</code> instance</a></span></dt><dt><span class="section"><a href="#section-executable-validator-methods">3.2.2. <code class="literal">ExecutableValidator</code> methods</a></span></dt><dt><span class="section"><a href="#__literal_constraintviolation_literal_methods_for_method_validation">3.2.3. <code class="literal">ConstraintViolation</code> methods for method validation</a></span></dt></dl></dd><dt><span class="section"><a href="#section-builtin-method-constraints">3.3. Built-in method constraints</a></span></dt></dl></div><p>As of Bean Validation 1.1, constraints can not only be applied to JavaBeans and their properties,
but also to the parameters and return values of the methods and constructors of any Java type. That
way Bean Validation constraints can be used to specify</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">the preconditions that must be satisfied by the caller before a method or constructor may be
invoked (by applying constraints to the parameters of an executable)</li><li class="listitem">the postconditions that are guaranteed to the caller after a method or constructor invocation
returns (by applying constraints to the return value of an executable)</li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>For the purpose of this reference guide, the term <span class="emphasis"><em>method constraint</em></span> refers to both, method and
constructor constraints, if not stated otherwise. Occasionally, the term <span class="emphasis"><em>executable</em></span> is used when
referring to methods and constructors.</p></div><p>This approach has several advantages over traditional ways of checking the correctness of parameters
and return values:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">the checks don’t have to be performed manually (e.g. by throwing <code class="literal">IllegalArgumentException</code> or
similar), resulting in less code to write and maintain</li><li class="listitem">an executable’s pre- and postconditions don’t have to be expressed again in its documentation,
since the constraint annotations will automatically be included in the generated JavaDoc. This
avoids redundancies and reduces the chance of inconsistencies between implementation and
documentation</li></ul></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>In order to make annotations show up in the JavaDoc of annotated elements, the annotation types
themselves must be annotated with the meta annotation @Documented. This is the case for all built-in
constraints and is considered a best practice for any custom constraints.</p></div><p>In the remainder of this chapter you will learn how to declare parameter and return value
constraints and how to validate them using the <code class="literal">ExecutableValidator</code> API.</p><div class="section" title="3.1. Declaring method constraints"><div class="titlepage"><div><div><h2 class="title"><a id="section-declaring-method-constraints"/>3.1. Declaring method constraints</h2></div></div></div><div class="section" title="3.1.1. Parameter constraints"><div class="titlepage"><div><div><h3 class="title"><a id="_parameter_constraints"/>3.1.1. Parameter constraints</h3></div></div></div><p>You specify the preconditions of a method or constructor by adding constraint annotations to its
parameters as demonstrated in <a class="xref" href="#example-declaring-parameter-constraints" title="Example 3.1. Declaring method and constructor parameter constraints">Example 3.1, “Declaring method and constructor parameter constraints”</a>.</p><div class="example"><a id="example-declaring-parameter-constraints"/><p class="title"><strong>Example 3.1. Declaring method and constructor parameter constraints</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter03.parameter;

public class RentalStation {

	public RentalStation(@NotNull String name) {
		//...
	}

	public void rentCar(
			@NotNull Customer customer,
			@NotNull @Future Date startDate,
			@Min(1) int durationInDays) {
		//...
	}
}</code></pre></div></div><br class="example-break"/><p>The following preconditions are declared here:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The <code class="literal">name</code> passed to the <code class="literal">RentalCar</code> constructor must not be <code class="literal">null</code></li><li class="listitem">When invoking the <code class="literal">rentCar()</code> method, the given <code class="literal">customer</code> must not be <code class="literal">null</code>, the rental’s start
date must not be <code class="literal">null</code> as well as be in the future and finally the rental duration must be at least
one day</li></ul></div><p>Note that declaring method or constructor constraints itself does not automatically cause their
validation upon invocation of the executable. Instead, the <code class="literal">ExecutableValidator</code> API (see
<a class="xref" href="#section-validating-executable-constraints" title="3.2. Validating method constraints">Section 3.2, “Validating method constraints”</a>) must be used to perform the validation, which is
often done using a method interception facility such as AOP, proxy objects etc.</p><p>Constraints may only be applied to instance methods, i.e. declaring constraints on static methods is
not supported. Depending on the interception facility you use for triggering method validation,
additional restrictions may apply, e.g. with respect to the visibility of methods supported as
target of interception. Refer to the documentation of the interception technology to find out
whether any such limitations exist.</p><div class="section" title="3.1.1.1. Cross-parameter constraints"><div class="titlepage"><div><div><h4 class="title"><a id="_cross_parameter_constraints"/>3.1.1.1. Cross-parameter constraints</h4></div></div></div><p>Sometimes validation does not only depend on a single parameter but on several or even all
parameters of a method or constructor. This kind of requirement can be fulfilled with help of a
cross-parameter constraint.</p><p>Cross-parameter constraints can be considered as the method validation equivalent to class-level
constraints. Both can be used to implement validation requirements which are based on several
elements. While class-level constraints apply to several properties of a bean, cross-parameter
constraints apply to several parameters of an executable.</p><p>In contrast to single-parameter constraints, cross-parameter constraints are declared on the method
or constructor as you can see in <a class="xref" href="#example-using-cross-parameter-constraint" title="Example 3.2. Declaring a cross-parameter constraint">Example 3.2, “Declaring a cross-parameter constraint”</a>. Here the cross-
parameter constraint <code class="literal">@LuggageCountMatchesPassengerCount</code> declared on the <code class="literal">load()</code> method is used to
ensure that no passenger has more than two pieces of luggage.</p><div class="example"><a id="example-using-cross-parameter-constraint"/><p class="title"><strong>Example 3.2. Declaring a cross-parameter constraint</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter03.crossparameter;

public class Car {

	@LuggageCountMatchesPassengerCount(piecesOfLuggagePerPassenger = 2)
	public void load(List&lt;Person&gt; passengers, List&lt;PieceOfLuggage&gt; luggage) {
		//...
	}
}</code></pre></div></div><br class="example-break"/><p>As you will learn in the next section, return value constraints are also declared on the method
level. In order to distinguish cross-parameter constraints from return value constraints, the
constraint target is configured in the <code class="literal">ConstraintValidator</code> implementation using the
<code class="literal">@SupportedValidationTarget</code> annotation. You can find out about the details in
<a class="xref" href="#section-cross-parameter-constraints" title="6.3. Cross-parameter constraints">Section 6.3, “Cross-parameter constraints”</a> which shows how to implement your own cross-parameter constraint.</p><p>In some cases a constraint can be applied to an executable’s parameters (i.e. it is a cross-
parameter constraint), but also to the return value. One example for this are custom constraints
which allow to specify validation rules using expression or script languages.</p><p>Such constraints must define a member <code class="literal">validationAppliesTo()</code> which can be used at declaration time to
specify the constraint target. As shown in <a class="xref" href="#example-specifying-constraint-target" title="Example 3.3. Specifying a constraint’s target">Example 3.3, “Specifying a constraint’s target”</a> you apply the
constraint to an executable’s parameters by specifying
<code class="literal">validationAppliesTo = ConstraintTarget.PARAMETERS</code>, while <code class="literal">ConstraintTarget.RETURN_VALUE</code> is used
to apply the constraint to the executable return value.</p><div class="example"><a id="example-specifying-constraint-target"/><p class="title"><strong>Example 3.3. Specifying a constraint’s target</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter03.crossparameter.constrainttarget;

public class Garage {

	@ELAssert(expression = "...", validationAppliesTo = ConstraintTarget.PARAMETERS)
	public Car buildCar(List&lt;Part&gt; parts) {
		//...
	}

	@ELAssert(expression = "...", validationAppliesTo = ConstraintTarget.RETURN_VALUE)
	public Car paintCar(int color) {
		//...
	}
}</code></pre></div></div><br class="example-break"/><p>Although such a constraint is applicable to the parameters and return value of an executable, the
target can often be inferred automatically. This is the case, if the constraint is declared on</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">a void method with parameters (the constraint applies to the parameters)</li><li class="listitem">an executable with return value but no parameters (the constraint applies to the return value)</li><li class="listitem">neither a method nor a constructor, but a field, parameter etc. (the constraint applies to the
annotated element)</li></ul></div><p>In these situations you don’t have to specify the constraint target. It is still recommended to do
so if it increases readability of the source code. If the constraint target is not specified in
situations where it can’t be determined automatically, a ConstraintDeclarationException is raised.</p></div></div><div class="section" title="3.1.2. Return value constraints"><div class="titlepage"><div><div><h3 class="title"><a id="_return_value_constraints"/>3.1.2. Return value constraints</h3></div></div></div><p>The postconditions of a method or constructor are declared by adding constraint annotations to the
executable as shown in <a class="xref" href="#example-declaring-return-value-constraints" title="Example 3.4. Declaring method and constructor return value constraints">Example 3.4, “Declaring method and constructor return value constraints”</a>.</p><div class="example"><a id="example-declaring-return-value-constraints"/><p class="title"><strong>Example 3.4. Declaring method and constructor return value constraints</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter03.returnvalue;

public class RentalStation {

	@ValidRentalStation
	public RentalStation() {
		//...
	}

	@NotNull
	@Size(min = 1)
	public List&lt;Customer&gt; getCustomers() {
		//...
	}
}</code></pre></div></div><br class="example-break"/><p>The following constraints apply to the executables of RentalStation:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Any newly created <code class="literal">RentalStation</code> object must satisfy the <code class="literal">@ValidRentalStation</code> constraint</li><li class="listitem">The customer list returned by <code class="literal">getCustomers()</code> must not be <code class="literal">null</code> and must contain at least on element</li></ul></div></div><div class="section" title="3.1.3. Cascaded validation"><div class="titlepage"><div><div><h3 class="title"><a id="_cascaded_validation"/>3.1.3. Cascaded validation</h3></div></div></div><p>Similar to the cascaded validation of JavaBeans properties (see
<a class="xref" href="#section-object-graph-validation" title="2.1.6. Object graphs">Section 2.1.6, “Object graphs”</a>), the <code class="literal">@Valid</code> annotation can be used to mark executable
parameters and return values for cascaded validation. When validating a parameter or return value
annotated with <code class="literal">@Valid</code>, the constraints declared on the parameter or return value object are
validated as well.</p><p>In <a class="xref" href="#example-cascaded-executable-validation" title="Example 3.5. Marking executable parameters and return values for cascaded validation">Example 3.5, “Marking executable parameters and return values for cascaded validation”</a>, the <code class="literal">car</code> parameter of the method <code class="literal">Garage#checkCar()</code> as
well as the return value of the <code class="literal">Garage</code> constructor are marked for cascaded validation.</p><div class="example"><a id="example-cascaded-executable-validation"/><p class="title"><strong>Example 3.5. Marking executable parameters and return values for cascaded validation</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter03.cascaded;

public class Garage {

	@NotNull
	private String name;

	@Valid
	public Garage(String name) {
		this.name = name;
	}

	public boolean checkCar(@Valid @NotNull Car car) {
		//...
	}
}</code></pre><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter03.cascaded;

public class Car {

	@NotNull
	private String manufacturer;

	@NotNull
	@Size(min = 2, max = 14)
	private String licensePlate;

	public Car(String manufacturer, String licencePlate) {
		this.manufacturer = manufacturer;
		this.licensePlate = licencePlate;
	}

	//getters and setters ...
}</code></pre></div></div><br class="example-break"/><p>When validating the arguments of the <code class="literal">checkCar()</code> method, the constraints on the properties of the
passed <code class="literal">Car</code> object are evaluated as well. Similarly, the <code class="literal">@NotNull</code> constraint on the name field of
<code class="literal">Garage</code> is checked when validating the return value of the <code class="literal">Garage</code> constructor.</p><p>Generally, the cascaded validation works for executables in exactly the same way as it does for
JavaBeans properties.</p><p>In particular, <code class="literal">null</code> values are ignored during cascaded validation (naturally this can’t happen
during constructor return value validation) and cascaded validation is performed recursively, i.e.
if a parameter or return value object which is marked for cascaded validation itself has properties
marked with <code class="literal">@Valid</code>, the constraints declared on the referenced elements will be validated as well.</p><p>Cascaded validation can not only be applied to simple object references but also to collection-typed
parameters and return values. This means when putting the <code class="literal">@Valid</code> annotation to a parameter or return
value which</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">is an array</li><li class="listitem">implements <code class="literal">java.lang.Iterable</code></li><li class="listitem">or implements <code class="literal">java.util.Map</code></li></ul></div><p>each contained element gets validated. So when validating the arguments of the <code class="literal">checkCars()</code> method in
<a class="xref" href="#example-cascaded-executable-validation-listtyped" title="Example 3.6. List-typed method parameter marked for cascaded validation">Example 3.6, “List-typed method parameter marked for cascaded validation”</a>, each element instance of the passed list will
be validated and a <code class="literal">ConstraintViolation</code> created when any of the contained <code class="literal">Car</code> instances is invalid.</p><div class="example"><a id="example-cascaded-executable-validation-listtyped"/><p class="title"><strong>Example 3.6. List-typed method parameter marked for cascaded validation</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter03.cascaded.collection;

public class Garage {

	public boolean checkCars(@Valid @NotNull List&lt;Car&gt; cars) {
		//...
	}
}</code></pre></div></div><br class="example-break"/></div><div class="section" title="3.1.4. Method constraints in inheritance hierarchies"><div class="titlepage"><div><div><h3 class="title"><a id="_method_constraints_in_inheritance_hierarchies"/>3.1.4. Method constraints in inheritance hierarchies</h3></div></div></div><p>When declaring method constraints in inheritance hierarchies, it is important to be aware of the
following rules:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The preconditions to be satisfied by the caller of a method may not be strengthened in subtypes</li><li class="listitem">The postconditions guaranteed to the caller of a method may not be weakened in subtypes</li></ul></div><p>These rules are motivated by the concept of <span class="emphasis"><em>behavioral subtyping</em></span> which requires that wherever a
type <code class="literal">T</code> is used, also a subtype <code class="literal">S</code> of <code class="literal">T</code> may be used without altering the program’s behavior.</p><p>As an example, consider a class invoking a method on an object with the static type <code class="literal">T</code>. If the
runtime type of that object was <code class="literal">S</code> and <code class="literal">S</code> imposed additional preconditions, the client class might
fail to satisfy these preconditions as is not aware of them. The rules of behavioral subtyping are
also known as the <a class="link" href="http://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov
substitution principle</a>.</p><p>The Bean Validation specification implements the first rule by disallowing parameter constraints on
methods which override or implement a method declared in a supertype (superclass or interface).
<a class="xref" href="#example-illegal-parameter-constraints" title="Example 3.7. Illegal method parameter constraint in subtype">Example 3.7, “Illegal method parameter constraint in subtype”</a> shows a violation of this rule.</p><div class="example"><a id="example-illegal-parameter-constraints"/><p class="title"><strong>Example 3.7. Illegal method parameter constraint in subtype</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter03.inheritance.parameter;

public interface Vehicle {

    void drive(@Max(75) int speedInMph);
}</code></pre><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter03.inheritance.parameter;

public class Car implements Vehicle {

	@Override
	public void drive(@Max(55) int speedInMph) {
		//...
	}
}</code></pre></div></div><br class="example-break"/><p>The <code class="literal">@Max</code> constraint on <code class="literal">Car#drive()</code> is illegal since this method implements the interface method
<code class="literal">Vehicle#drive()</code>. Note that parameter constraints on overriding methods are also disallowed, if the
supertype method itself doesn’t declare any parameter constraints.</p><p>Furthermore, if a method overrides or implements a method declared in several parallel supertypes
(e.g. two interfaces not extending each other or a class and an interface not implemented by that
class), no parameter constraints may be specified for the method in any of the involved types. The
types in <a class="xref" href="#example-illegal-parameter-constraints-parallel-types" title="Example 3.8. Illegal method parameter constraint in parallel types of a hierarchy">Example 3.8, “Illegal method parameter constraint in parallel types of a hierarchy”</a> demonstrate a violation of that
rule. The method <code class="literal">RacingCar#drive()</code> overrides <code class="literal">Vehicle#drive()</code> as well as <code class="literal">Car#drive()</code>.
Therefore the constraint on <code class="literal">Vehicle#drive()</code> is illegal.</p><div class="example"><a id="example-illegal-parameter-constraints-parallel-types"/><p class="title"><strong>Example 3.8. Illegal method parameter constraint in parallel types of a hierarchy</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter03.inheritance.parallel;

public interface Vehicle {

	void drive(@Max(75) int speedInMph);
}</code></pre><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter03.inheritance.parallel;

public interface Car {

	public void drive(int speedInMph);
}</code></pre><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter03.inheritance.parallel;

public class RacingCar implements Car, Vehicle {

	@Override
	public void drive(int speedInMph) {
		//...
	}
}</code></pre></div></div><br class="example-break"/><p>The previously described restrictions only apply to parameter constraints. In contrast, return value
constraints may be added in methods overriding or implementing any supertype methods.</p><p>In this case, all the method’s return value constraints apply for the subtype method, i.e. the
constraints declared on the subtype method itself as well as any return value constraints on
overridden/implemented supertype methods. This is legal as putting additional return value
constraints in place may never represent a weakening of the postconditions guaranteed to the caller
of a method.</p><p>So when validating the return value of the method <code class="literal">Car#getPassengers()</code> shown in
<a class="xref" href="#example-return-value-constraints-in-hierarchy" title="Example 3.9. Return value constraints on supertype and subtype method">Example 3.9, “Return value constraints on supertype and subtype method”</a>, the <code class="literal">@Size</code> constraint on the method itself as well
as the <code class="literal">@NotNull</code> constraint on the implemented interface method <code class="literal">Vehicle#getPassengers()</code> apply.</p><div class="example"><a id="example-return-value-constraints-in-hierarchy"/><p class="title"><strong>Example 3.9. Return value constraints on supertype and subtype method</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter03.inheritance.returnvalue;

public interface Vehicle {

	@NotNull
	List&lt;Person&gt; getPassengers();
}</code></pre><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter03.inheritance.returnvalue;

public class Car implements Vehicle {

	@Override
	@Size(min = 1)
	public List&lt;Person&gt; getPassengers() {
		//...
	}
}</code></pre></div></div><br class="example-break"/><p>If the validation engine detects a violation of any of the aforementioned rules, a
<code class="literal">ConstraintDeclarationException</code> will be raised.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>The rules described in this section only apply to methods but not constructors. By definition,
constructors never override supertype constructors. Therefore, when validating the parameters or the
return value of a constructor invocation only the constraints declared on the constructor itself
apply, but never any constraints declared on supertype constructors.</p></div></div></div><div class="section" title="3.2. Validating method constraints"><div class="titlepage"><div><div><h2 class="title"><a id="section-validating-executable-constraints"/>3.2. Validating method constraints</h2></div></div></div><p>The validation of method constraints is done using the <code class="literal">ExecutableValidator</code> interface.</p><p>In <a class="xref" href="#section-obtaining-executable-validator" title="3.2.1. Obtaining an ExecutableValidator instance">Section 3.2.1, “Obtaining an <code class="literal">ExecutableValidator</code> instance”</a> you will learn how to obtain an <code class="literal">ExecutableValidator</code>
instance while <a class="xref" href="#section-executable-validator-methods" title="3.2.2. ExecutableValidator methods">Section 3.2.2, “<code class="literal">ExecutableValidator</code> methods”</a> shows how to use the different methods
offered by this interface.</p><p>Instead of calling the <code class="literal">ExecutableValidator</code> methods directly from within application code, they are
usually invoked via a method interception technology such as AOP, proxy objects, etc. This causes
executable constraints to be validated automatically and transparently upon method or constructor
invocation. Typically a <code class="literal">ConstraintViolationException</code> is raised by the integration layer in case any
of the constraints is violated.</p><div class="section" title="3.2.1. Obtaining an ExecutableValidator instance"><div class="titlepage"><div><div><h3 class="title"><a id="section-obtaining-executable-validator"/>3.2.1. Obtaining an <code class="literal">ExecutableValidator</code> instance</h3></div></div></div><p>You can retrieve an <code class="literal">ExecutableValidator</code> instance via <code class="literal">Validator#forExecutables()</code> as shown in
<a class="xref" href="#example-obtaining-executable-validator" title="Example 3.10. Obtaining an ExecutableValidator instance">Example 3.10, “Obtaining an <code class="literal">ExecutableValidator</code> instance”</a>.</p><div class="example"><a id="example-obtaining-executable-validator"/><p class="title"><strong>Example 3.10. Obtaining an <code class="literal">ExecutableValidator</code> instance</strong></p><div class="example-contents"><pre><code class="language-java">ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
executableValidator = factory.getValidator().forExecutables();</code></pre></div></div><br class="example-break"/><p>In the example the executable validator is retrieved from the default validator factory, but if
required you could also bootstrap a specifically configured factory as described in
<a class="xref" href="#chapter-bootstrapping" title="Chapter 8. Bootstrapping">Chapter 8, <em>Bootstrapping</em></a>, for instance in order to use a specific parameter name provider
(see <a class="xref" href="#section-parameter-name-provider" title="8.2.4. ParameterNameProvider">Section 8.2.4, “<code class="literal">ParameterNameProvider</code>”</a>).</p></div><div class="section" title="3.2.2. ExecutableValidator methods"><div class="titlepage"><div><div><h3 class="title"><a id="section-executable-validator-methods"/>3.2.2. <code class="literal">ExecutableValidator</code> methods</h3></div></div></div><p>The <code class="literal">ExecutableValidator</code> interface offers altogether four methods:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">validateParameters()</code> and <code class="literal">validateReturnValue()</code> for method validation</li><li class="listitem"><code class="literal">validateConstructorParameters()</code> and <code class="literal">validateConstructorReturnValue()</code> for constructor validation</li></ul></div><p>Just as the methods on <code class="literal">Validator</code>, all these methods return a <code class="literal">Set&lt;ConstraintViolation&gt;</code> which contains
a <code class="literal">ConstraintViolation</code> instance for each violated constraint and which is empty if the validation
succeeds. Also all the methods have a var-args groups parameter by which you can pass the validation
groups to be considered for validation.</p><p>The examples in the following sections are based on the methods on constructors of the <code class="literal">Car</code> class
shown in <a class="xref" href="#example-executable-validator-class-car" title="Example 3.11. Class Car with constrained methods and constructors">Example 3.11, “Class <code class="literal">Car</code> with constrained methods and constructors”</a>.</p><div class="example"><a id="example-executable-validator-class-car"/><p class="title"><strong>Example 3.11. Class <code class="literal">Car</code> with constrained methods and constructors</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter03.validation;

public class Car {

	public Car(@NotNull String manufacturer) {
		//...
	}

	@ValidRacingCar
	public Car(String manufacturer, String team) {
		//...
	}

	public void drive(@Max(75) int speedInMph) {
		//...
	}

	@Size(min = 1)
	public List&lt;Passenger&gt; getPassengers() {
		//...
	}
}</code></pre></div></div><br class="example-break"/><div class="section" title="3.2.2.1. ExecutableValidator#validateParameters()"><div class="titlepage"><div><div><h4 class="title"><a id="__literal_executablevalidator_validateparameters_literal"/>3.2.2.1. <code class="literal">ExecutableValidator#validateParameters()</code></h4></div></div></div><p>The method <code class="literal">validateParameters()</code> is used to validate the arguments of a method invocation.
<a class="xref" href="#example-executable-validator-validate-parameters" title="Example 3.12. Using ExecutableValidator#validateParameters()">Example 3.12, “Using <code class="literal">ExecutableValidator#validateParameters()</code>”</a> shows an example. The validation results in a
violation of the <code class="literal">@Max</code> constraint on the parameter of the <code class="literal">drive()</code> method.</p><div class="example"><a id="example-executable-validator-validate-parameters"/><p class="title"><strong>Example 3.12. Using <code class="literal">ExecutableValidator#validateParameters()</code></strong></p><div class="example-contents"><pre><code class="language-java">Car object = new Car( "Morris" );
Method method = Car.class.getMethod( "drive", int.class );
Object[] parameterValues = { 80 };
Set&lt;ConstraintViolation&lt;Car&gt;&gt; violations = executableValidator.validateParameters(
		object,
		method,
		parameterValues
);

assertEquals( 1, violations.size() );
Class&lt;? extends Annotation&gt; constraintType = violations.iterator()
		.next()
		.getConstraintDescriptor()
		.getAnnotation()
		.annotationType();
assertEquals( Max.class, constraintType );</code></pre></div></div><br class="example-break"/><p>Note that <code class="literal">validateParameters()</code> validates all the parameter constraints of a method, i.e. constraints
on individual parameters as well as cross-parameter constraints.</p></div><div class="section" title="3.2.2.2. ExecutableValidator#validateReturnValue()"><div class="titlepage"><div><div><h4 class="title"><a id="__literal_executablevalidator_validatereturnvalue_literal"/>3.2.2.2. <code class="literal">ExecutableValidator#validateReturnValue()</code></h4></div></div></div><p>Using <code class="literal">validateReturnValue()</code> the return value of a method can can be validated. The validation in
<a class="xref" href="#example-executable-validator-validate-return-value" title="Example 3.13. Using ExecutableValidator#validateReturnValue()">Example 3.13, “Using <code class="literal">ExecutableValidator#validateReturnValue()</code>”</a> yields one constraint violation since the
<code class="literal">getPassengers()</code> method is expect to return at least one <code class="literal">Passenger</code> instance.</p><div class="example"><a id="example-executable-validator-validate-return-value"/><p class="title"><strong>Example 3.13. Using <code class="literal">ExecutableValidator#validateReturnValue()</code></strong></p><div class="example-contents"><pre><code class="language-java">Car object = new Car( "Morris" );
Method method = Car.class.getMethod( "getPassengers" );
Object returnValue = Collections.&lt;Passenger&gt;emptyList();
Set&lt;ConstraintViolation&lt;Car&gt;&gt; violations = executableValidator.validateReturnValue(
		object,
		method,
		returnValue
);

assertEquals( 1, violations.size() );
Class&lt;? extends Annotation&gt; constraintType = violations.iterator()
		.next()
		.getConstraintDescriptor()
		.getAnnotation()
		.annotationType();
assertEquals( Size.class, constraintType );</code></pre></div></div><br class="example-break"/></div><div class="section" title="3.2.2.3. ExecutableValidator#validateConstructorParameters()"><div class="titlepage"><div><div><h4 class="title"><a id="__literal_executablevalidator_validateconstructorparameters_literal"/>3.2.2.3. <code class="literal">ExecutableValidator#validateConstructorParameters()</code></h4></div></div></div><p>The arguments of constructor invocations can be validated with <code class="literal">validateConstructorParameters()</code> as
shown in method <a class="xref" href="#example-executable-validator-validate-constructor-parameters" title="Example 3.14. Using ExecutableValidator#validateConstructorParameters()">Example 3.14, “Using <code class="literal">ExecutableValidator#validateConstructorParameters()</code>”</a>. Due to the
<code class="literal">@NotNull</code> constraint on the manufacturer parameter, the validation call returns one constraint
violation.</p><div class="example"><a id="example-executable-validator-validate-constructor-parameters"/><p class="title"><strong>Example 3.14. Using <code class="literal">ExecutableValidator#validateConstructorParameters()</code></strong></p><div class="example-contents"><pre><code class="language-java">Constructor&lt;Car&gt; constructor = Car.class.getConstructor( String.class );
Object[] parameterValues = { null };
Set&lt;ConstraintViolation&lt;Car&gt;&gt; violations = executableValidator.validateConstructorParameters(
		constructor,
		parameterValues
);

assertEquals( 1, violations.size() );
Class&lt;? extends Annotation&gt; constraintType = violations.iterator()
		.next()
		.getConstraintDescriptor()
		.getAnnotation()
		.annotationType();
assertEquals( NotNull.class, constraintType );</code></pre></div></div><br class="example-break"/></div><div class="section" title="3.2.2.4. ExecutableValidator#validateConstructorReturnValue()"><div class="titlepage"><div><div><h4 class="title"><a id="__literal_executablevalidator_validateconstructorreturnvalue_literal"/>3.2.2.4. <code class="literal">ExecutableValidator#validateConstructorReturnValue()</code></h4></div></div></div><p>Finally, by using <code class="literal">validateConstructorReturnValue()</code> you can validate a constructor’s return value. In
<a class="xref" href="#example-executable-validator-validate-constructor-return-value" title="Example 3.15. Using ExecutableValidator#validateConstructorReturnValue()">Example 3.15, “Using <code class="literal">ExecutableValidator#validateConstructorReturnValue()</code>”</a>, <code class="literal">validateConstructorReturnValue()</code>
returns one constraint violation, since the <code class="literal">Car</code> instance returned by the constructor doesn’t satisfy
the <code class="literal">@ValidRacingCar</code> constraint (not shown).</p><div class="example"><a id="example-executable-validator-validate-constructor-return-value"/><p class="title"><strong>Example 3.15. Using <code class="literal">ExecutableValidator#validateConstructorReturnValue()</code></strong></p><div class="example-contents"><pre><code class="language-java">//constructor for creating racing cars
Constructor&lt;Car&gt; constructor = Car.class.getConstructor( String.class, String.class );
Car createdObject = new Car( "Morris", null );
Set&lt;ConstraintViolation&lt;Car&gt;&gt; violations = executableValidator.validateConstructorReturnValue(
		constructor,
		createdObject
);

assertEquals( 1, violations.size() );
Class&lt;? extends Annotation&gt; constraintType = violations.iterator()
		.next()
		.getConstraintDescriptor()
		.getAnnotation()
		.annotationType();
assertEquals( ValidRacingCar.class, constraintType );</code></pre></div></div><br class="example-break"/></div></div><div class="section" title="3.2.3. ConstraintViolation methods for method validation"><div class="titlepage"><div><div><h3 class="title"><a id="__literal_constraintviolation_literal_methods_for_method_validation"/>3.2.3. <code class="literal">ConstraintViolation</code> methods for method validation</h3></div></div></div><p>In addition to the methods introduced in <a class="xref" href="#section-constraint-violation-methods" title="2.2.3. ConstraintViolation methods">Section 2.2.3, “<code class="literal">ConstraintViolation</code> methods”</a>,
<code class="literal">ConstraintViolation</code> provides two more methods specific to the validation of executable parameters
and return values.</p><p><code class="literal">ConstraintViolation#getExecutableParameters()</code> returns the validated parameter array in case of
method or constructor parameter validation, while <code class="literal">ConstraintViolation#getExecutableReturnValue()</code>
provides access to the validated object in case of return value validation.</p><p>All the other <code class="literal">ConstraintViolation</code> methods generally work for method validation in the same way as
for validation of beans. Refer to the <a class="link" href="http://docs.jboss.org/hibernate/beanvalidation/spec/1.1 /api/index.html?javax/validation/metadata/BeanDescriptor.html">JavaDoc</a> to learn more about the
behavior of the individual methods and their return values during bean and method validation.</p><p>Note that <code class="literal">getPropertyPath()</code> can be very useful in order to obtain detailed information about the
validated parameter or return value, e.g. for logging purposes. In particular, you can retrieve name
and argument types of the concerned method as well as the index of the concerned parameter from the
path nodes. How this can be done is shown in <a class="xref" href="#example-executable-validation-property-path" title="Example 3.16. Retrieving method and parameter information">Example 3.16, “Retrieving method and parameter information”</a>.</p><div class="example"><a id="example-executable-validation-property-path"/><p class="title"><strong>Example 3.16. Retrieving method and parameter information</strong></p><div class="example-contents"><pre><code class="language-java">Car object = new Car( "Morris" );
Method method = Car.class.getMethod( "drive", int.class );
Object[] parameterValues = { 80 };
Set&lt;ConstraintViolation&lt;Car&gt;&gt; violations = executableValidator.validateParameters(
		object,
		method,
		parameterValues
);

assertEquals( 1, violations.size() );
Iterator&lt;Node&gt; propertyPath = violations.iterator()
		.next()
		.getPropertyPath()
		.iterator();

MethodNode methodNode = propertyPath.next().as( MethodNode.class );
assertEquals( "drive", methodNode.getName() );
assertEquals( Arrays.&lt;Class&lt;?&gt;&gt;asList( int.class ), methodNode.getParameterTypes() );

ParameterNode parameterNode = propertyPath.next().as( ParameterNode.class );
assertEquals( "arg0", parameterNode.getName() );
assertEquals( 0, parameterNode.getParameterIndex() );</code></pre></div></div><br class="example-break"/><p>The parameter name is determined using the current <code class="literal">ParameterNameProvider</code> (see
<a class="xref" href="#section-parameter-name-provider" title="8.2.4. ParameterNameProvider">Section 8.2.4, “<code class="literal">ParameterNameProvider</code>”</a>) and defaults to <code class="literal">arg0</code>, <code class="literal">arg1</code> etc.</p></div></div><div class="section" title="3.3. Built-in method constraints"><div class="titlepage"><div><div><h2 class="title"><a id="section-builtin-method-constraints"/>3.3. Built-in method constraints</h2></div></div></div><p>In addition to the built-in bean and property-level constraints discussed in
<a class="xref" href="#section-builtin-constraints" title="2.3. Built-in constraints">Section 2.3, “Built-in constraints”</a>, Hibernate Validator currently provides one method-level constraint,
<code class="literal">@ParameterScriptAssert</code>. This is a generic cross-parameter constraint which allows to implement
validation routines using any JSR 223 compatible ("Scripting for the Java<sup>TM</sup> Platform") scripting
language, provided an engine for this language is available on the classpath.</p><p>To refer to the executable’s parameters from within the expression, use their name as obtained from
the active parameter name provider (see <a class="xref" href="#section-parameter-name-provider" title="8.2.4. ParameterNameProvider">Section 8.2.4, “<code class="literal">ParameterNameProvider</code>”</a>).
<a class="xref" href="#example-parameterscriptassert" title="Example 3.17. Using @ParameterScriptAssert">Example 3.17, “Using <code class="literal">@ParameterScriptAssert</code>”</a> shows how the validation logic of the <code class="literal">@LuggageCountMatchesPassengerCount</code>
constraint from <a class="xref" href="#example-using-cross-parameter-constraint" title="Example 3.2. Declaring a cross-parameter constraint">Example 3.2, “Declaring a cross-parameter constraint”</a> could be expressed with the help of
<code class="literal">@ParameterScriptAssert</code>.</p><div class="example"><a id="example-parameterscriptassert"/><p class="title"><strong>Example 3.17. Using <code class="literal">@ParameterScriptAssert</code></strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter03.parametersscriptassert;

public class Car {

	@ParameterScriptAssert(lang = "javascript", script = "arg1.size() &lt;= arg0.size() * 2")
	public void load(List&lt;Person&gt; passengers, List&lt;PieceOfLuggage&gt; luggage) {
		//...
	}
}</code></pre></div></div><br class="example-break"/></div></div><div class="chapter" title="Chapter 4. Interpolating constraint error messages"><div class="titlepage"><div><div><h2 class="title"><a id="chapter-message-interpolation"/>Chapter 4. Interpolating constraint error messages</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#section-message-interpolation">4.1. Default message interpolation</a></span></dt><dd><dl><dt><span class="section"><a href="#section-special-characters">4.1.1. Special characters</a></span></dt><dt><span class="section"><a href="#section-interpolation-with-message-expressions">4.1.2. Interpolation with message expressions</a></span></dt><dt><span class="section"><a href="#_examples">4.1.3. Examples</a></span></dt></dl></dd><dt><span class="section"><a href="#section-custom-message-interpolation">4.2. Custom message interpolation</a></span></dt><dd><dl><dt><span class="section"><a href="#section-resource-bundle-locator">4.2.1. <code class="literal">ResourceBundleLocator</code></a></span></dt></dl></dd></dl></div><p>Message interpolation is the process of creating error messages for violated Bean Validation
constraints. In this chapter you will learn how such messages are defined and resolved and how you
can plug in custom message interpolators in case the default algorithm is not sufficient for your
requirements.</p><div class="section" title="4.1. Default message interpolation"><div class="titlepage"><div><div><h2 class="title"><a id="section-message-interpolation"/>4.1. Default message interpolation</h2></div></div></div><p>Constraint violation messages are retrieved from so called message descriptors. Each constraint
defines its default message descriptor using the message attribute. At declaration time, the default
descriptor can be overridden with a specific value as shown in <a class="xref" href="#example-overriding-message" title="Example 4.1. Specifying a message descriptor using the message attribute">Example 4.1, “Specifying a message descriptor using the message attribute”</a>.</p><div class="example"><a id="example-overriding-message"/><p class="title"><strong>Example 4.1. Specifying a message descriptor using the message attribute</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter04;

public class Car {

	@NotNull(message = "The manufacturer name must not be null")
	private String manufacturer;

	//constructor, getters and setters ...
}</code></pre></div></div><br class="example-break"/><p>If a constraint is violated, its descriptor will be interpolated by the validation engine using the
currently configured <code class="literal">MessageInterpolator</code>. The interpolated error message can then be retrieved from
the resulting constraint violation by calling <code class="literal">ConstraintViolation#getMessage()</code>.</p><p>Message descriptors can contain <span class="emphasis"><em>message parameters</em></span> as well as <span class="emphasis"><em>message expressions</em></span> which will be
resolved during interpolation. Message parameters are string literals enclosed in <code class="literal">{}</code>, while
message expressions are string literals enclosed in <code class="literal">${}</code>. The following algorithm is applied during
method interpolation:</p><div class="orderedlist"><ol class="orderedlist" type="1"><li class="listitem">Resolve any message parameters by using them as key for the resource bundle <span class="emphasis"><em>ValidationMessages</em></span>. If
this bundle contains an entry for a given message parameter, that parameter will be replaced in the
message with the corresponding value from the bundle. This step will be executed recursively in case
the replaced value again contains message parameters. The resource bundle is expected to be provided
by the application developer, e.g. by adding a file named <span class="emphasis"><em>ValidationMessages.properties</em></span> to the
classpath. You can also create localized error messages by providing locale specific variations of
this bundle, such as <span class="emphasis"><em>ValidationMessages_en_US.properties</em></span>. By default, the JVM’s default locale
(<code class="literal">Locale#getDefault()</code>) will be used when looking up messages in the bundle.</li><li class="listitem">Resolve any message parameters by using them as key for a resource bundle containing the standard
error messages for the built-in constraints as defined in Appendix B of the Bean Validation
specification. In the case of Hibernate Validator, this bundle is named
<code class="literal">org.hibernate.validator.ValidationMessages</code>. If this step triggers a replacement, step 1 is executed
again, otherwise step 3 is applied.</li><li class="listitem">Resolve any message parameters by replacing them with the value of the constraint annotation member
of the same name. This allows to refer to attribute values of the constraint (e.g. <code class="literal">Size#min()</code>) in
the error message (e.g. "must be at least ${min}").</li><li class="listitem">Resolve any message expressions by evaluating them as expressions of the Unified Expression
Language. See <a class="xref" href="#section-interpolation-with-message-expressions" title="4.1.2. Interpolation with message expressions">Section 4.1.2, “Interpolation with message expressions”</a> to learn more about the usage of
Unified EL in error messages.</li></ol></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>You can find the formal definition of the interpolation algorithm in section
<a class="link" href="http://beanvalidation.org/1.1/spec/#default-resolution-algorithm">5.3.1.1</a> of the Bean
Validation specification.</p></div><div class="section" title="4.1.1. Special characters"><div class="titlepage"><div><div><h3 class="title"><a id="section-special-characters"/>4.1.1. Special characters</h3></div></div></div><p>Since the characters <code class="literal">{</code>, <code class="literal">}</code> and <code class="literal">$</code> have a special meaning in message descriptors they need to be escaped if you want to use them literally. The following rules apply:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">\{</code> is considered as the literal <code class="literal">{</code></li><li class="listitem"><code class="literal">\}</code> is considered as the literal <code class="literal">}</code></li><li class="listitem"><code class="literal">\$</code> is considered as the literal <code class="literal">$</code></li><li class="listitem"><code class="literal">\\</code> is considered as the literal <code class="literal">\</code></li></ul></div></div><div class="section" title="4.1.2. Interpolation with message expressions"><div class="titlepage"><div><div><h3 class="title"><a id="section-interpolation-with-message-expressions"/>4.1.2. Interpolation with message expressions</h3></div></div></div><p>As of Hibernate Validator 5 (Bean Validation 1.1) it is possible to use the Unified Expression
Language (as defined by <a class="link" href="http://jcp.org/en/jsr/detail?id=341">JSR 341</a>) in constraint
violation messages. This allows to define error messages based on conditional logic and also enables
advanced formatting options. The validation engine makes the following objects available in the EL
context:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">the attribute values of the constraint mapped to the attribute names</li><li class="listitem">the currently validated value (property, bean, method parameter etc.) under the name <span class="emphasis"><em>validatedValue</em></span></li><li class="listitem">a bean mapped to the name formatter exposing the var-arg method
<code class="literal">format(String format, Object…​ args)</code> which behaves like
<code class="literal">java.util.Formatter.format(String format, Object…​ args)</code>.</li></ul></div><p>The following section provides several examples for using EL expressions in error messages.</p></div><div class="section" title="4.1.3. Examples"><div class="titlepage"><div><div><h3 class="title"><a id="_examples"/>4.1.3. Examples</h3></div></div></div><p><a class="xref" href="#example-message-descriptors" title="Example 4.2. Specifying message descriptors">Example 4.2, “Specifying message descriptors”</a> shows how to make use of the different options for specifying
message descriptors.</p><div class="example"><a id="example-message-descriptors"/><p class="title"><strong>Example 4.2. Specifying message descriptors</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter04.complete;

public class Car {

	@NotNull
	private String manufacturer;

	@Size(min = 2,
		max = 14,
		message = "The license plate '${validatedValue}' must be between {min} and {max} characters long"
	)
	private String licensePlate;

	@Min(value = 2,
		message = "There must be at least {value} seat${value &gt; 1 ? 's' : ''}"
	)
	private int seatCount;

	@DecimalMax(value = "350",
			message = "The top speed ${formatter.format('%1$.2f', validatedValue)} is higher " +
					"than {value}"
	)
	private double topSpeed;

	@DecimalMax(value = "100000", message = "Price must not be higher than ${value}")
	private BigDecimal price;

	public Car(
			String manufacturer,
			String licensePlate,
			int seatCount,
			double topSpeed,
			BigDecimal price) {
		this.manufacturer = manufacturer;
		this.licensePlate = licensePlate;
		this.seatCount = seatCount;
		this.topSpeed = topSpeed;
		this.price = price;
	}

	//getters and setters ...
}</code></pre></div></div><br class="example-break"/><p>Validating an invalid <code class="literal">Car</code> instance yields constraint violations with the messages shown by the
assertions in <a class="xref" href="#example-expected-error-messages" title="Example 4.3. Expected error messages">Example 4.3, “Expected error messages”</a>:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">the <code class="literal">@NotNull</code> constraint on the <code class="literal">manufacturer</code> field causes the error message "may not be null", as
this is the default message defined by the Bean Validation specification and no specific descriptor
is given in the message attribute</li><li class="listitem">the <code class="literal">@Size</code> constraint on the <code class="literal">licensePlate</code> field shows the interpolation of message parameters
(<code class="literal">{min}</code>, <code class="literal">{max}</code>) and how to add the validated value to the error message using the EL
expression <code class="literal">${validatedValue}</code></li><li class="listitem">the <code class="literal">@Min</code> constraint on <code class="literal">seatCount</code> demonstrates how use an EL expression with a ternery expression to
dynamically chose singular or plural form, depending on an attribute of the constraint ("There must
be at least 1 seat" vs. "There must be at least 2 seats")</li><li class="listitem">the message for the <code class="literal">@DecimalMax</code> constraint on <code class="literal">topSpeed</code> shows how to format the validated
value using the formatter instance</li><li class="listitem">finally, the <code class="literal">@DecimalMax</code> constraint on price shows that parameter interpolation has precedence over
expression evaluation, causing the <code class="literal">$</code> sign to show up in front of the maximum price</li></ul></div><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>Only actual constraint attributes can be interpolated using message parameters in the form
<code class="literal">{attributeName}</code>. When referring to the validated value or custom expression variables added to the
interpolation context (see <a class="xref" href="#section-hibernateconstraintvalidatorcontext" title="11.9.1. HibernateConstraintValidatorContext">Section 11.9.1, “<code class="literal">HibernateConstraintValidatorContext</code>”</a>), an EL expression in the
form <code class="literal">${attributeName}</code> must be used.</p></div><div class="example"><a id="example-expected-error-messages"/><p class="title"><strong>Example 4.3. Expected error messages</strong></p><div class="example-contents"><pre><code class="language-java">Car car = new Car( null, "A", 1, 400.123456, BigDecimal.valueOf( 200000 ) );

String message = validator.validateProperty( car, "manufacturer" )
		.iterator()
		.next()
		.getMessage();
assertEquals( "may not be null", message );

message = validator.validateProperty( car, "licensePlate" )
		.iterator()
		.next()
		.getMessage();
assertEquals(
		"The license plate must be between 2 and 14 characters long",
		message
);

message = validator.validateProperty( car, "seatCount" ).iterator().next().getMessage();
assertEquals( "There must be at least 2 seats", message );

message = validator.validateProperty( car, "topSpeed" ).iterator().next().getMessage();
assertEquals( "The top speed 400.12 is higher than 350", message );

message = validator.validateProperty( car, "price" ).iterator().next().getMessage();
assertEquals( "Price must not be higher than $100000", message );</code></pre></div></div><br class="example-break"/></div></div><div class="section" title="4.2. Custom message interpolation"><div class="titlepage"><div><div><h2 class="title"><a id="section-custom-message-interpolation"/>4.2. Custom message interpolation</h2></div></div></div><p>If the default message interpolation algorithm does not fit your requirements it is also possible to
plug in a custom <code class="literal">MessageInterpolator</code> implementation.</p><p>Custom interpolators must implement the interface <code class="literal">javax.validation.MessageInterpolator</code>. Note that
implementations must be thread-safe. It is recommended that custom message interpolators delegate
final implementation to the default interpolator, which can be obtained via
<code class="literal">Configuration#getDefaultMessageInterpolator()</code>.</p><p>In order to use a custom message interpolator it must be registered either by configuring it in the
Bean Validation XML descriptor <span class="emphasis"><em>META-INF/validation.xml</em></span> (see
<a class="xref" href="#section-configuration-validation-xml" title="7.1. Configuring the validator factory in validation.xml">Section 7.1, “Configuring the validator factory in <span class="emphasis"><em>validation.xml</em></span>”</a>) or by passing it when bootstrapping a <code class="literal">ValidatorFactory</code> or
<code class="literal">Validator</code> (see <a class="xref" href="#section-validator-factory-message-interpolator" title="8.2.1. MessageInterpolator">Section 8.2.1, “<code class="literal">MessageInterpolator</code>”</a> and
<a class="xref" href="#section-configuring-validator" title="8.3. Configuring a Validator">Section 8.3, “Configuring a Validator”</a>, respectively).</p><div class="section" title="4.2.1. ResourceBundleLocator"><div class="titlepage"><div><div><h3 class="title"><a id="section-resource-bundle-locator"/>4.2.1. <code class="literal">ResourceBundleLocator</code></h3></div></div></div><p>In some use cases you want to use the message interpolation algorithm as defined by the Bean
Validation specification, but retrieve error messages from other resource bundles than
<span class="emphasis"><em>ValidationMessages</em></span>. In this situation Hibernate Validator’s <code class="literal">ResourceBundleLocator</code> SPI can help.</p><p>The default message interpolator in Hibernate Validator, <code class="literal">ResourceBundleMessageInterpolator</code>,
delegates retrieval of resource bundles to that SPI. Using an alternative bundle only requires
passing an instance of <code class="literal">PlatformResourceBundleLocator</code> with the bundle name when bootstrapping the
<code class="literal">ValidatorFactory</code> as shown in <a class="xref" href="#example-using-specific-resource-bundle-locator" title="Example 4.4. Using a specific resource bundle">Example 4.4, “Using a specific resource bundle”</a>.</p><div class="example"><a id="example-using-specific-resource-bundle-locator"/><p class="title"><strong>Example 4.4. Using a specific resource bundle</strong></p><div class="example-contents"><pre><code class="language-java">Validator validator = Validation.byDefaultProvider()
		.configure()
		.messageInterpolator(
				new ResourceBundleMessageInterpolator(
						new PlatformResourceBundleLocator( "MyMessages" )
				)
		)
		.buildValidatorFactory()
		.getValidator();</code></pre></div></div><br class="example-break"/><p>Of course you also could implement a completely different <code class="literal">ResourceBundleLocator</code>, which for instance
returns bundles backed by records in a database. In this case you can obtain the default locator via
<code class="literal">HibernateValidatorConfiguration#getDefaultResourceBundleLocator()</code>, which you e.g. could use as
fall-back for your custom locator.</p><p>Besides <code class="literal">PlatformResourceBundleLocator</code>, Hibernate Validator provides another resource bundle locator
implementation out of the box, namely <code class="literal">AggregateResourceBundleLocator</code>, which allows to retrieve error
messages from more than one resource bundle. You could for instance use this implementation in a
multi-module application where you want to have one message bundle per module.
<a class="xref" href="#example-using-aggregate-resource-bundle-locator" title="Example 4.5. Using AggregateResourceBundleLocator">Example 4.5, “Using <code class="literal">AggregateResourceBundleLocator</code>”</a> shows how to use <code class="literal">AggregateResourceBundleLocator</code>.</p><div class="example"><a id="example-using-aggregate-resource-bundle-locator"/><p class="title"><strong>Example 4.5. Using <code class="literal">AggregateResourceBundleLocator</code></strong></p><div class="example-contents"><pre><code class="language-java">Validator validator = Validation.byDefaultProvider()
		.configure()
		.messageInterpolator(
				new ResourceBundleMessageInterpolator(
						new AggregateResourceBundleLocator(
								Arrays.asList(
										"MyMessages",
										"MyOtherMessages"
								)
						)
				)
		)
		.buildValidatorFactory()
		.getValidator();</code></pre></div></div><br class="example-break"/><p>Note that the bundles are processed in the order as passed to the constructor. That means if several
bundles contain an entry for a given message key, the value will be taken from the first bundle in
the list containing the key.</p></div></div></div><div class="chapter" title="Chapter 5. Grouping constraints"><div class="titlepage"><div><div><h2 class="title"><a id="chapter-groups"/>Chapter 5. Grouping constraints</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#_requesting_groups">5.1. Requesting groups</a></span></dt><dt><span class="section"><a href="#section-defining-group-sequences">5.2. Defining group sequences</a></span></dt><dt><span class="section"><a href="#section-default-group-class">5.3. Redefining the default group sequence</a></span></dt><dd><dl><dt><span class="section"><a href="#__literal_groupsequence_literal">5.3.1. <code class="literal">@GroupSequence</code></a></span></dt><dt><span class="section"><a href="#__literal_groupsequenceprovider_literal">5.3.2. <code class="literal">@GroupSequenceProvider</code></a></span></dt></dl></dd><dt><span class="section"><a href="#section-group-conversion">5.4. Group conversion</a></span></dt></dl></div><p>All validation methods on <code class="literal">Validator</code> and <code class="literal">ExecutableValidator</code> discussed in earlier chapters also take
a var-arg argument groups. So far we have been ignoring this parameter, but it is time to have a
closer look.</p><div class="section" title="5.1. Requesting groups"><div class="titlepage"><div><div><h2 class="title"><a id="_requesting_groups"/>5.1. Requesting groups</h2></div></div></div><p>Groups allow you to restrict the set of constraints applied during validation. One use case for
validation groups are UI wizards where in each step only a specified subset of constraints should
get validated. The groups targeted are passed as var-arg parameters to the appropriate validate
method.</p><p>Let’s have a look at an example. The class <code class="literal">Person</code> in <a class="xref" href="#example-person" title="Example 5.1. Example class Person">Example 5.1, “Example class <code class="literal">Person</code>”</a> has a <code class="literal">@NotNull</code>
constraint on <code class="literal">name</code>. Since no group is specified for this annotation the default group
<code class="literal">javax.validation.groups.Default</code> is assumed.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>When more than one group is requested, the order in which the groups are evaluated is not
deterministic. If no group is specified the default group <code class="literal">javax.validation.groups.Default</code> is
assumed.</p></div><div class="example"><a id="example-person"/><p class="title"><strong>Example 5.1. Example class <code class="literal">Person</code></strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter05;

public class Person {

	@NotNull
	private String name;

	public Person(String name) {
		this.name = name;
	}

	// getters and setters ...
}</code></pre></div></div><br class="example-break"/><p>The class <code class="literal">Driver</code> in <a class="xref" href="#example-driver" title="Example 5.2. Driver">Example 5.2, “Driver”</a> extends <code class="literal">Person</code> and adds the properties <code class="literal">age</code> and
<code class="literal">hasDrivingLicense</code>. Drivers must be at least 18 years old (<code class="literal">@Min(18)</code>) and have a driving license
(<code class="literal">@AssertTrue</code>). Both constraints defined on these properties belong to the group <code class="literal">DriverChecks</code> which
is just a simple tagging interface.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>Using interfaces makes the usage of groups type-safe and allows for easy refactoring. It also means
that groups can inherit from each other via class inheritance.</p></div><div class="example"><a id="example-driver"/><p class="title"><strong>Example 5.2. Driver</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter05;

public class Driver extends Person {

	@Min(
			value = 18,
			message = "You have to be 18 to drive a car",
			groups = DriverChecks.class
	)
	public int age;

	@AssertTrue(
			message = "You first have to pass the driving test",
			groups = DriverChecks.class
	)
	public boolean hasDrivingLicense;

	public Driver(String name) {
		super( name );
	}

	public void passedDrivingTest(boolean b) {
		hasDrivingLicense = b;
	}

	public int getAge() {
		return age;
	}

	public void setAge(int age) {
		this.age = age;
	}
}</code></pre><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter05;

public interface DriverChecks {
}</code></pre></div></div><br class="example-break"/><p>Finally the class <code class="literal">Car</code> (<a class="xref" href="#example-car" title="Example 5.3. Car">Example 5.3, “Car”</a>) has some constraints which are part of the default group as
well as <code class="literal">@AssertTrue</code> in the group <code class="literal">CarChecks</code> on the property <code class="literal">passedVehicleInspection</code> which indicates
whether a car passed the road worthy tests.</p><div class="example"><a id="example-car"/><p class="title"><strong>Example 5.3. Car</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter05;

public class Car {
	@NotNull
	private String manufacturer;

	@NotNull
	@Size(min = 2, max = 14)
	private String licensePlate;

	@Min(2)
	private int seatCount;

	@AssertTrue(
			message = "The car has to pass the vehicle inspection first",
			groups = CarChecks.class
	)
	private boolean passedVehicleInspection;

	@Valid
	private Driver driver;

	public Car(String manufacturer, String licencePlate, int seatCount) {
		this.manufacturer = manufacturer;
		this.licensePlate = licencePlate;
		this.seatCount = seatCount;
	}

	// getters and setters ...
}</code></pre><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter05;

public interface CarChecks {
}</code></pre></div></div><br class="example-break"/><p>Overall three different groups are used in the example:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">The constraints on <code class="literal">Person.name</code>, <code class="literal">Car.manufacturer</code>, <code class="literal">Car.licensePlate</code> and <code class="literal">Car.seatCount</code>
all belong to the <code class="literal">Default</code> group</li><li class="listitem">The constraints on <code class="literal">Driver.age</code> and <code class="literal">Driver.hasDrivingLicense</code> belong to <code class="literal">DriverChecks</code></li><li class="listitem">The constraint on <code class="literal">Car.passedVehicleInspection</code> belongs to the group <code class="literal">CarChecks</code></li></ul></div><p><a class="xref" href="#example-drive-away" title="Example 5.4. Using validation groups">Example 5.4, “Using validation groups”</a> shows how passing different group combinations to the <code class="literal">Validator#validate()</code>
method results in different validation results.</p><div class="example"><a id="example-drive-away"/><p class="title"><strong>Example 5.4. Using validation groups</strong></p><div class="example-contents"><pre><code class="language-java">// create a car and check that everything is ok with it.
Car car = new Car( "Morris", "DD-AB-123", 2 );
Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );
assertEquals( 0, constraintViolations.size() );

// but has it passed the vehicle inspection?
constraintViolations = validator.validate( car, CarChecks.class );
assertEquals( 1, constraintViolations.size() );
assertEquals(
		"The car has to pass the vehicle inspection first",
		constraintViolations.iterator().next().getMessage()
);

// let's go to the vehicle inspection
car.setPassedVehicleInspection( true );
assertEquals( 0, validator.validate( car ).size() );

// now let's add a driver. He is 18, but has not passed the driving test yet
Driver john = new Driver( "John Doe" );
john.setAge( 18 );
car.setDriver( john );
constraintViolations = validator.validate( car, DriverChecks.class );
assertEquals( 1, constraintViolations.size() );
assertEquals(
		"You first have to pass the driving test",
		constraintViolations.iterator().next().getMessage()
);

// ok, John passes the test
john.passedDrivingTest( true );
assertEquals( 0, validator.validate( car, DriverChecks.class ).size() );

// just checking that everything is in order now
assertEquals(
		0, validator.validate(
		car,
		Default.class,
		CarChecks.class,
		DriverChecks.class
).size()
);</code></pre></div></div><br class="example-break"/><p>The first <code class="literal">validate()</code> call in <a class="xref" href="#example-drive-away" title="Example 5.4. Using validation groups">Example 5.4, “Using validation groups”</a> is done using no explicit group. There are no
validation errors, even though the property <code class="literal">passedVehicleInspection</code> is per default <code class="literal">false</code>. However,
the constraint defined on this property does not belong to the default group.</p><p>The next validation using the <code class="literal">CarChecks</code> group fails until the car passes the vehicle inspection.
Adding a driver to the car and validating against <code class="literal">DriverChecks</code> again yields one constraint violation
due to the fact that the driver has not yet passed the driving test. Only after setting
<code class="literal">passedDrivingTest</code> to <code class="literal">true</code> the validation against <code class="literal">DriverChecks</code> passes.</p><p>The last <code class="literal">validate()</code> call finally shows that all constraints are passing by validating against all
defined groups.</p></div><div class="section" title="5.2. Defining group sequences"><div class="titlepage"><div><div><h2 class="title"><a id="section-defining-group-sequences"/>5.2. Defining group sequences</h2></div></div></div><p>By default, constraints are evaluated in no particular order, regardless of which groups they belong
to. In some situations, however, it is useful to control the order constraints are evaluated.</p><p>In the example from <a class="xref" href="#example-drive-away" title="Example 5.4. Using validation groups">Example 5.4, “Using validation groups”</a> it could for instance be required that first all default
car constraints are passing before checking the road worthiness of the car. Finally, before driving
away, the actual driver constraints should be checked.</p><p>In order to implement such a validation order you just need to define an interface and annotate it
with <code class="literal">@GroupSequence</code>, defining the order in which the groups have to be validated (see
<a class="xref" href="#example-defining-group-sequence" title="Example 5.5. Defining a group sequence">Example 5.5, “Defining a group sequence”</a>). If at least one constraint fails in a sequenced group none of the
constraints of the following groups in the sequence get validated.</p><div class="example"><a id="example-defining-group-sequence"/><p class="title"><strong>Example 5.5. Defining a group sequence</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter05;

@GroupSequence({ Default.class, CarChecks.class, DriverChecks.class })
public interface OrderedChecks {
}</code></pre></div></div><br class="example-break"/><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2><p>Groups defining a sequence and groups composing a sequence must not be involved in a cyclic
dependency either directly or indirectly, either through cascaded sequence definition or group
inheritance. If a group containing such a circularity is evaluated, a <code class="literal">GroupDefinitionException</code> is
raised.</p></div><p>You then can use the new sequence as shown in in <a class="xref" href="#example-group-sequence" title="Example 5.6. Using a group sequence">Example 5.6, “Using a group sequence”</a>.</p><div class="example"><a id="example-group-sequence"/><p class="title"><strong>Example 5.6. Using a group sequence</strong></p><div class="example-contents"><pre><code class="language-java">Car car = new Car( "Morris", "DD-AB-123", 2 );
car.setPassedVehicleInspection( true );

Driver john = new Driver( "John Doe" );
john.setAge( 18 );
john.passedDrivingTest( true );
car.setDriver( john );

assertEquals( 0, validator.validate( car, OrderedChecks.class ).size() );</code></pre></div></div><br class="example-break"/></div><div class="section" title="5.3. Redefining the default group sequence"><div class="titlepage"><div><div><h2 class="title"><a id="section-default-group-class"/>5.3. Redefining the default group sequence</h2></div></div></div><div class="section" title="5.3.1. @GroupSequence"><div class="titlepage"><div><div><h3 class="title"><a id="__literal_groupsequence_literal"/>5.3.1. <code class="literal">@GroupSequence</code></h3></div></div></div><p>Besides defining group sequences, the <code class="literal">@GroupSequence</code> annotation also allows to redefine the default
group for a given class. To do so, just add the <code class="literal">@GroupSequence</code> annotation to the class and specify
the sequence of groups which substitute Default for this class within the annotation.</p><p><a class="xref" href="#example-rental-car" title="Example 5.7. Class RentalCar with redefined default group">Example 5.7, “Class <code class="literal">RentalCar</code> with redefined default group”</a> introduces a new class <code class="literal">RentalCar</code> with a redefined default group.</p><div class="example"><a id="example-rental-car"/><p class="title"><strong>Example 5.7. Class <code class="literal">RentalCar</code> with redefined default group</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter05;

@GroupSequence({ RentalChecks.class, CarChecks.class, RentalCar.class })
public class RentalCar extends Car {
	@AssertFalse(message = "The car is currently rented out", groups = RentalChecks.class)
	private boolean rented;

	public RentalCar(String manufacturer, String licencePlate, int seatCount) {
		super( manufacturer, licencePlate, seatCount );
	}

	public boolean isRented() {
		return rented;
	}

	public void setRented(boolean rented) {
		this.rented = rented;
	}
}</code></pre><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter05;

public interface RentalChecks {
}</code></pre></div></div><br class="example-break"/><p>With this definition you can evaluate the constraints belonging to <code class="literal">RentalChecks</code>, <code class="literal">CarChecks</code> and
<code class="literal">RentalCar</code> by just requesting the <code class="literal">Default</code> group as seen in <a class="xref" href="#example-testCarIsRented" title="Example 5.8. Validating an object with redefined default group">Example 5.8, “Validating an object with redefined default group”</a>.</p><div class="example"><a id="example-testCarIsRented"/><p class="title"><strong>Example 5.8. Validating an object with redefined default group</strong></p><div class="example-contents"><pre><code class="language-java">RentalCar rentalCar = new RentalCar( "Morris", "DD-AB-123", 2 );
rentalCar.setPassedVehicleInspection( true );
rentalCar.setRented( true );

Set&lt;ConstraintViolation&lt;RentalCar&gt;&gt; constraintViolations = validator.validate( rentalCar );

assertEquals( 1, constraintViolations.size() );
assertEquals(
		"Wrong message",
		"The car is currently rented out",
		constraintViolations.iterator().next().getMessage()
);

rentalCar.setRented( false );
constraintViolations = validator.validate( rentalCar );

assertEquals( 0, constraintViolations.size() );</code></pre></div></div><br class="example-break"/><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>Since there must no cyclic dependency in the group and group sequence definitions one cannot just
add <code class="literal">Default</code> to the sequence redefining <code class="literal">Default</code> for a class. Instead the class itself has to be
added!</p></div><p>The <code class="literal">Default</code> group sequence overriding is local to the class it is defined on and is not propagated
to associated objects. For the example this means that adding <code class="literal">DriverChecks</code> to the default group
sequence of <code class="literal">RentalCar</code> would not have any effects. Only the group <code class="literal">Default</code> will be propagated to the
driver association.</p><p>Note that you can control the propagated group(s) by declaring a group conversion rule (see
<a class="xref" href="#section-group-conversion" title="5.4. Group conversion">Section 5.4, “Group conversion”</a>).</p></div><div class="section" title="5.3.2. @GroupSequenceProvider"><div class="titlepage"><div><div><h3 class="title"><a id="__literal_groupsequenceprovider_literal"/>5.3.2. <code class="literal">@GroupSequenceProvider</code></h3></div></div></div><p>In addition to statically redefining default group sequences via <code class="literal">@GroupSequence</code>, Hibernate Validator
also provides an SPI for the dynamic redefinition of default group sequences depending on the object
state.</p><p>For that purpose you need to implement the interface <code class="literal">DefaultGroupSequenceProvider</code> and register this
implementation with the target class via the <code class="literal">@GroupSequenceProvider</code> annotation. In the rental car
scenario you could for instance dynamically add the <code class="literal">CarChecks</code> as seen in
<a class="xref" href="#example-implementing-using-default-group-sequence-provider" title="Example 5.9. Implementing and using a default group sequence provider">Example 5.9, “Implementing and using a default group sequence provider”</a>.</p><div class="example"><a id="example-implementing-using-default-group-sequence-provider"/><p class="title"><strong>Example 5.9. Implementing and using a default group sequence provider</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter05.groupsequenceprovider;

public class RentalCarGroupSequenceProvider
		implements DefaultGroupSequenceProvider&lt;RentalCar&gt; {

	@Override
	public List&lt;Class&lt;?&gt;&gt; getValidationGroups(RentalCar car) {
		List&lt;Class&lt;?&gt;&gt; defaultGroupSequence = new ArrayList&lt;Class&lt;?&gt;&gt;();
		defaultGroupSequence.add( RentalCar.class );

		if ( car != null &amp;&amp; !car.isRented() ) {
			defaultGroupSequence.add( CarChecks.class );
		}

		return defaultGroupSequence;
	}
}</code></pre><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter05.groupsequenceprovider;

@GroupSequenceProvider(RentalCarGroupSequenceProvider.class)
public class RentalCar extends Car {

	@AssertFalse(message = "The car is currently rented out", groups = RentalChecks.class)
	private boolean rented;

	public RentalCar(String manufacturer, String licencePlate, int seatCount) {
		super( manufacturer, licencePlate, seatCount );
	}

	public boolean isRented() {
		return rented;
	}

	public void setRented(boolean rented) {
		this.rented = rented;
	}
}</code></pre></div></div><br class="example-break"/></div></div><div class="section" title="5.4. Group conversion"><div class="titlepage"><div><div><h2 class="title"><a id="section-group-conversion"/>5.4. Group conversion</h2></div></div></div><p>What if you wanted to validate the car related checks together with the driver checks? Of course you
could pass the required groups to the validate call explicitly, but what if you wanted to make these
validations occur as part of the <code class="literal">Default</code> group validation? Here <code class="literal">@ConvertGroup</code> comes into play which
allows you during cascaded validation to use a different group than the originally requested one.</p><p>Let’s have a look at <a class="xref" href="#example-group-conversion-dedault-to-driver-checks" title="Example 5.10. @ConvertGroup usage">Example 5.10, “<code class="literal">@ConvertGroup</code> usage”</a>. Here <code class="literal">@GroupSequence({
CarChecks.class, Car.class })</code> is used to combine the car related constraints under the <code class="literal">Default</code> group
(see <a class="xref" href="#section-default-group-class" title="5.3. Redefining the default group sequence">Section 5.3, “Redefining the default group sequence”</a>). There is also a <code class="literal">@ConvertGroup(from = Default.class, to =
DriverChecks.class)</code> which ensures the <code class="literal">Default</code> group gets converted to the <code class="literal">DriverChecks</code> group during
cascaded validation of the driver association.</p><div class="example"><a id="example-group-conversion-dedault-to-driver-checks"/><p class="title"><strong>Example 5.10. <code class="literal">@ConvertGroup</code> usage</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter05.groupconversion;

public class Driver {

	@NotNull
	private String name;

	@Min(
			value = 18,
			message = "You have to be 18 to drive a car",
			groups = DriverChecks.class
	)
	public int age;

	@AssertTrue(
			message = "You first have to pass the driving test",
			groups = DriverChecks.class
	)
	public boolean hasDrivingLicense;

	public Driver(String name) {
		this.name = name;
	}

	public void passedDrivingTest(boolean b) {
		hasDrivingLicense = b;
	}

	// getters and setters ...
}</code></pre><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter05.groupconversion;

@GroupSequence({ CarChecks.class, Car.class })
public class Car {

	@NotNull
	private String manufacturer;

	@NotNull
	@Size(min = 2, max = 14)
	private String licensePlate;

	@Min(2)
	private int seatCount;

	@AssertTrue(
			message = "The car has to pass the vehicle inspection first",
			groups = CarChecks.class
	)
	private boolean passedVehicleInspection;

	@Valid
	@ConvertGroup(from = Default.class, to = DriverChecks.class)
	private Driver driver;

	public Car(String manufacturer, String licencePlate, int seatCount) {
		this.manufacturer = manufacturer;
		this.licensePlate = licencePlate;
		this.seatCount = seatCount;
	}

	// getters and setters ...
}</code></pre></div></div><br class="example-break"/><p>As a result the validation in <a class="xref" href="#example-group-conversion-test" title="Example 5.11. Test case for @ConvertGroup">Example 5.11, “Test case for <code class="literal">@ConvertGroup</code>”</a> succeeds, even though the constraint
on <code class="literal">hasDrivingLicense</code> belongs to the <code class="literal">DriverChecks</code> group and only the <code class="literal">Default</code> group is requested in
the <code class="literal">validate()</code> call.</p><div class="example"><a id="example-group-conversion-test"/><p class="title"><strong>Example 5.11. Test case for <code class="literal">@ConvertGroup</code></strong></p><div class="example-contents"><pre><code class="language-java">// create a car and validate. The Driver is still null and does not get validated
Car car = new Car( "VW", "USD-123", 4 );
car.setPassedVehicleInspection( true );
Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );
assertEquals( 0, constraintViolations.size() );

// create a driver who has not passed the driving test
Driver john = new Driver( "John Doe" );
john.setAge( 18 );

// now let's add a driver to the car
car.setDriver( john );
constraintViolations = validator.validate( car );
assertEquals( 1, constraintViolations.size() );
assertEquals(
		"The driver constraint should also be validated as part of the default group",
		constraintViolations.iterator().next().getMessage(),
		"You first have to pass the driving test"
);</code></pre></div></div><br class="example-break"/><p>You can define group conversions wherever <code class="literal">@Valid</code> can be used, namely associations as well as method
and constructor parameters and return values. Multiple conversions can be specified using
<code class="literal">@ConvertGroup.List</code>.</p><p>However, the following restrictions apply:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><code class="literal">@ConvertGroup</code> must only be used in combination with <code class="literal">@Valid</code>. If used without, a
<code class="literal">ConstraintDeclarationException</code> is thrown.</li><li class="listitem">It is not legal to have multiple conversion rules on the same element with the same from value.
In this case, a <code class="literal">ConstraintDeclarationException</code> is raised.</li><li class="listitem">The from attribute must not refer to a group sequence. A <code class="literal">ConstraintDeclarationException</code> is
raised in this situation.</li></ul></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>Rules are not executed recursively. The first matching conversion rule is used and subsequent rules
are ignored. For example if a set of <code class="literal">@ConvertGroup</code> declarations chains group <code class="literal">A</code> to <code class="literal">B</code> and
<code class="literal">B</code> to <code class="literal">C</code>, the group <code class="literal">A</code> will be converted to <code class="literal">B</code> and not to <code class="literal">C</code>.</p></div></div></div><div class="chapter" title="Chapter 6. Creating custom constraints"><div class="titlepage"><div><div><h2 class="title"><a id="validator-customconstraints"/>Chapter 6. Creating custom constraints</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#validator-customconstraints-simple">6.1. Creating a simple constraint</a></span></dt><dd><dl><dt><span class="section"><a href="#validator-customconstraints-constraintannotation">6.1.1. The constraint annotation</a></span></dt><dt><span class="section"><a href="#section-constraint-validator">6.1.2. The constraint validator</a></span></dt><dt><span class="section"><a href="#validator-customconstraints-errormessage">6.1.3. The error message</a></span></dt><dt><span class="section"><a href="#validator-customconstraints-using">6.1.4. Using the constraint</a></span></dt></dl></dd><dt><span class="section"><a href="#section-class-level-constraints">6.2. Class-level constraints</a></span></dt><dd><dl><dt><span class="section"><a href="#section-custom-property-paths">6.2.1. Custom property paths</a></span></dt></dl></dd><dt><span class="section"><a href="#section-cross-parameter-constraints">6.3. Cross-parameter constraints</a></span></dt><dt><span class="section"><a href="#section-constraint-composition">6.4. Constraint composition</a></span></dt></dl></div><p>The Bean Validation API defines a whole set of standard constraint annotations such as <code class="literal">@NotNull</code>,
<code class="literal">@Size</code> etc. In cases where these buit-in constraints are not sufficient, you cean easily create
custom constraints tailored to your specific validation requirements.</p><div class="section" title="6.1. Creating a simple constraint"><div class="titlepage"><div><div><h2 class="title"><a id="validator-customconstraints-simple"/>6.1. Creating a simple constraint</h2></div></div></div><p>To create a custom constraint, the following three steps are required:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Create a constraint annotation</li><li class="listitem">Implement a validator</li><li class="listitem">Define a default error message</li></ul></div><div class="section" title="6.1.1. The constraint annotation"><div class="titlepage"><div><div><h3 class="title"><a id="validator-customconstraints-constraintannotation"/>6.1.1. The constraint annotation</h3></div></div></div><p>This section shows how to write a constraint annotation which can be used to ensure that a given
string is either completely upper case or lower case. Later on this constraint will be applied to
the <code class="literal">licensePlate</code> field of the <code class="literal">Car</code> class from <a class="xref" href="#validator-gettingstarted" title="Chapter 1. Getting started">Chapter 1, <em>Getting started</em></a> to ensure, that
the field is always an upper-case string.</p><p>The first thing needed is a way to express the two case modes. While you could use <code class="literal">String</code> constants,
a better approach is using a Java 5 enum for that purpose:</p><div class="example"><a id="d0e3541"/><p class="title"><strong>Example 6.1. Enum <code class="literal">CaseMode</code> to express upper vs. lower case</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter06;

public enum CaseMode {
	UPPER,
	LOWER;
}</code></pre></div></div><br class="example-break"/><p>The next step is to define the actual constraint annotation. If you’ve never designed an annotation
before, this may look a bit scary, but actually it’s not that hard:</p><div class="example"><a id="example-defining-custom-constraint"/><p class="title"><strong>Example 6.2. Defining the <code class="literal">@CheckCase</code> constraint annotation</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter06;

@Target({ FIELD, METHOD, PARAMETER, ANNOTATION_TYPE })
@Retention(RUNTIME)
@Constraint(validatedBy = CheckCaseValidator.class)
@Documented
public @interface CheckCase {

	String message() default "{org.hibernate.validator.referenceguide.chapter06.CheckCase." +
			"message}";

	Class&lt;?&gt;[] groups() default { };

	Class&lt;? extends Payload&gt;[] payload() default { };

	CaseMode value();

	@Target({ FIELD, METHOD, PARAMETER, ANNOTATION_TYPE })
	@Retention(RUNTIME)
	@Documented
	@interface List {
		CheckCase[] value();
	}
}</code></pre></div></div><br class="example-break"/><p>An annotation type is defined using the <code class="literal">@interface</code> keyword. All attributes of an annotation type are
declared in a method-like manner. The specification of the Bean Validation API demands, that any
constraint annotation defines</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">an attribute <code class="literal">message</code> that returns the default key for creating error messages in case the
constraint is violated</li><li class="listitem">an attribute <code class="literal">groups</code> that allows the specification of validation groups, to which this constraint
belongs (see <a class="xref" href="#chapter-groups" title="Chapter 5. Grouping constraints">Chapter 5, <em>Grouping constraints</em></a>). This must default to an empty array of type Class&lt;?&gt;.</li><li class="listitem"><p class="simpara">an attribute <code class="literal">payload</code> that can be used by clients of the Bean Validation API to assign custom
payload objects to a constraint. This attribute is not used by the API itself. An example for a
custom payload could be the definition of a severity:</p><div class="informalexample"><pre><code class="language-java">public class Severity {
	public interface Info extends Payload {
	}

	public interface Error extends Payload {
	}
}

public class ContactDetails {
	@NotNull(message = "Name is mandatory", payload = Severity.Error.class)
	private String name;

	@NotNull(message = "Phone number not specified, but not mandatory",
			payload = Severity.Info.class)
	private String phoneNumber;

	// ...
}</code></pre></div><p class="simpara">Now a client can after the validation of a <code class="literal">ContactDetails</code> instance access the severity of a
constraint using <code class="literal">ConstraintViolation.getConstraintDescriptor().getPayload()</code> and adjust its behavior
depending on the severity.</p></li></ul></div><p>Besides these three mandatory attributes there is another one, <code class="literal">value</code>, allowing for the required case
mode to be specified. The name <code class="literal">value</code> is a special one, which can be omitted when using the
annotation, if it is the only attribute specified, as e.g. in <code class="literal">@CheckCase(CaseMode.UPPER)</code>.</p><p>In addition, the constraint annotation is decorated with a couple of meta annotations:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><p class="simpara"><code class="literal">@Target({ FIELD, METHOD, PARAMETER, ANNOTATION_TYPE})</code>: Defines the supported target element types
for the constraint. <code class="literal">@CheckCase</code> may be used on fields (element type <code class="literal">FIELD</code>), JavaBeans properties as
well as method return values (<code class="literal">METHOD</code>) and method/constructor parameters (<code class="literal">PARAMETER</code>). The element
type <code class="literal">ANNOTATION_TYPE</code> allows for the creation of composed constraints
(see <a class="xref" href="#section-constraint-composition" title="6.4. Constraint composition">Section 6.4, “Constraint composition”</a>) based on <code class="literal">@CheckCase</code>.</p><p class="simpara">When creating a class-level constraint (see <a class="xref" href="#validator-usingvalidator-classlevel" title="2.1.4. Class-level constraints">Section 2.1.4, “Class-level constraints”</a>), the element
type <code class="literal">TYPE</code> would have to be used. Constraints targeting the return value of a constructor need to
support the element type <code class="literal">CONSTRUCTOR</code>. Cross-parameter constraints (see
<a class="xref" href="#section-cross-parameter-constraints" title="6.3. Cross-parameter constraints">Section 6.3, “Cross-parameter constraints”</a>) which are used to validate all the parameters of a method
or constructor together, must support <code class="literal">METHOD</code> or <code class="literal">CONSTRUCTOR</code>, respectively.</p></li><li class="listitem"><code class="literal">@Retention(RUNTIME)</code>: Specifies, that annotations of this type will be available at runtime by the
means of reflection</li><li class="listitem"><code class="literal">@Constraint(validatedBy = CheckCaseValidator.class)</code>: Marks the annotation type as constraint
annotation and specifies the validator to be used to validate elements annotated with <code class="literal">@CheckCase</code>.
If a constraint may be used on several data types, several validators may be specified, one for
each data type.</li><li class="listitem"><code class="literal">@Documented</code>: Says, that the use of <code class="literal">@CheckCase</code> will be contained in the JavaDoc of elements
annotated with it</li></ul></div><p>Finally, there is an inner annotation type named <code class="literal">List</code>. This annotation allows to specify several
<code class="literal">@CheckCase</code> annotations on the same element, e.g. with different validation groups and messages.
While also another name could be used, the Bean Validation specification recommends to use the name
<code class="literal">List</code> and make the annotation an inner annotation of the corresponding constraint type.</p></div><div class="section" title="6.1.2. The constraint validator"><div class="titlepage"><div><div><h3 class="title"><a id="section-constraint-validator"/>6.1.2. The constraint validator</h3></div></div></div><p>Having defined the annotation, you need to create a constraint validator, which is able to validate
elements with a <code class="literal">@CheckCase</code> annotation. To do so, implement the interface <code class="literal">ConstraintValidator</code> as
shown below:</p><div class="example"><a id="example-constraint-validator"/><p class="title"><strong>Example 6.3. Implementing a constraint validator for the constraint <code class="literal">@CheckCase</code></strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter06;

public class CheckCaseValidator implements ConstraintValidator&lt;CheckCase, String&gt; {

	private CaseMode caseMode;

	@Override
	public void initialize(CheckCase constraintAnnotation) {
		this.caseMode = constraintAnnotation.value();
	}

	@Override
	public boolean isValid(String object, ConstraintValidatorContext constraintContext) {
		if ( object == null ) {
			return true;
		}

		if ( caseMode == CaseMode.UPPER ) {
			return object.equals( object.toUpperCase() );
		}
		else {
			return object.equals( object.toLowerCase() );
		}
	}
}</code></pre></div></div><br class="example-break"/><p>The <code class="literal">ConstraintValidator</code> interface defines two type parameters which are set in the implementation.
The first one specifies the annotation type to be validated (<code class="literal">CheckCase</code>), the second one the type of
elements, which the validator can handle (<code class="literal">String</code>). In case a constraint supports several data types,
a <code class="literal">ConstraintValidator</code> for each allowed type has to be implemented and registered at the constraint
annotation as shown above.</p><p>The implementation of the validator is straightforward. The <code class="literal">initialize()</code> method gives you access to
the attribute values of the validated constraint and allows you to store them in a field of the
validator as shown in the example.</p><p>The <code class="literal">isValid()</code> method contains the actual validation logic. For <code class="literal">@CheckCase</code> this is the check whether
a given string is either completely lower case or upper case, depending on the case mode retrieved
in <code class="literal">initialize()</code>. Note that the Bean Validation specification recommends to consider null values as
being valid. If <code class="literal">null</code> is not a valid value for an element, it should be annotated with <code class="literal">@NotNull</code>
explicitly.</p><div class="section" title="6.1.2.1. The ConstraintValidatorContext"><div class="titlepage"><div><div><h4 class="title"><a id="_the_literal_constraintvalidatorcontext_literal"/>6.1.2.1. The <code class="literal">ConstraintValidatorContext</code></h4></div></div></div><p><a class="xref" href="#example-constraint-validator" title="Example 6.3. Implementing a constraint validator for the constraint @CheckCase">Example 6.3, “Implementing a constraint validator for the constraint <code class="literal">@CheckCase</code>”</a>
relies on the default error message generation by just returning <code class="literal">true</code> or <code class="literal">false</code> from the <code class="literal">isValid()</code>
method. Using the passed <code class="literal">ConstraintValidatorContext</code> object it is possible to either add additional
error messages or completely disable the default error message generation and solely define custom
error messages. The <code class="literal">ConstraintValidatorContext</code> API is modeled as fluent interface and is best
demonstrated with an example:</p><div class="example"><a id="example-constraint-validator-context"/><p class="title"><strong>Example 6.4. Using <code class="literal">ConstraintValidatorContext</code> to define custom error messages</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter06.constraintvalidatorcontext;

public class CheckCaseValidator implements ConstraintValidator&lt;CheckCase, String&gt; {

	private CaseMode caseMode;

	@Override
	public void initialize(CheckCase constraintAnnotation) {
		this.caseMode = constraintAnnotation.value();
	}

	@Override
	public boolean isValid(String object, ConstraintValidatorContext constraintContext) {
		if ( object == null ) {
			return true;
		}

		boolean isValid;
		if ( caseMode == CaseMode.UPPER ) {
			isValid = object.equals( object.toUpperCase() );
		}
		else {
			isValid = object.equals( object.toLowerCase() );
		}

		if ( !isValid ) {
			constraintContext.disableDefaultConstraintViolation();
			constraintContext.buildConstraintViolationWithTemplate(
					"{org.hibernate.validator.referenceguide.chapter03." +
					"constraintvalidatorcontext.CheckCase.message}"
			)
			.addConstraintViolation();
		}

		return isValid;
	}
}</code></pre></div></div><br class="example-break"/><p><a class="xref" href="#example-constraint-validator-context" title="Example 6.4. Using ConstraintValidatorContext to define custom error messages">Example 6.4, “Using <code class="literal">ConstraintValidatorContext</code> to define custom error messages”</a>
shows how you can disable the default error message generation and add a custom error message using
a specified message template. In this example the use of the <code class="literal">ConstraintValidatorContext</code> results in
the same error message as the default error message generation.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>It is important to add each configured constraint violation by calling <code class="literal">addConstraintViolation()</code>.
Only after that the new constraint violation will be created.</p></div><p>Refer to <a class="xref" href="#section-custom-property-paths" title="6.2.1. Custom property paths">Section 6.2.1, “Custom property paths”</a> to learn how to use the <code class="literal">ConstraintValidatorContext</code> API to
control the property path of constraint violations for class-level constraints.</p></div></div><div class="section" title="6.1.3. The error message"><div class="titlepage"><div><div><h3 class="title"><a id="validator-customconstraints-errormessage"/>6.1.3. The error message</h3></div></div></div><p>The last missing building block is an error message which should be used in case a <code class="literal">@CheckCase</code>
constraint is violated. To define this, create a file <span class="emphasis"><em>ValidationMessages.properties</em></span> with the
following contents (see also <a class="xref" href="#section-message-interpolation" title="4.1. Default message interpolation">Section 4.1, “Default message interpolation”</a>):</p><div class="example"><a id="d0e3802"/><p class="title"><strong>Example 6.5. Defining a custom error message for the <code class="literal">CheckCase</code> constraint</strong></p><div class="example-contents"><pre class="screen">org.hibernate.validator.referenceguide.chapter06.CheckCase.message=Case mode must be {value}.</pre></div></div><br class="example-break"/><p>If a validation error occurs, the validation runtime will use the default value, that you specified
for the message attribute of the <code class="literal">@CheckCase</code> annotation to look up the error message in this resource
bundle.</p></div><div class="section" title="6.1.4. Using the constraint"><div class="titlepage"><div><div><h3 class="title"><a id="validator-customconstraints-using"/>6.1.4. Using the constraint</h3></div></div></div><p>You can now use the constraint in the <code class="literal">Car</code> class from the <a class="xref" href="#validator-gettingstarted" title="Chapter 1. Getting started">Chapter 1, <em>Getting started</em></a> chapter to
specify that the <code class="literal">licensePlate</code> field should only contain upper-case strings:</p><div class="example"><a id="example-car-with-checkcase"/><p class="title"><strong>Example 6.6. Applying the <code class="literal">@CheckCase</code> constraint</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter06;

public class Car {

	@NotNull
	private String manufacturer;

	@NotNull
	@Size(min = 2, max = 14)
	@CheckCase(CaseMode.UPPER)
	private String licensePlate;

	@Min(2)
	private int seatCount;

	public Car ( String manufacturer, String licencePlate, int seatCount ) {
		this.manufacturer = manufacturer;
		this.licensePlate = licencePlate;
		this.seatCount = seatCount;
	}

	//getters and setters ...
}</code></pre></div></div><br class="example-break"/><p>Finally, <a class="xref" href="#example-using-checkcase" title="Example 6.7. Validating objects with the @CheckCase constraint">Example 6.7, “Validating objects with the <code class="literal">@CheckCase</code> constraint”</a> demonstrates how validating a <code class="literal">Car</code> instance with an invalid
license plate causes the <code class="literal">@CheckCase</code> constraint to be violated.</p><div class="example"><a id="example-using-checkcase"/><p class="title"><strong>Example 6.7. Validating objects with the <code class="literal">@CheckCase</code> constraint</strong></p><div class="example-contents"><pre><code class="language-java">//invalid license plate
Car car = new Car( "Morris", "dd-ab-123", 4 );
Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations =
		validator.validate( car );
assertEquals( 1, constraintViolations.size() );
assertEquals(
		"Case mode must be UPPER.",
		constraintViolations.iterator().next().getMessage()
);

//valid license plate
car = new Car( "Morris", "DD-AB-123", 4 );

constraintViolations = validator.validate( car );

assertEquals( 0, constraintViolations.size() );</code></pre></div></div><br class="example-break"/></div></div><div class="section" title="6.2. Class-level constraints"><div class="titlepage"><div><div><h2 class="title"><a id="section-class-level-constraints"/>6.2. Class-level constraints</h2></div></div></div><p>As discussed earlier, constraints can also be applied on the class level to validate the state of an
entire object. Class-level constraints are defined in the same was as are property constraints.
<a class="xref" href="#example-implementing-classlevel-constraint" title="Example 6.8. Implementing a class-level constraint">Example 6.8, “Implementing a class-level constraint”</a> shows constraint annotation and validator of the
<code class="literal">@ValidPassengerCount</code> constraint you already saw in use in <a class="xref" href="#example-class-level" title="Example 2.7. Class-level constraint">Example 2.7, “Class-level constraint”</a>.</p><div class="example"><a id="example-implementing-classlevel-constraint"/><p class="title"><strong>Example 6.8. Implementing a class-level constraint</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter06.classlevel;

@Target({ TYPE, ANNOTATION_TYPE })
@Retention(RUNTIME)
@Constraint(validatedBy = { ValidPassengerCountValidator.class })
@Documented
public @interface ValidPassengerCount {

	String message() default "{org.hibernate.validator.referenceguide.chapter06.classlevel." +
			"ValidPassengerCount.message}";

	Class&lt;?&gt;[] groups() default { };

	Class&lt;? extends Payload&gt;[] payload() default { };
}</code></pre><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter06.classlevel;

public class ValidPassengerCountValidator
		implements ConstraintValidator&lt;ValidPassengerCount, Car&gt; {

	@Override
	public void initialize(ValidPassengerCount constraintAnnotation) {
	}

	@Override
	public boolean isValid(Car car, ConstraintValidatorContext context) {
		if ( car == null ) {
			return true;
		}

		return car.getPassengers().size() &lt;= car.getSeatCount();
	}
}</code></pre></div></div><br class="example-break"/><p>As the example demonstrates, you need to use the element type <code class="literal">TYPE</code> in the <code class="literal">@Target</code> annotation. This
allows the constraint to be put on type definitions. The validator of the constraint in the example
receives a <code class="literal">Car</code> in the <code class="literal">isValid()</code> method and can access the complete object state to decide whether
the given instance is valid or not.</p><div class="section" title="6.2.1. Custom property paths"><div class="titlepage"><div><div><h3 class="title"><a id="section-custom-property-paths"/>6.2.1. Custom property paths</h3></div></div></div><p>By default the constraint violation for a class-level constraint is reported on the level of the
annotated type, e.g. <code class="literal">Car</code>.</p><p>In some cases it is preferable though that the violation’s property path refers to one of the
involved properties. For instance you might want to report the <code class="literal">@ValidPassengerCount</code> constraint
against the passengers property instead of the <code class="literal">Car</code> bean.</p><p><a class="xref" href="#example-custom-error" title="Example 6.9. Adding a new ConstraintViolation with custom property path">Example 6.9, “Adding a new <code class="literal">ConstraintViolation</code> with custom property path”</a>
shows how this can be done by using the constraint validator context passed to <code class="literal">isValid()</code> to build a
custom constraint violation with a property node for the property passengers. Note that you also
could add several property nodes, pointing to a sub-entity of the validated bean.</p><div class="example"><a id="example-custom-error"/><p class="title"><strong>Example 6.9. Adding a new <code class="literal">ConstraintViolation</code> with custom property path</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter06.custompath;

public class ValidPassengerCountValidator
		implements ConstraintValidator&lt;ValidPassengerCount, Car&gt; {

	@Override
	public void initialize(ValidPassengerCount constraintAnnotation) {
	}

	@Override
	public boolean isValid(Car car, ConstraintValidatorContext constraintValidatorContext) {
		if ( car == null ) {
			return true;
		}

		boolean isValid = car.getPassengers().size() &lt;= car.getSeatCount();

		if ( !isValid ) {
			constraintValidatorContext.disableDefaultConstraintViolation();
			constraintValidatorContext
					.buildConstraintViolationWithTemplate( "{my.custom.template}" )
					.addPropertyNode( "passengers" ).addConstraintViolation();
		}

		return isValid;
	}
}</code></pre></div></div><br class="example-break"/></div></div><div class="section" title="6.3. Cross-parameter constraints"><div class="titlepage"><div><div><h2 class="title"><a id="section-cross-parameter-constraints"/>6.3. Cross-parameter constraints</h2></div></div></div><p>Bean Validation distinguishes between two different kinds of constraints.</p><p>Generic constraints (which have been discussed so far) apply to the annotated element, e.g. a type,
field, method parameter or return value etc. Cross-parameter constraints, in contrast, apply to the
array of parameters of a method or constructor and can be used to express validation logic which
depends on several parameter values.</p><p>In order to define a cross-parameter constraint, its validator class must be annotated with
<code class="literal">@SupportedValidationTarget(ValidationTarget.PARAMETERS)</code>. The type parameter <code class="literal">T</code> from the
<code class="literal">ConstraintValidator</code> interface must resolve to either <code class="literal">Object</code> or <code class="literal">Object[]</code> in order to receive the
array of method/constructor arguments in the <code class="literal">isValid()</code> method.</p><p>The following example shows the definition of a cross-parameter constraint which can be used to
check that two <code class="literal">Date</code> parameters of a method are in the correct order:</p><div class="example"><a id="d0e3949"/><p class="title"><strong>Example 6.10. Cross-parameter constraint</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter06.crossparameter;

@Constraint(validatedBy = ConsistentDateParameterValidator.class)
@Target({ METHOD, CONSTRUCTOR, ANNOTATION_TYPE })
@Retention(RUNTIME)
@Documented
public @interface ConsistentDateParameters {

	String message() default "{org.hibernate.validator.referenceguide.chapter06." +
			"crossparameter.ConsistentDateParameters.message}";

	Class&lt;?&gt;[] groups() default { };

	Class&lt;? extends Payload&gt;[] payload() default { };
}</code></pre></div></div><br class="example-break"/><p>The definition of a cross-parameter constraint isn’t any different from defining a generic
constraint, i.e. it must specify the members <code class="literal">message()</code>, <code class="literal">groups()</code> and <code class="literal">payload()</code> and be annotated with
<code class="literal">@Constraint</code>. This meta annotation also specifies the corresponding validator, which is shown in
<a class="xref" href="#example-cross-parameter-validator" title="Example 6.11. Generic and cross-parameter constraint">Example 6.11, “Generic and cross-parameter constraint”</a>. Note that besides the element types <code class="literal">METHOD</code> and <code class="literal">CONSTRUCTOR</code>
also <code class="literal">ANNOTATION_TYPE</code> is specified as target of the annotation, in order to enable the creation of
composed constraints based on <code class="literal">@ConsistentDateParameters</code> (see
<a class="xref" href="#section-constraint-composition" title="6.4. Constraint composition">Section 6.4, “Constraint composition”</a>).</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>Cross-parameter constraints are specified directly on the declaration of a method or constructor,
which is also the case for return value constraints. In order to improve code readability, it is
therefore recommended to chose constraint names - such as <code class="literal">@ConsistentDateParameters</code> - which make the
constraint target apparent.</p></div><div class="example"><a id="example-cross-parameter-validator"/><p class="title"><strong>Example 6.11. Generic and cross-parameter constraint</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter06.crossparameter;

@SupportedValidationTarget(ValidationTarget.PARAMETERS)
public class ConsistentDateParameterValidator implements
		ConstraintValidator&lt;ConsistentDateParameters, Object[]&gt; {

	@Override
	public void initialize(ConsistentDateParameters constraintAnnotation) {
	}

	@Override
	public boolean isValid(Object[] value, ConstraintValidatorContext context) {
		if ( value.length != 2 ) {
			throw new IllegalArgumentException( "Illegal method signature" );
		}

		//leave null-checking to @NotNull on individual parameters
		if ( value[0] == null || value[1] == null ) {
			return true;
		}

		if ( !( value[0] instanceof Date ) || !( value[1] instanceof Date ) ) {
			throw new IllegalArgumentException(
					"Illegal method signature, expected two " +
							"parameters of type Date."
			);
		}

		return ( (Date) value[0] ).before( (Date) value[1] );
	}
}</code></pre></div></div><br class="example-break"/><p>As discussed above, the validation target <code class="literal">PARAMETERS</code> must be configured for a cross-parameter
validator by using the <code class="literal">@SupportedValidationTarget</code> annotation. Since a cross-parameter constraint
could be applied to any method or constructor, it is considered a best practice to check for the
expected number and types of parameters in the validator implementation.</p><p>As with generic constraints, <code class="literal">null</code> parameters should be considered valid and <code class="literal">@NotNull</code> on the
individual parameters should be used to make sure that parameters are not <code class="literal">null</code>.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>Similar to class-level constraints, you can create custom constraint violations on single parameters
instead of all parameters when validating a cross-parameter constraint. Just obtain a node builder
from the <code class="literal">ConstraintValidatorContext</code> passed to <code class="literal">isValid()</code> and add a parameter node by calling
<code class="literal">addParameterNode()</code>. In the example you could use this to create a constraint violation on the end
date parameter of the validated method.</p></div><p>In rare situations a constraint is both, generic and cross-parameter. This is the case if a
constraint has a validator class which is annotated with
<code class="literal">@SupportedValidationTarget({ValidationTarget.PARAMETERS, ValidationTarget.ANNOTATED_ELEMENT})</code> or if
it has a generic and a cross-parameter validator class.</p><p>When declaring such a constraint on a method which has parameters and also a return value, the
intended constraint target can’t be determined. Constraints which are generic and cross-parameter at
the same time, must therefore define a member <code class="literal">validationAppliesTo()</code> which allows the constraint user
to specify the constraint’s target as shown in <a class="xref" href="#example-dual-cross-parameter-constraint" title="Example 6.12. Generic and cross-parameter constraint">Example 6.12, “Generic and cross-parameter constraint”</a>.</p><div class="example"><a id="example-dual-cross-parameter-constraint"/><p class="title"><strong>Example 6.12. Generic and cross-parameter constraint</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter06.crossparameter;

@Constraint(validatedBy = {
		ScriptAssertObjectValidator.class,
		ScriptAssertParametersValidator.class
})
@Target({ TYPE, FIELD, PARAMETER, METHOD, CONSTRUCTOR, ANNOTATION_TYPE })
@Retention(RUNTIME)
@Documented
public @interface ScriptAssert {

	String message() default "{org.hibernate.validator.referenceguide.chapter06." +
			"crossparameter.ScriptAssert.message}";

	Class&lt;?&gt;[] groups() default { };

	Class&lt;? extends Payload&gt;[] payload() default { };

	String script();

	ConstraintTarget validationAppliesTo() default ConstraintTarget.IMPLICIT;
}</code></pre></div></div><br class="example-break"/><p>The <code class="literal">@ScriptAssert</code> constraint has two validators (not shown), a generic and a cross-parameter one and
thus defines the member <code class="literal">validationAppliesTo()</code>. The default value <code class="literal">IMPLICIT</code> allows to derive the
target automatically in situations where this is possible (e.g. if the constraint is declared on a
field or on a method which has parameters but no return value).</p><p>If the target can not be determined implicitly, it must be set by the user to either <code class="literal">PARAMETERS</code> or
<code class="literal">RETURN_VALUE</code> as shown in <a class="xref" href="#example-dual-cross-parameter-constraint-usage" title="Example 6.13. Specifying the target for a generic and cross-parameter constraint">Example 6.13, “Specifying the target for a generic and cross-parameter constraint”</a>.</p><div class="example"><a id="example-dual-cross-parameter-constraint-usage"/><p class="title"><strong>Example 6.13. Specifying the target for a generic and cross-parameter constraint</strong></p><div class="example-contents"><pre><code class="language-java">@ScriptAssert(script = "arg1.size() &lt;= arg0", validationAppliesTo = ConstraintTarget.PARAMETERS)
public Car buildCar(int seatCount, List&lt;Passenger&gt; passengers) {
	//...
}</code></pre></div></div><br class="example-break"/></div><div class="section" title="6.4. Constraint composition"><div class="titlepage"><div><div><h2 class="title"><a id="section-constraint-composition"/>6.4. Constraint composition</h2></div></div></div><p>Looking at the <code class="literal">licensePlate</code> field of the <code class="literal">Car</code> class in <a class="xref" href="#example-car-with-checkcase" title="Example 6.6. Applying the @CheckCase constraint">Example 6.6, “Applying the <code class="literal">@CheckCase</code> constraint”</a>, you see three
constraint annotations already. In complexer scenarios, where even more constraints could be applied
to one element, this might become a bit confusing easily. Furthermore, if there was a <code class="literal">licensePlate</code>
field in another class, you would have to copy all constraint declarations to the other class as
well, violating the DRY principle.</p><p>You can address this kind of problem by creating higher level constraints, composed from several
basic constraints. <a class="xref" href="#example-composed-constraint" title="Example 6.14. Creating a composing constraint @ValidLicensePlate">Example 6.14, “Creating a composing constraint <code class="literal">@ValidLicensePlate</code>”</a> shows a composed constraint annotation which
comprises the constraints <code class="literal">@NotNull</code>, <code class="literal">@Size</code> and <code class="literal">@CheckCase</code>:</p><div class="example"><a id="example-composed-constraint"/><p class="title"><strong>Example 6.14. Creating a composing constraint <code class="literal">@ValidLicensePlate</code></strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter06.constraintcomposition;

@NotNull
@Size(min = 2, max = 14)
@CheckCase(CaseMode.UPPER)
@Target({ METHOD, FIELD, ANNOTATION_TYPE })
@Retention(RUNTIME)
@Constraint(validatedBy = { })
@Documented
public @interface ValidLicensePlate {

	String message() default "{org.hibernate.validator.referenceguide.chapter06." +
			"constraintcomposition.ValidLicensePlate.message}";

	Class&lt;?&gt;[] groups() default { };

	Class&lt;? extends Payload&gt;[] payload() default { };
}</code></pre></div></div><br class="example-break"/><p>To create a composed constraint, simply annotate the constraint declaration with its comprising
constraints. If the composed constraint itself requires a validator, this validator is to be
specified within the <code class="literal">@Constraint</code> annotation. For composed constraints which don’t need an additional
validator such as <code class="literal">@ValidLicensePlate</code>, just set <code class="literal">validatedBy()</code> to an empty array.</p><p>Using the new composed constraint at the <code class="literal">licensePlate</code> field is fully equivalent to the previous
version, where the three constraints were declared directly at the field itself:</p><div class="example"><a id="d0e4121"/><p class="title"><strong>Example 6.15. Application of composing constraint <code class="literal">ValidLicensePlate</code></strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter06.constraintcomposition;

public class Car {

	@ValidLicensePlate
	private String licensePlate;

	//...
}</code></pre></div></div><br class="example-break"/><p>The set of <code class="literal">ConstraintViolations</code> retrieved when validating a <code class="literal">Car</code> instance will contain an entry for
each violated composing constraint of the <code class="literal">@ValidLicensePlate</code> constraint. If you rather prefer a
single <code class="literal">ConstraintViolation</code> in case any of the composing constraints is violated, the
<code class="literal">@ReportAsSingleViolation</code> meta constraint can be used as follows:</p><div class="example"><a id="d0e4145"/><p class="title"><strong>Example 6.16. Using @ReportAsSingleViolation</strong></p><div class="example-contents"><pre><code class="language-java">//...
@ReportAsSingleViolation
public @interface ValidLicensePlate {

	String message() default "{org.hibernate.validator.referenceguide.chapter06." +
			"constraintcomposition.ValidLicensePlate.message}";

	Class&lt;?&gt;[] groups() default { };

	Class&lt;? extends Payload&gt;[] payload() default { };
}</code></pre></div></div><br class="example-break"/></div></div><div class="chapter" title="Chapter 7. Configuring via XML"><div class="titlepage"><div><div><h2 class="title"><a id="chapter-xml-configuration"/>Chapter 7. Configuring via XML</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#section-configuration-validation-xml">7.1. Configuring the validator factory in <span class="emphasis"><em>validation.xml</em></span></a></span></dt><dt><span class="section"><a href="#section-mapping-xml-constraints">7.2. Mapping constraints via <code class="literal">constraint-mappings</code></a></span></dt></dl></div><p>So far we have used the default configuration source for Bean Validation, namely annotations.
However, there also exist two kinds of XML descriptors allowing configuration via XML. The first
descriptor describes general Bean Validation behaviour and is provided as <span class="emphasis"><em>META-INF/validation.xml</em></span>.
The second one describes constraint declarations and closely matches the constraint declaration
approach via annotations. Let’s have a look at these two document types.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>The XSD files are available via
<a class="link" href="http://www.jboss.org/xml/ns/javax/validation/configuration/">http://www.jboss.org/xml/ns/javax/validation/configuration</a> and
<a class="link" href="http://www.jboss.org/xml/ns/javax/validation/mapping">http://www.jboss.org/xml/ns/javax/validation/mapping</a>.</p></div><div class="section" title="7.1. Configuring the validator factory in validation.xml"><div class="titlepage"><div><div><h2 class="title"><a id="section-configuration-validation-xml"/>7.1. Configuring the validator factory in <span class="emphasis"><em>validation.xml</em></span></h2></div></div></div><p>The key to enable XML configuration for Hibernate Validator is the file <span class="emphasis"><em>META-INF/validation.xml</em></span>.
If this file exists on the classpath its configuration will be applied when the <code class="literal">ValidatorFactory</code>
gets created. <a class="xref" href="#image-validation-configuration" title="Figure 7.1. Validation configuration schema">Figure 7.1, “Validation configuration schema”</a> shows a model view of the XML schema to which
<span class="emphasis"><em>validation.xml</em></span> has to adhere.</p><div class="figure"><a id="image-validation-configuration"/><p class="title"><strong>Figure 7.1. Validation configuration schema</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/validation-configuration-1.1.png" alt="validation-configuration-1.1.xsd"/></div></div></div><br class="figure-break"/><p><a class="xref" href="#example-validation-xml" title="Example 7.1. validation.xml">Example 7.1, “<code class="literal">validation.xml</code>”</a>
shows the several configuration options of <span class="emphasis"><em>validation.xml</em></span>. All settings are optional and the same
configuration options are also available programmatically through <code class="literal">javax.validation.Configuration</code>. In
fact the XML configuration will be overridden by values explicitly specified via the programmatic
API. It is even possible to ignore the XML configuration completely via
<code class="literal">Configuration#ignoreXmlConfiguration()</code>. See also <a class="xref" href="#section-configuring-validator-factory" title="8.2. Configuring a ValidatorFactory">Section 8.2, “Configuring a <code class="literal">ValidatorFactory</code>”</a>.</p><div class="example"><a id="example-validation-xml"/><p class="title"><strong>Example 7.1. <code class="literal">validation.xml</code></strong></p><div class="example-contents"><pre><code class="language-xml">&lt;validation-config
    xmlns="http://jboss.org/xml/ns/javax/validation/configuration"
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://jboss.org/xml/ns/javax/validation/configuration"&gt;

    &lt;default-provider&gt;com.acme.ValidationProvider&lt;/default-provider&gt;

    &lt;message-interpolator&gt;com.acme.MessageInterpolator&lt;/message-interpolator&gt;
    &lt;traversable-resolver&gt;com.acme.TraversableResolver&lt;/traversable-resolver&gt;
    &lt;constraint-validator-factory&gt;
        com.acme.ConstraintValidatorFactory
    &lt;/constraint-validator-factory&gt;
    &lt;parameter-name-provider&gt;com.acme.ParameterNameProvider&lt;/parameter-name-provider&gt;

    &lt;executable-validation enabled="true"&gt;
        &lt;default-validated-executable-types&gt;
            &lt;executable-type&gt;CONSTRUCTORS&lt;/executable-type&gt;
            &lt;executable-type&gt;NON_GETTER_METHODS&lt;/executable-type&gt;
            &lt;executable-type&gt;GETTER_METHODS&lt;/executable-type&gt;
        &lt;/default-validated-executable-types&gt;
    &lt;/executable-validation&gt;

    &lt;constraint-mapping&gt;META-INF/validation/constraints-car.xml&lt;/constraint-mapping&gt;

    &lt;property name="hibernate.validator.fail_fast"&gt;false&lt;/property&gt;
&lt;/validation-config&gt;</code></pre></div></div><br class="example-break"/><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2><p>There must only be one file named <span class="emphasis"><em>META-INF/validation.xml</em></span> on the classpath. If more than one is
found an exception is thrown.</p></div><p>The node <code class="literal">default-provider</code> allows to choose the Bean Validation provider. This is useful if there is
more than one provider on the classpath. <code class="literal">message-interpolator</code>, <code class="literal">traversable-resolver</code>,
<code class="literal">constraint-validator-factory</code> and <code class="literal">parameter-name-provider</code> allow to customize the used
implementations for the interfaces <code class="literal">MessageInterpolator</code>, <code class="literal">TraversableResolver</code>,
<code class="literal">ConstraintValidatorFactory</code> and <code class="literal">ParameterNameProvider</code> defined in the <code class="literal">javax.validation</code> package.
See the sub-sections of <a class="xref" href="#section-configuring-validator-factory" title="8.2. Configuring a ValidatorFactory">Section 8.2, “Configuring a <code class="literal">ValidatorFactory</code>”</a> for more information about these
interfaces.</p><p><code class="literal">executable-validation</code> and its subnodes define defaults for method validation. The Bean Validation
specification defines constructor and non getter methods as defaults. The enabled attribute acts as
global switch to turn method validation on and off (see also <a class="xref" href="#chapter-method-constraints" title="Chapter 3. Declaring and validating method constraints">Chapter 3, <em>Declaring and validating method constraints</em></a>).</p><p>Via the <code class="literal">constraint-mapping</code> element you can list an arbitrary number of additional XML files
containing the actual constraint configuration. Mapping file names must be specified using their
fully-qualified name on the classpath. Details on writing mapping files can be found in the next
section.</p><p>Last but not least, you can specify provider specific properties via the <code class="literal">property</code> nodes. In the
example we are using the Hibernate Validator specific <code class="literal">hibernate.validator.fail_fast</code> property (see
<a class="xref" href="#section-fail-fast" title="11.2. Fail fast mode">Section 11.2, “Fail fast mode”</a>).</p></div><div class="section" title="7.2. Mapping constraints via constraint-mappings"><div class="titlepage"><div><div><h2 class="title"><a id="section-mapping-xml-constraints"/>7.2. Mapping constraints via <code class="literal">constraint-mappings</code></h2></div></div></div><p>Expressing constraints in XML is possible via files adhering to the schema seen in
<a class="xref" href="#image-mapping-configuration" title="Figure 7.2. Validation mapping schema">Figure 7.2, “Validation mapping schema”</a>. Note that these mapping files are only processed if listed via
constraint-mapping in <span class="emphasis"><em>validation.xml</em></span>.</p><div class="figure"><a id="image-mapping-configuration"/><p class="title"><strong>Figure 7.2. Validation mapping schema</strong></p><div class="figure-contents"><div class="mediaobject"><img src="images/validation-mapping-1.1.png" alt="validation-mapping-1.1.xsd"/></div></div></div><br class="figure-break"/><p><a class="xref" href="#example-constraints-car" title="Example 7.2. Bean constraints configured via XML">Example 7.2, “Bean constraints configured via XML”</a> shows how the classes Car and RentalCar from <a class="xref" href="#example-car" title="Example 5.3. Car">Example 5.3, “Car”</a> resp.
<a class="xref" href="#example-rental-car" title="Example 5.7. Class RentalCar with redefined default group">Example 5.7, “Class <code class="literal">RentalCar</code> with redefined default group”</a> could be mapped in XML.</p><div class="example"><a id="example-constraints-car"/><p class="title"><strong>Example 7.2. Bean constraints configured via XML</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;constraint-mappings
    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
    xsi:schemaLocation="http://jboss.org/xml/ns/javax/validation/mapping validation-mapping-1.1.xsd"
    xmlns="http://jboss.org/xml/ns/javax/validation/mapping" version="1.1"&gt;

    &lt;default-package&gt;org.hibernate.validator.referenceguide.chapter05&lt;/default-package&gt;
    &lt;bean class="Car" ignore-annotations="true"&gt;
        &lt;field name="manufacturer"&gt;
            &lt;constraint annotation="javax.validation.constraints.NotNull"/&gt;
        &lt;/field&gt;
        &lt;field name="licensePlate"&gt;
            &lt;constraint annotation="javax.validation.constraints.NotNull"/&gt;
        &lt;/field&gt;
        &lt;field name="seatCount"&gt;
            &lt;constraint annotation="javax.validation.constraints.Min"&gt;
                &lt;element name="value"&gt;2&lt;/element&gt;
            &lt;/constraint&gt;
        &lt;/field&gt;
        &lt;field name="driver"&gt;
            &lt;valid/&gt;
        &lt;/field&gt;
        &lt;getter name="passedVehicleInspection" ignore-annotations="true"&gt;
            &lt;constraint annotation="javax.validation.constraints.AssertTrue"&gt;
                &lt;message&gt;The car has to pass the vehicle inspection first&lt;/message&gt;
                &lt;groups&gt;
                    &lt;value&gt;CarChecks&lt;/value&gt;
                &lt;/groups&gt;
                &lt;element name="max"&gt;10&lt;/element&gt;
            &lt;/constraint&gt;
        &lt;/getter&gt;
    &lt;/bean&gt;
    &lt;bean class="RentalCar" ignore-annotations="true"&gt;
        &lt;class ignore-annotations="true"&gt;
            &lt;group-sequence&gt;
                &lt;value&gt;RentalCar&lt;/value&gt;
                &lt;value&gt;CarChecks&lt;/value&gt;
            &lt;/group-sequence&gt;
        &lt;/class&gt;
    &lt;/bean&gt;
    &lt;constraint-definition annotation="org.mycompany.CheckCase"&gt;
        &lt;validated-by include-existing-validators="false"&gt;
            &lt;value&gt;org.mycompany.CheckCaseValidator&lt;/value&gt;
        &lt;/validated-by&gt;
    &lt;/constraint-definition&gt;
&lt;/constraint-mappings&gt;</code></pre></div></div><br class="example-break"/><p><a class="xref" href="#example-rental-station-xml" title="Example 7.3. Method constraints configured via XML">Example 7.3, “Method constraints configured via XML”</a> shows how the constraints from
<a class="xref" href="#example-declaring-parameter-constraints" title="Example 3.1. Declaring method and constructor parameter constraints">Example 3.1, “Declaring method and constructor parameter constraints”</a>, <a class="xref" href="#example-declaring-return-value-constraints" title="Example 3.4. Declaring method and constructor return value constraints">Example 3.4, “Declaring method and constructor return value constraints”</a>
and <a class="xref" href="#example-specifying-constraint-target" title="Example 3.3. Specifying a constraint’s target">Example 3.3, “Specifying a constraint’s target”</a> can be expressed in XML.</p><div class="example"><a id="example-rental-station-xml"/><p class="title"><strong>Example 7.3. Method constraints configured via XML</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;constraint-mappings
        xmlns="http://jboss.org/xml/ns/javax/validation/mapping"
        xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
        xsi:schemaLocation=
                "http://jboss.org/xml/ns/javax/validation/mapping validation-mapping-1.1.xsd" version="1.1"&gt;

    &lt;default-package&gt;org.hibernate.validator.referenceguide.chapter07&lt;/default-package&gt;

    &lt;bean class="RentalStation" ignore-annotations="true"&gt;
        &lt;constructor&gt;
            &lt;return-value&gt;
                &lt;constraint annotation="ValidRentalStation"/&gt;
            &lt;/return-value&gt;
        &lt;/constructor&gt;

        &lt;constructor&gt;
            &lt;parameter type="java.lang.String"&gt;
                &lt;constraint annotation="javax.validation.constraints.NotNull"/&gt;
            &lt;/parameter&gt;
        &lt;/constructor&gt;

        &lt;method name="getCustomers"&gt;
            &lt;return-value&gt;
                &lt;constraint annotation="javax.validation.constraints.NotNull"/&gt;
                &lt;constraint annotation="javax.validation.constraints.Size"&gt;
                    &lt;element name="min"&gt;1&lt;/element&gt;
                &lt;/constraint&gt;
            &lt;/return-value&gt;
        &lt;/method&gt;

        &lt;method name="rentCar"&gt;
            &lt;parameter type="Customer"&gt;
                &lt;constraint annotation="javax.validation.constraints.NotNull"/&gt;
            &lt;/parameter&gt;
            &lt;parameter type="java.util.Date"&gt;
                &lt;constraint annotation="javax.validation.constraints.NotNull"/&gt;
                &lt;constraint annotation="javax.validation.constraints.Future"/&gt;
            &lt;/parameter&gt;
            &lt;parameter type="int"&gt;
                &lt;constraint annotation="javax.validation.constraints.Min"&gt;
                    &lt;element name="value"&gt;1&lt;/element&gt;
                &lt;/constraint&gt;
            &lt;/parameter&gt;
        &lt;/method&gt;
    &lt;/bean&gt;

    &lt;bean class="Garage" ignore-annotations="true"&gt;
        &lt;method name="buildCar"&gt;
            &lt;parameter type="java.util.List"/&gt;
            &lt;cross-parameter&gt;
                &lt;constraint annotation="ELAssert"&gt;
                    &lt;element name="expression"&gt;...&lt;/element&gt;
                    &lt;element name="validationAppliesTo"&gt;PARAMETERS&lt;/element&gt;
                &lt;/constraint&gt;
            &lt;/cross-parameter&gt;
        &lt;/method&gt;
        &lt;method name="paintCar"&gt;
            &lt;parameter type="int"/&gt;
            &lt;return-value&gt;
                &lt;constraint annotation="ELAssert"&gt;
                    &lt;element name="expression"&gt;...&lt;/element&gt;
                    &lt;element name="validationAppliesTo"&gt;RETURN_VALUE&lt;/element&gt;
                &lt;/constraint&gt;
            &lt;/return-value&gt;
        &lt;/method&gt;
    &lt;/bean&gt;

&lt;/constraint-mappings&gt;</code></pre></div></div><br class="example-break"/><p>The XML configuration is closely mirroring the programmatic API. For this reason it should suffice
to just add some comments. <code class="literal">default-package</code> is used for all fields where a class name is expected. If
the specified class is not fully qualified the configured default package will be used. Every
mapping file can then have several bean nodes, each describing the constraints on the entity with
the specified class name.</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2><p>A given class can only be configured once across all configuration files. The same applies for
constraint definitions for a given constraint annotation. It can only occur in one mapping file. If
these rules are violated a <code class="literal">ValidationException</code> is thrown.</p></div><p>Setting <code class="literal">ignore-annotations</code> to <code class="literal">true</code> means that constraint annotations placed on the configured bean
are ignored. The default for this value is true. <code class="literal">ignore-annotations</code> is also available for the nodes
<code class="literal">class</code>, <code class="literal">fields</code>, <code class="literal">getter</code>, <code class="literal">constructor</code>, <code class="literal">method</code>, <code class="literal">parameter</code>, <code class="literal">cross-parameter</code> and <code class="literal">return-value</code>.
If not explicitly specified on these levels the configured bean value applies.</p><p>The nodes <code class="literal">class</code>, <code class="literal">field</code>, <code class="literal">getter</code>, <code class="literal">constructor</code> and <code class="literal">method</code> (and its sub node parameter) determine on
which level the constraint gets placed. The <code class="literal">constraint</code> node is then used to add a constraint on the
corresponding level. Each constraint definition must define the class via the <code class="literal">annotation</code> attribute.
The constraint attributes required by the Bean Validation specification (<code class="literal">message</code>, <code class="literal">groups</code> and
<code class="literal">payload</code>) have dedicated nodes. All other constraint specific attributes are configured using the
<code class="literal">element</code> node.</p><p>The <code class="literal">class</code> node also allows to reconfigure the default group sequence (see
<a class="xref" href="#section-default-group-class" title="5.3. Redefining the default group sequence">Section 5.3, “Redefining the default group sequence”</a>) via the <code class="literal">group-sequence</code> node. Not shown in the example is the use
of <code class="literal">convert-group</code> to
specify group conversions (see <a class="xref" href="#section-group-conversion" title="5.4. Group conversion">Section 5.4, “Group conversion”</a>). This node is available on <code class="literal">field</code>,
<code class="literal">getter</code>, <code class="literal">parameter</code> and <code class="literal">return-value</code> and specifies a from and to attribute to specify the groups.</p><p>Last but not least, the list of <code class="literal">ConstraintValidator</code> instances associated to a given constraint
can be altered via the <code class="literal">constraint-definition</code> node. The annotation attribute represents the constraint
annotation being altered. The <code class="literal">validated-by</code> element represent the (ordered) list of <code class="literal">ConstraintValidator</code>
implementations associated to the constraint. If <code class="literal">include-existing-validator</code> is set to <code class="literal">false</code>,
validators defined on the constraint annotation are ignored. If set to <code class="literal">true</code>, the list of constraint
validators described in XML is concatenated to the list of validators specified on the annotation.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>One use case for constraint-definition is to change the default constraint definition for <code class="literal">@URL</code>.
Historically, Hibernate Validator’s default constraint validator for this constraint uses the
<code class="literal">java.net.URL</code> constructor to verify that an URL is valid.
However, there is also a purely regular expression based version available which can be configured using
XML:</p><p title="Using XML to register a regular expression based constraint definition for @URL"><strong>Using XML to register a regular expression based constraint definition for <code class="literal">@URL</code>. </strong>
</p><pre><code class="language-xml">&lt;constraint-definition annotation="org.hibernate.validator.constraints.URL"&gt;
  &lt;validated-by include-existing-validators="false"&gt;
    &lt;value&gt;org.hibernate.validator.constraintvalidators.RegexpURLValidator&lt;/value&gt;
  &lt;/validated-by&gt;
&lt;/constraint-definition&gt;</code></pre><p title="Using XML to register a regular expression based constraint definition for @URL">
</p></div></div></div><div class="chapter" title="Chapter 8. Bootstrapping"><div class="titlepage"><div><div><h2 class="title"><a id="chapter-bootstrapping"/>Chapter 8. Bootstrapping</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#section-retrieving-validator-factory-validator">8.1. Retrieving <code class="literal">ValidatorFactory</code> and <code class="literal">Validator</code></a></span></dt><dd><dl><dt><span class="section"><a href="#section-validation-provider-resolver">8.1.1. <code class="literal">ValidationProviderResolver</code></a></span></dt></dl></dd><dt><span class="section"><a href="#section-configuring-validator-factory">8.2. Configuring a <code class="literal">ValidatorFactory</code></a></span></dt><dd><dl><dt><span class="section"><a href="#section-validator-factory-message-interpolator">8.2.1. <code class="literal">MessageInterpolator</code></a></span></dt><dt><span class="section"><a href="#__literal_traversableresolver_literal">8.2.2. <code class="literal">TraversableResolver</code></a></span></dt><dt><span class="section"><a href="#__literal_constraintvalidatorfactory_literal">8.2.3. <code class="literal">ConstraintValidatorFactory</code></a></span></dt><dt><span class="section"><a href="#section-parameter-name-provider">8.2.4. <code class="literal">ParameterNameProvider</code></a></span></dt><dt><span class="section"><a href="#_adding_mapping_streams">8.2.5. Adding mapping streams</a></span></dt><dt><span class="section"><a href="#section-provider-specific-settings">8.2.6. Provider-specific settings</a></span></dt></dl></dd><dt><span class="section"><a href="#section-configuring-validator">8.3. Configuring a Validator</a></span></dt></dl></div><p>In <a class="xref" href="#section-obtaining-validator" title="2.2.1. Obtaining a Validator instance">Section 2.2.1, “Obtaining a <code class="literal">Validator</code> instance”</a> you already saw one way for creating a Validator instance - via
<code class="literal">Validation#buildDefaultValidatorFactory()</code>. In this chapter you will learn how to use the other
methods in <code class="literal">javax.validation.Validation</code> in order to bootstrap specifically configured validators.</p><div class="section" title="8.1. Retrieving ValidatorFactory and Validator"><div class="titlepage"><div><div><h2 class="title"><a id="section-retrieving-validator-factory-validator"/>8.1. Retrieving <code class="literal">ValidatorFactory</code> and <code class="literal">Validator</code></h2></div></div></div><p>You obtain a <code class="literal">Validator</code> by retrieving a <code class="literal">ValidatorFactory</code> via one of the static methods on
<code class="literal">javax.validation.Validation</code> and calling <code class="literal">getValidator()</code> on the factory instance.</p><p><a class="xref" href="#example-build-default-validator-factory" title="Example 8.1. Bootstrapping default ValidatorFactory and Validator">Example 8.1, “Bootstrapping default <code class="literal">ValidatorFactory</code> and <code class="literal">Validator</code>”</a> shows how to obtain a validator from the default
validator factory:</p><div class="example"><a id="example-build-default-validator-factory"/><p class="title"><strong>Example 8.1. Bootstrapping default <code class="literal">ValidatorFactory</code> and <code class="literal">Validator</code></strong></p><div class="example-contents"><pre><code class="language-java">ValidatorFactory factory = Validation.buildDefaultValidatorFactory();
Validator validator = factory.getValidator();</code></pre></div></div><br class="example-break"/><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>The generated <code class="literal">ValidatorFactory</code> and <code class="literal">Validator</code> instances are thread-safe and can be cached. As
Hibernate Validator uses the factory as context for caching constraint metadata it is recommended to
work with one factory instance within an application.</p></div><p>Bean Validation supports working with several providers such as Hibernate Validator within one
application. If more than one provider is present on the classpath, it is not guaranteed which one
is chosen when creating a factory via <code class="literal">buildDefaultValidatorFactory()</code>.</p><p>In this case you can explicitly specify the provider to use via <code class="literal">Validation#byProvider()</code>, passing the
provider’s <code class="literal">ValidationProvider</code> class as shown in <a class="xref" href="#example-using-specific-provider" title="Example 8.2. Bootstrapping ValidatorFactory and Validator using a specific provider">Example 8.2, “Bootstrapping <code class="literal">ValidatorFactory</code> and Validator using a specific provider”</a>.</p><div class="example"><a id="example-using-specific-provider"/><p class="title"><strong>Example 8.2. Bootstrapping <code class="literal">ValidatorFactory</code> and Validator using a specific provider</strong></p><div class="example-contents"><pre><code class="language-java">ValidatorFactory validatorFactory = Validation.byProvider( HibernateValidator.class )
		.configure()
		.buildValidatorFactory();
Validator validator = validatorFactory.getValidator();</code></pre></div></div><br class="example-break"/><p>Note that the configuration object returned by <code class="literal">configure()</code> allows to specifically customize the
factory before calling <code class="literal">buildValidatorFactory()</code>. The available options are discussed later in this
chapter.</p><p>Similarly you can retrieve the default validator factory for configuration which is demonstrated in
<a class="xref" href="#example-configuring-default-provider" title="Example 8.3. Retrieving the default ValidatorFactory for configuration">Example 8.3, “Retrieving the default <code class="literal">ValidatorFactory</code> for configuration”</a>.</p><div class="example"><a id="example-configuring-default-provider"/><p class="title"><strong>Example 8.3. Retrieving the default <code class="literal">ValidatorFactory</code> for configuration</strong></p><div class="example-contents"><pre><code class="language-java">ValidatorFactory validatorFactory = Validation.byDefaultProvider()
		.configure()
		.buildValidatorFactory();
Validator validator = validatorFactory.getValidator();</code></pre></div></div><br class="example-break"/><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>If a <code class="literal">ValidatorFactory</code> instance is no longer in use, it should be disposed by calling
<code class="literal">ValidatorFactory#close()</code>. This will free any resources possibly allocated by the factory.</p></div><div class="section" title="8.1.1. ValidationProviderResolver"><div class="titlepage"><div><div><h3 class="title"><a id="section-validation-provider-resolver"/>8.1.1. <code class="literal">ValidationProviderResolver</code></h3></div></div></div><p>By default, available Bean Validation providers are discovered using the
<a class="link" href="http://docs.oracle.com/javase/6/docs/technotes/guides/jar/jar.html#Service%20Provider">Java
Service Provider</a> mechanism.</p><p>For that purpose, each provider includes the file <span class="emphasis"><em>META-
INF/services/javax.validation.spi.ValidationProvider</em></span>, containing the fully qualified classname of
its <code class="literal">ValidationProvider</code> implementation. In the case of Hibernate Validator this is
<code class="literal">org.hibernate.validator.HibernateValidator</code>.</p><p>Depending on your environment and its classloading specifics, provider discovery via the Java’s
service loader mechanism might not work. In this case you can plug in a custom
<code class="literal">ValidationProviderResolver</code> implementation which performs the provider retrieval. An example is OSGi,
where you could implement a provider resolver which uses OSGi services for provider discovery.</p><p>To use a custom provider resolver pass it via <code class="literal">providerResolver()</code> as shown shown in
<a class="xref" href="#example-using-custom-validation-provider-resolver" title="Example 8.4. Using a custom ValidationProviderResolver">Example 8.4, “Using a custom <code class="literal">ValidationProviderResolver</code>”</a>.</p><div class="example"><a id="example-using-custom-validation-provider-resolver"/><p class="title"><strong>Example 8.4. Using a custom <code class="literal">ValidationProviderResolver</code></strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter08;

public class OsgiServiceDiscoverer implements ValidationProviderResolver {

	@Override
	public List&lt;ValidationProvider&lt;?&gt;&gt; getValidationProviders() {
		//...
	}
}</code></pre><pre><code class="language-java">ValidatorFactory validatorFactory = Validation.byDefaultProvider()
		.providerResolver( new OsgiServiceDiscoverer() )
		.configure()
		.buildValidatorFactory();
Validator validator = validatorFactory.getValidator();</code></pre></div></div><br class="example-break"/></div></div><div class="section" title="8.2. Configuring a ValidatorFactory"><div class="titlepage"><div><div><h2 class="title"><a id="section-configuring-validator-factory"/>8.2. Configuring a <code class="literal">ValidatorFactory</code></h2></div></div></div><p>By default validator factories retrieved from <code class="literal">Validation</code> and any validators they create are
configured as per the XML descriptor <span class="emphasis"><em>META-INF/validation.xml</em></span> (see <a class="xref" href="#chapter-xml-configuration" title="Chapter 7. Configuring via XML">Chapter 7, <em>Configuring via XML</em></a>),
if present.</p><p>If you want to disable the XML based configuration, you can do so by invoking
<code class="literal">Configuration#ignoreXmlConfiguration()</code>.</p><p>The different values of the XML configuration can be accessed via
<code class="literal">Configuration#getBootstrapConfiguration()</code>. This can for instance be helpful if you want to integrate
Bean Validation into a managed environment and want to create managed instances of the objects
configured via XML.</p><p>Using the fluent configuration API, you can override one or more of the settings when bootstrapping
the factory. The following sections show how to make use of the different options. Note that the
<code class="literal">Configuration</code> class exposes the default implementations of the different extension points which can
be useful if you want to use these as delegates for your custom implementations.</p><div class="section" title="8.2.1. MessageInterpolator"><div class="titlepage"><div><div><h3 class="title"><a id="section-validator-factory-message-interpolator"/>8.2.1. <code class="literal">MessageInterpolator</code></h3></div></div></div><p>Message interpolators are used by the validation engine to create user readable error messages from
constraint message descriptors.</p><p>In case the default message interpolation algorithm described in <a class="xref" href="#chapter-message-interpolation" title="Chapter 4. Interpolating constraint error messages">Chapter 4, <em>Interpolating constraint error messages</em></a>
is not sufficient for your needs, you can pass in your own implementation of the <code class="literal">MessageInterpolator</code>
interface via <code class="literal">Configuration#messageInterpolator()</code> as shown in
<a class="xref" href="#example-using-custom-message-interpolator" title="Example 8.5. Using a custom MessageInterpolator">Example 8.5, “Using a custom <code class="literal">MessageInterpolator</code>”</a>.</p><div class="example"><a id="example-using-custom-message-interpolator"/><p class="title"><strong>Example 8.5. Using a custom <code class="literal">MessageInterpolator</code></strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter08;

public class MyMessageInterpolator implements MessageInterpolator {

	@Override
	public String interpolate(String messageTemplate, Context context) {
		//...
	}

	@Override
	public String interpolate(String messageTemplate, Context context, Locale locale) {
		//...
	}
}</code></pre><pre><code class="language-java">ValidatorFactory validatorFactory = Validation.byDefaultProvider()
		.configure()
		.messageInterpolator( new MyMessageInterpolator() )
		.buildValidatorFactory();
Validator validator = validatorFactory.getValidator();</code></pre></div></div><br class="example-break"/></div><div class="section" title="8.2.2. TraversableResolver"><div class="titlepage"><div><div><h3 class="title"><a id="__literal_traversableresolver_literal"/>8.2.2. <code class="literal">TraversableResolver</code></h3></div></div></div><p>In some cases the validation engine should not access the state of a bean property. The most obvious
example for that is a lazily loaded property or association of a JPA entity. Validating this lazy
property or association would mean that its state would have to be accessed, triggering a load from
the database.</p><p>Which properties can be accessed and which ones not is controlled by querying the
<code class="literal">TraversableResolver</code> interface. <a class="xref" href="#example-using-custom-traversable-resolver" title="Example 8.6. Using a custom TraversableResolver">Example 8.6, “Using a custom <code class="literal">TraversableResolver</code>”</a> shows how to use a
custom traversable resolver implementation.</p><div class="example"><a id="example-using-custom-traversable-resolver"/><p class="title"><strong>Example 8.6. Using a custom <code class="literal">TraversableResolver</code></strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter08;

public class MyTraversableResolver implements TraversableResolver {

	@Override
	public boolean isReachable(
			Object traversableObject,
			Node traversableProperty,
			Class&lt;?&gt; rootBeanType,
			Path pathToTraversableObject,
			ElementType elementType) {
		//...
	}

	@Override
	public boolean isCascadable(
			Object traversableObject,
			Node traversableProperty,
			Class&lt;?&gt; rootBeanType,
			Path pathToTraversableObject,
			ElementType elementType) {
		//...
	}
}</code></pre><pre><code class="language-java">ValidatorFactory validatorFactory = Validation.byDefaultProvider()
		.configure()
		.traversableResolver( new MyTraversableResolver() )
		.buildValidatorFactory();
Validator validator = validatorFactory.getValidator();</code></pre></div></div><br class="example-break"/><p>If no specific traversable resolver has been configured, the default behavior is to consider all properties as reachable and cascadable.
When using Hibernate Validator together with a JPA 2 provider such as Hibernate ORM, only those properties will be considered reachable
which already have been loaded by the persistence provider and all properties will be considered cascadable.</p></div><div class="section" title="8.2.3. ConstraintValidatorFactory"><div class="titlepage"><div><div><h3 class="title"><a id="__literal_constraintvalidatorfactory_literal"/>8.2.3. <code class="literal">ConstraintValidatorFactory</code></h3></div></div></div><p><code class="literal">ConstraintValidatorFactory</code> is the extension point for customizing how constraint validators are
instantiated and released.</p><p>The default <code class="literal">ConstraintValidatorFactory</code> provided by Hibernate Validator requires a public no-arg
constructor to instantiate <code class="literal">ConstraintValidator</code> instances (see <a class="xref" href="#section-constraint-validator" title="6.1.2. The constraint validator">Section 6.1.2, “The constraint validator”</a>).
Using a custom <code class="literal">ConstraintValidatorFactory</code> offers for example the possibility to use dependency
injection in constraint validator implementations.</p><p>To configure a custom constraint validator factory call <code class="literal">Configuration#constraintValidatorFactory()</code>
(see <a class="xref" href="#example-using-custom-constraint-validator-factory" title="Example 8.7. Using a custom ConstraintValidatorFactory">Example 8.7, “Using a custom <code class="literal">ConstraintValidatorFactory</code>”</a>.</p><div class="example"><a id="example-using-custom-constraint-validator-factory"/><p class="title"><strong>Example 8.7. Using a custom <code class="literal">ConstraintValidatorFactory</code></strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter08;

public class MyConstraintValidatorFactory implements ConstraintValidatorFactory {

	@Override
	public &lt;T extends ConstraintValidator&lt;?, ?&gt;&gt; T getInstance(Class&lt;T&gt; key) {
		//...
	}

	@Override
	public void releaseInstance(ConstraintValidator&lt;?, ?&gt; instance) {
		//...
	}
}</code></pre><pre><code class="language-java">ValidatorFactory validatorFactory = Validation.byDefaultProvider()
		.configure()
		.constraintValidatorFactory( new MyConstraintValidatorFactory() )
		.buildValidatorFactory();
Validator validator = validatorFactory.getValidator();</code></pre></div></div><br class="example-break"/><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2><p>Any constraint implementations relying on <code class="literal">ConstraintValidatorFactory</code> behaviors specific to an
implementation (dependency injection, no no-arg constructor and so on) are not considered portable.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p><code class="literal">ConstraintValidatorFactory</code> implementations should not cache validator instances as the state of each
instance can be altered in the <code class="literal">initialize()</code> method.</p></div></div><div class="section" title="8.2.4. ParameterNameProvider"><div class="titlepage"><div><div><h3 class="title"><a id="section-parameter-name-provider"/>8.2.4. <code class="literal">ParameterNameProvider</code></h3></div></div></div><p>In case a method or constructor parameter constraint is violated, the <code class="literal">ParameterNameProvider</code>
interface is used to retrieve the parameter name and make it available to the user via the
property path of the constraint violation.</p><p>The default implementation returns parameter names in the form of <code class="literal">arg0</code>, <code class="literal">arg1</code> etc, while custom
implementations can retrieve the parameter names using methods such as parameter annotations,
debug symbols, or Java 8 reflection.</p><p>An implementation for retrieving the parameter names using reflection in Java 8 is provided with
<code class="literal">ReflectionParameterNameProvider</code>. For this parameter name provider to work, the
source must be compiled using the <code class="literal">–parameters</code> compiler argument. Otherwise, the provider will
return synthetic names in the form of <code class="literal">arg0</code>, <code class="literal">arg1</code>, etc.</p><p>To use <code class="literal">ReflectionParameterNameProvider</code> or another custom provider either pass an instance of
the provider during bootstrapping as shown in <a class="xref" href="#example-using-custom-parameter-name-provider" title="Example 8.8. Using a custom ParameterNameProvider">Example 8.8, “Using a custom <code class="literal">ParameterNameProvider</code>”</a>,
or specify the fully qualified class name of the provider as value for
the <code class="literal">&lt;parameter-name-provider&gt;</code> element in the <span class="emphasis"><em>META-INF/validation.xml</em></span> file
(see <a class="xref" href="#section-configuration-validation-xml" title="7.1. Configuring the validator factory in validation.xml">Section 7.1, “Configuring the validator factory in <span class="emphasis"><em>validation.xml</em></span>”</a>). This is demonstrated in
<a class="xref" href="#example-using-custom-parameter-name-provider" title="Example 8.8. Using a custom ParameterNameProvider">Example 8.8, “Using a custom <code class="literal">ParameterNameProvider</code>”</a>.</p><div class="example"><a id="example-using-custom-parameter-name-provider"/><p class="title"><strong>Example 8.8. Using a custom <code class="literal">ParameterNameProvider</code></strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter08;

public class MyParameterNameProvider implements ParameterNameProvider {

	@Override
	public List&lt;String&gt; getParameterNames(Constructor&lt;?&gt; constructor) {
		//...
	}

	@Override
	public List&lt;String&gt; getParameterNames(Method method) {
		//...
	}
}</code></pre><pre><code class="language-java">ValidatorFactory validatorFactory = Validation.byDefaultProvider()
		.configure()
		.parameterNameProvider( new MyParameterNameProvider() )
		.buildValidatorFactory();
Validator validator = validatorFactory.getValidator();</code></pre></div></div><br class="example-break"/><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>Hibernate Validator comes with a custom <code class="literal">ParameterNameProvider</code> implementation based on the
<a class="link" href="https://github.com/paul-hammant/paranamer/">ParaNamer</a> library which provides several ways
for obtaining parameter names at runtime. Refer to <a class="xref" href="#section-paranamer-parameternameprovider" title="11.10. ParaNamer based ParameterNameProvider">Section 11.10, “ParaNamer based <code class="literal">ParameterNameProvider</code>”</a>
to learn more about this specific implementation.</p></div></div><div class="section" title="8.2.5. Adding mapping streams"><div class="titlepage"><div><div><h3 class="title"><a id="_adding_mapping_streams"/>8.2.5. Adding mapping streams</h3></div></div></div><p>As discussed earlier you can configure the constraints applying for your Java beans using XML based
constraint mappings.</p><p>Besides the mapping files specified in <span class="emphasis"><em>META-INF/validation.xml</em></span> you can add further mappings via
<code class="literal">Configuration#addMapping()</code> (see <a class="xref" href="#example-adding-mapping-streams" title="Example 8.9. Adding constraint mapping streams">Example 8.9, “Adding constraint mapping streams”</a>). Note that the passed input
stream(s) must adhere to the XML schema for constraint mappings presented in
<a class="xref" href="#section-mapping-xml-constraints" title="7.2. Mapping constraints via constraint-mappings">Section 7.2, “Mapping constraints via <code class="literal">constraint-mappings</code>”</a>.</p><div class="example"><a id="example-adding-mapping-streams"/><p class="title"><strong>Example 8.9. Adding constraint mapping streams</strong></p><div class="example-contents"><pre><code class="language-java">InputStream constraintMapping1 = ...;
InputStream constraintMapping2 = ...;
ValidatorFactory validatorFactory = Validation.byDefaultProvider()
		.configure()
		.addMapping( constraintMapping1 )
		.addMapping( constraintMapping2 )
		.buildValidatorFactory();
Validator validator = validatorFactory.getValidator();</code></pre></div></div><br class="example-break"/><p>You should close any passed input stream after the validator factory has been created.</p></div><div class="section" title="8.2.6. Provider-specific settings"><div class="titlepage"><div><div><h3 class="title"><a id="section-provider-specific-settings"/>8.2.6. Provider-specific settings</h3></div></div></div><p>Via the configuration object returned by <code class="literal">Validation#byProvider()</code> provider specific options can be
configured.</p><p>In case of Hibernate Validator this e.g. allows you to enable the fail fast mode and pass one or
more programmatic constraint mappings as demonstrated in
<a class="xref" href="#example-hibernate-validator-specific-options" title="Example 8.10. Setting Hibernate Validator specific options">Example 8.10, “Setting Hibernate Validator specific options”</a>.</p><div class="example"><a id="example-hibernate-validator-specific-options"/><p class="title"><strong>Example 8.10. Setting Hibernate Validator specific options</strong></p><div class="example-contents"><pre><code class="language-java">ValidatorFactory validatorFactory = Validation.byProvider( HibernateValidator.class )
		.configure()
		.failFast( true )
		.addMapping( (ConstraintMapping) null )
		.buildValidatorFactory();
Validator validator = validatorFactory.getValidator();</code></pre></div></div><br class="example-break"/><p>Alternatively, provider-specific options can be passed via <code class="literal">Configuration#addProperty()</code>. Hibernate
Validator supports enabling the fail fast mode that way, too:</p><div class="example"><a id="example-hibernate-validator-specific-option-via-addproperty"/><p class="title"><strong>Example 8.11. Enabling a Hibernate Validator specific option via <code class="literal">addProperty()</code></strong></p><div class="example-contents"><pre><code class="language-java">ValidatorFactory validatorFactory = Validation.byProvider( HibernateValidator.class )
		.configure()
		.addProperty( "hibernate.validator.fail_fast", "true" )
		.buildValidatorFactory();
Validator validator = validatorFactory.getValidator();</code></pre></div></div><br class="example-break"/><p>Refer to <a class="xref" href="#section-fail-fast" title="11.2. Fail fast mode">Section 11.2, “Fail fast mode”</a> and <a class="xref" href="#section-programmatic-api" title="11.3. Programmatic constraint declaration">Section 11.3, “Programmatic constraint declaration”</a> to learn more about the fail fast
mode and the constraint declaration API.</p></div></div><div class="section" title="8.3. Configuring a Validator"><div class="titlepage"><div><div><h2 class="title"><a id="section-configuring-validator"/>8.3. Configuring a Validator</h2></div></div></div><p>When working with a configured validator factory it can occasionally be required to apply a
different configuration to a single <code class="literal">Validator</code> instance. <a class="xref" href="#example-using-context" title="Example 8.12. Configuring a Validator instance via usingContext()">Example 8.12, “Configuring a <code class="literal">Validator</code> instance via <code class="literal">usingContext()</code>”</a> shows how this can
be achieved by calling <code class="literal">ValidatorFactory#usingContext()</code>.</p><div class="example"><a id="example-using-context"/><p class="title"><strong>Example 8.12. Configuring a <code class="literal">Validator</code> instance via <code class="literal">usingContext()</code></strong></p><div class="example-contents"><pre><code class="language-java">ValidatorFactory validatorFactory = Validation.buildDefaultValidatorFactory();

Validator validator = validatorFactory.usingContext()
		.messageInterpolator( new MyMessageInterpolator() )
		.traversableResolver( new MyTraversableResolver() )
		.getValidator();</code></pre></div></div><br class="example-break"/></div></div><div class="chapter" title="Chapter 9. Using constraint metadata"><div class="titlepage"><div><div><h2 class="title"><a id="validator-metadata-api"/>Chapter 9. Using constraint metadata</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#__literal_beandescriptor_literal">9.1. <code class="literal">BeanDescriptor</code></a></span></dt><dt><span class="section"><a href="#section-property-descriptor">9.2. <code class="literal">PropertyDescriptor</code></a></span></dt><dt><span class="section"><a href="#__literal_methoddescriptor_literal_and_literal_constructordescriptor_literal">9.3. <code class="literal">MethodDescriptor</code> and <code class="literal">ConstructorDescriptor</code></a></span></dt><dt><span class="section"><a href="#validator-metadata-api-elementdescriptor">9.4. <code class="literal">ElementDescriptor</code></a></span></dt><dt><span class="section"><a href="#section-group-conversion-descriptor">9.5. <code class="literal">GroupConversionDescriptor</code></a></span></dt><dt><span class="section"><a href="#section-constraint-descriptor">9.6. <code class="literal">ConstraintDescriptor</code></a></span></dt></dl></div><p>The Bean Validation specification provides not only a validation engine, but also an API for
retrieving constraint metadata in a uniform way, no matter whether the constraints are declared
using annotations or via XML mappings. Read this chapter to learn more about this API and its
possibilities. You can find all the metadata API types in the package <code class="literal">javax.validation.metadata</code>.</p><p>The examples presented in this chapter are based on the classes and constraint declarations shown in
<a class="xref" href="#metadata-example-car" title="Example 9.1. Example classes">Example 9.1, “Example classes”</a>.</p><div class="example"><a id="metadata-example-car"/><p class="title"><strong>Example 9.1. Example classes</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter07;

public class Person {

	public interface Basic {
	}

	@NotNull
	private String name;

	//getters and setters ...
}</code></pre><pre><code class="language-java">public interface Vehicle {

	public interface Basic {
	}

	@NotNull(groups = Vehicle.Basic.class)
	String getManufacturer();
}</code></pre><pre><code class="language-java">@ValidCar
public class Car implements Vehicle {

	public interface SeverityInfo extends Payload {
	}

	private String manufacturer;

	@NotNull
	@Size(min = 2, max = 14)
	private String licensePlate;

	private Person driver;

	private String modelName;

	public Car() {
	}

	public Car(
			@NotNull String manufacturer,
			String licencePlate,
			Person driver,
			String modelName) {

		this.manufacturer = manufacturer;
		this.licensePlate = licencePlate;
		this.driver = driver;
		this.modelName = modelName;
	}

	public void driveAway(@Max(75) int speed) {
		//...
	}

	@LuggageCountMatchesPassengerCount(
			piecesOfLuggagePerPassenger = 2,
			validationAppliesTo = ConstraintTarget.PARAMETERS,
			payload = SeverityInfo.class,
			message = "There must not be more than {piecesOfLuggagePerPassenger} pieces of " +
					"luggage per passenger."
	)
	public void load(List&lt;Person&gt; passengers, List&lt;PieceOfLuggage&gt; luggage) {
		//...
	}

	@Override
	@Size(min = 3)
	public String getManufacturer() {
		return manufacturer;
	}

	public void setManufacturer(String manufacturer) {
		this.manufacturer = manufacturer;
	}

	@Valid
	@ConvertGroup(from = Default.class, to = Person.Basic.class)
	public Person getDriver() {
		return driver;
	}

	//further getters and setters...
}</code></pre></div></div><br class="example-break"/><div class="section" title="9.1. BeanDescriptor"><div class="titlepage"><div><div><h2 class="title"><a id="__literal_beandescriptor_literal"/>9.1. <code class="literal">BeanDescriptor</code></h2></div></div></div><p>The entry point into the metadata API is the method <code class="literal">Validator#getConstraintsForClass()</code>, which
returns an instance of the <code class="literal"><a class="link" href="http://docs.jboss.org/hibernate/beanvalidation/spec/1.1/api/index. html?javax/validation/metadata/BeanDescriptor.html">BeanDescriptor</a></code> interface. Using this
descriptor, you can obtain metadata for constraints declared directly on the bean itself (class- or
property-level), but also retrieve metadata descriptors representing single properties, methods and
constructors.</p><p><a class="xref" href="#metadata-example-using-beandescriptor" title="Example 9.2. Using BeanDescriptor">Example 9.2, “Using <code class="literal">BeanDescriptor</code>”</a> demonstrates how to retrieve a <code class="literal">BeanDescriptor</code> for the
<code class="literal">Car</code> class and how to use this descriptor in form of assertions.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>If a constraint declaration hosted by the requested class is invalid, a <code class="literal">ValidationException</code> is thrown.</p></div><div class="example"><a id="metadata-example-using-beandescriptor"/><p class="title"><strong>Example 9.2. Using <code class="literal">BeanDescriptor</code></strong></p><div class="example-contents"><pre><code class="language-java">Validator validator = Validation.buildDefaultValidatorFactory().getValidator();

BeanDescriptor carDescriptor = validator.getConstraintsForClass( Car.class );

assertTrue( carDescriptor.isBeanConstrained() );

//one class-level constraint
assertEquals( 1, carDescriptor.getConstraintDescriptors().size() );

//manufacturer, licensePlate, driver
assertEquals( 3, carDescriptor.getConstrainedProperties().size() );

//property has constraint
assertNotNull( carDescriptor.getConstraintsForProperty( "licensePlate" ) );

//property is marked with @Valid
assertNotNull( carDescriptor.getConstraintsForProperty( "driver" ) );

//constraints from getter method in interface and implementation class are returned
assertEquals(
		2,
		carDescriptor.getConstraintsForProperty( "manufacturer" )
				.getConstraintDescriptors()
				.size()
);

//property is not constrained
assertNull( carDescriptor.getConstraintsForProperty( "modelName" ) );

//driveAway(int), load(List&lt;Person&gt;, List&lt;PieceOfLuggage&gt;)
assertEquals( 2, carDescriptor.getConstrainedMethods( MethodType.NON_GETTER ).size() );

//driveAway(int), getManufacturer(), getDriver(), load(List&lt;Person&gt;, List&lt;PieceOfLuggage&gt;)
assertEquals(
		4,
		carDescriptor.getConstrainedMethods( MethodType.NON_GETTER, MethodType.GETTER )
				.size()
);

//driveAway(int)
assertNotNull( carDescriptor.getConstraintsForMethod( "driveAway", int.class ) );

//getManufacturer()
assertNotNull( carDescriptor.getConstraintsForMethod( "getManufacturer" ) );

//setManufacturer() is not constrained
assertNull( carDescriptor.getConstraintsForMethod( "setManufacturer", String.class ) );

//Car(String, String, Person, String)
assertEquals( 1, carDescriptor.getConstrainedConstructors().size() );

//Car(String, String, Person, String)
assertNotNull(
		carDescriptor.getConstraintsForConstructor(
				String.class,
				String.class,
				Person.class,
				String.class
		)
);</code></pre></div></div><br class="example-break"/><p>You can determine whether the specified class hosts any class- or property-level constraints via
<code class="literal">isBeanConstrained()</code>. Method or constructor constraints are not considered by <code class="literal">isBeanConstrained()</code>.</p><p>The method <code class="literal">getConstraintDescriptors()</code> is common to all descriptors derived from <code class="literal">ElementDescriptor</code>
(see <a class="xref" href="#validator-metadata-api-elementdescriptor" title="9.4. ElementDescriptor">Section 9.4, “<code class="literal">ElementDescriptor</code>”</a>) and returns a set of descriptors representing the
constraints directly declared on the given element. In case of <code class="literal">BeanDescriptor</code>, the bean’s class-
level constraints are returned. More details on <code class="literal">ConstraintDescriptor</code> can be found in
<a class="xref" href="#section-constraint-descriptor" title="9.6. ConstraintDescriptor">Section 9.6, “<code class="literal">ConstraintDescriptor</code>”</a>.</p><p>Via <code class="literal">getConstraintsForProperty()</code>, <code class="literal">getConstraintsForMethod()</code> and <code class="literal">getConstraintsForConstructor()</code> you
can obtain a descriptor representing one given property or executable element, identified by its
name and, in case of methods and constructors, parameter types. The different descriptor types
returned by these methods are described in the following sections.</p><p>Note that these methods consider constraints declared at super-types according to the rules for
constraint inheritance as described in <a class="xref" href="#section-constraint-inheritance" title="2.1.5. Constraint inheritance">Section 2.1.5, “Constraint inheritance”</a>. An example is the
descriptor for the <code class="literal">manufacturer</code> property, which provides access to all constraints defined on
<code class="literal">Vehicle#getManufacturer()</code> and the implementing method <code class="literal">Car#getManufacturer()</code>. <code class="literal">null</code> is returned in
case the specified element does not exist or is not constrained.</p><p>The methods <code class="literal">getConstrainedProperties()</code>, <code class="literal">getConstrainedMethods()</code> and <code class="literal">getConstrainedConstructors()</code>
return (potentially empty) sets with all constrained properties, methods and constructors,
respectively. An element is considered constrained, if it has at least one constraint or is marked
for cascaded validation. When invoking <code class="literal">getConstrainedMethods()</code>, you can specify the type of the
methods to be returned (getters, non-getters or both).</p></div><div class="section" title="9.2. PropertyDescriptor"><div class="titlepage"><div><div><h2 class="title"><a id="section-property-descriptor"/>9.2. <code class="literal">PropertyDescriptor</code></h2></div></div></div><p>The interface
<code class="literal"><a class="link" href="http://docs.jboss.org/hibernate/beanvalidation/spec/1.1/api/index.html?javax/validation/metadata/PropertyDescriptor.html">PropertyDescriptor</a></code> represents one given property of a
class. It is transparent whether constraints are declared on a field or a property getter, provided
the JavaBeans naming conventions are respected. <a class="xref" href="#metadata-example-using-propertydescriptor" title="Example 9.3. Using PropertyDescriptor">Example 9.3, “Using <code class="literal">PropertyDescriptor</code>”</a> shows
how to use the <code class="literal">PropertyDescriptor</code> interface.</p><div class="example"><a id="metadata-example-using-propertydescriptor"/><p class="title"><strong>Example 9.3. Using <code class="literal">PropertyDescriptor</code></strong></p><div class="example-contents"><pre><code class="language-java">PropertyDescriptor licensePlateDescriptor = carDescriptor.getConstraintsForProperty(
		"licensePlate"
);

//"licensePlate" has two constraints, is not marked with @Valid and defines no group conversions
assertEquals( "licensePlate", licensePlateDescriptor.getPropertyName() );
assertEquals( 2, licensePlateDescriptor.getConstraintDescriptors().size() );
assertTrue( licensePlateDescriptor.hasConstraints() );
assertFalse( licensePlateDescriptor.isCascaded() );
assertTrue( licensePlateDescriptor.getGroupConversions().isEmpty() );

PropertyDescriptor driverDescriptor = carDescriptor.getConstraintsForProperty( "driver" );

//"driver" has no constraints, is marked with @Valid and defines one group conversion
assertEquals( "driver", driverDescriptor.getPropertyName() );
assertTrue( driverDescriptor.getConstraintDescriptors().isEmpty() );
assertFalse( driverDescriptor.hasConstraints() );
assertTrue( driverDescriptor.isCascaded() );
assertEquals( 1, driverDescriptor.getGroupConversions().size() );</code></pre></div></div><br class="example-break"/><p>Using <code class="literal">getConstrainedDescriptors()</code>, you can retrieve a set of <code class="literal">ConstraintDescriptors</code> providing more
information on the individual constraints of a given property. The method <code class="literal">isCascaded()</code> returns
<code class="literal">true</code>, if the property is marked for cascaded validation (either using the <code class="literal">@Valid</code> annotation or via
XML), <code class="literal">false</code> otherwise. Any configured group conversions are returned by <code class="literal">getGroupConversions()</code>. See
<a class="xref" href="#section-group-conversion-descriptor" title="9.5. GroupConversionDescriptor">Section 9.5, “<code class="literal">GroupConversionDescriptor</code>”</a> for more details on <code class="literal">GroupConversionDescriptor</code>.</p></div><div class="section" title="9.3. MethodDescriptor and ConstructorDescriptor"><div class="titlepage"><div><div><h2 class="title"><a id="__literal_methoddescriptor_literal_and_literal_constructordescriptor_literal"/>9.3. <code class="literal">MethodDescriptor</code> and <code class="literal">ConstructorDescriptor</code></h2></div></div></div><p>Constrained methods and constructors are represented by the interfaces
<code class="literal"><a class="link" href="http://docs.jboss.org/hibernate/beanvalidation/spec/1.1/api/index.html?javax/validation/metadata/MethodDescriptor.html">MethodDescriptor</a></code>
and <code class="literal"><a class="link" href="http://docs.jboss.org/hibernate/beanvalidation/spec/1.1/api/index.html?javax/validation/metadata/ConstructorDescriptor.html">ConstructorDescriptor</a></code>, respectively.
<a class="xref" href="#metadata-example-using-methodandconstructordescriptor" title="Example 9.4. Using MethodDescriptor and ConstructorDescriptor">Example 9.4, “Using <code class="literal">MethodDescriptor</code> and <code class="literal">ConstructorDescriptor</code>”</a> demonstrates how to work with these
descriptors.</p><div class="example"><a id="metadata-example-using-methodandconstructordescriptor"/><p class="title"><strong>Example 9.4. Using <code class="literal">MethodDescriptor</code> and <code class="literal">ConstructorDescriptor</code></strong></p><div class="example-contents"><pre><code class="language-java">//driveAway(int) has a constrained parameter and an unconstrained return value
MethodDescriptor driveAwayDescriptor = carDescriptor.getConstraintsForMethod(
		"driveAway",
		int.class
);
assertEquals( "driveAway", driveAwayDescriptor.getName() );
assertTrue( driveAwayDescriptor.hasConstrainedParameters() );
assertFalse( driveAwayDescriptor.hasConstrainedReturnValue() );

//always returns an empty set; constraints are retrievable by navigating to
//one of the sub-descriptors, e.g. for the return value
assertTrue( driveAwayDescriptor.getConstraintDescriptors().isEmpty() );

ParameterDescriptor speedDescriptor = driveAwayDescriptor.getParameterDescriptors()
		.get( 0 );

//The "speed" parameter is located at index 0, has one constraint and is not cascaded
//nor does it define group conversions
assertEquals( "arg0", speedDescriptor.getName() );
assertEquals( 0, speedDescriptor.getIndex() );
assertEquals( 1, speedDescriptor.getConstraintDescriptors().size() );
assertFalse( speedDescriptor.isCascaded() );
assert speedDescriptor.getGroupConversions().isEmpty();

//getDriver() has no constrained parameters but its return value is marked for cascaded
//validation and declares one group conversion
MethodDescriptor getDriverDescriptor = carDescriptor.getConstraintsForMethod(
		"getDriver"
);
assertFalse( getDriverDescriptor.hasConstrainedParameters() );
assertTrue( getDriverDescriptor.hasConstrainedReturnValue() );

ReturnValueDescriptor returnValueDescriptor = getDriverDescriptor.getReturnValueDescriptor();
assertTrue( returnValueDescriptor.getConstraintDescriptors().isEmpty() );
assertTrue( returnValueDescriptor.isCascaded() );
assertEquals( 1, returnValueDescriptor.getGroupConversions().size() );

//load(List&lt;Person&gt;, List&lt;PieceOfLuggage&gt;) has one cross-parameter constraint
MethodDescriptor loadDescriptor = carDescriptor.getConstraintsForMethod(
		"load",
		List.class,
		List.class
);
assertTrue( loadDescriptor.hasConstrainedParameters() );
assertFalse( loadDescriptor.hasConstrainedReturnValue() );
assertEquals(
		1,
		loadDescriptor.getCrossParameterDescriptor().getConstraintDescriptors().size()
);

//Car(String, String, Person, String) has one constrained parameter
ConstructorDescriptor constructorDescriptor = carDescriptor.getConstraintsForConstructor(
		String.class,
		String.class,
		Person.class,
		String.class
);

assertEquals( "Car", constructorDescriptor.getName() );
assertFalse( constructorDescriptor.hasConstrainedReturnValue() );
assertTrue( constructorDescriptor.hasConstrainedParameters() );
assertEquals(
		1,
		constructorDescriptor.getParameterDescriptors()
				.get( 0 )
				.getConstraintDescriptors()
				.size()
);</code></pre></div></div><br class="example-break"/><p><code class="literal">getName()</code> returns the name of the given method or constructor. The methods
<code class="literal">hasConstrainedParameters()</code> and <code class="literal">hasConstrainedReturnValue()</code> can be used to perform a quick check
whether an executable element has any parameter constraints (either constraints on single parameters
or cross-parameter constraints) or return value constraints.</p><p>Note that any constraints are not directly exposed on <code class="literal">MethodDescriptor</code> and <code class="literal">ConstructorDescriptor</code>,
but rather on dedicated descriptors representing an executable’s parameters, its return value and
its cross-parameter constraints. To get hold of one of these descriptors, invoke
<code class="literal">getParameterDescriptors()</code>, <code class="literal">getReturnValueDescriptor()</code> or <code class="literal">getCrossParameterDescriptor()</code>,
respectively.</p><p>These descriptors provide access to the element’s constraints (<code class="literal">getConstraintDescriptors()</code>) and, in
case of parameters and return value, to its configuration for cascaded validation (<code class="literal">isValid()</code> and
<code class="literal">getGroupConversions()</code>). For parameters, you also can retrieve the index and the name, as returned by
the currently used parameter name provider (see <a class="xref" href="#section-parameter-name-provider" title="8.2.4. ParameterNameProvider">Section 8.2.4, “<code class="literal">ParameterNameProvider</code>”</a>) via <code class="literal">getName()</code>
and <code class="literal">getIndex()</code>.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>Getter methods following the JavaBeans naming conventions are considered as bean properties but also
as constrained methods.</p><p>That means you can retrieve the related metadata either by obtaining a <code class="literal">PropertyDescriptor</code> (e.g.
<code class="literal">BeanDescriptor.getConstraintsForProperty("foo")</code>) or by examining the return value descriptor of the
getter’s <code class="literal">MethodDescriptor</code> (e.g.
<code class="literal">BeanDescriptor.getConstraintsForMethod("getFoo").getReturnValueDescriptor())</code>.</p></div></div><div class="section" title="9.4. ElementDescriptor"><div class="titlepage"><div><div><h2 class="title"><a id="validator-metadata-api-elementdescriptor"/>9.4. <code class="literal">ElementDescriptor</code></h2></div></div></div><p>The <code class="literal"><a class="link" href="http://docs.jboss.org/hibernate/beanvalidation/spec/1.1/api/index.html?javax/validation/metadata/ElementDescriptor.html">ElementDiscriptor</a></code>
interface is the common base class for the
individual descriptor types such as <code class="literal">BeanDescriptor</code>, <code class="literal">PropertyDescriptor</code> etc. Besides
<code class="literal">getConstraintDescriptors()</code> it provides some more methods common to all descriptors.</p><p><code class="literal">hasConstraints()</code> allows for a quick check whether an element has any direct constraints (e.g. class-
level constraints in case of <code class="literal">BeanDescriptor</code>). <code class="literal">getElementClass()</code> returns the Java type of the element
represented by a given descriptor. More specifically, the method returns</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">the object type when invoked on <code class="literal">BeanDescriptor</code>,</li><li class="listitem">the type of a property or parameter when invoked on <code class="literal">PropertyDescriptor</code> or <code class="literal">ParameterDescriptor</code>
respectively,</li><li class="listitem"><code class="literal">Object[].class</code> when invoked on <code class="literal">CrossParameterDescriptor</code>,</li><li class="listitem">the return type when invoked on <code class="literal">ConstructorDescriptor</code>, <code class="literal">MethodDescriptor</code> or <code class="literal">ReturnValueDescriptor</code>.
<code class="literal">void.class</code> will be returned for methods which don’t have a return value.</li></ul></div><p><a class="xref" href="#metadata-example-using-elementdescriptor" title="Example 9.5. Using ElementDescriptor methods">Example 9.5, “Using <code class="literal">ElementDescriptor methods</code>”</a> shows how these methods are used.</p><div class="example"><a id="metadata-example-using-elementdescriptor"/><p class="title"><strong>Example 9.5. Using <code class="literal">ElementDescriptor methods</code></strong></p><div class="example-contents"><pre><code class="language-java">PropertyDescriptor manufacturerDescriptor = carDescriptor.getConstraintsForProperty(
		"manufacturer"
);

assertTrue( manufacturerDescriptor.hasConstraints() );
assertEquals( String.class, manufacturerDescriptor.getElementClass() );

CrossParameterDescriptor loadCrossParameterDescriptor = carDescriptor.getConstraintsForMethod(
		"load",
		List.class,
		List.class
).getCrossParameterDescriptor();

assertTrue( loadCrossParameterDescriptor.hasConstraints() );
assertEquals( Object[].class, loadCrossParameterDescriptor.getElementClass() );</code></pre></div></div><br class="example-break"/><p>Finally, <code class="literal">ElementDescriptor</code> offers access to the <code class="literal">ConstraintFinder</code> API which allows you to query for
constraint metadata in a fine grained way. <a class="xref" href="#example-constraint-finder" title="Example 9.6. Usage of ConstraintFinder">Example 9.6, “Usage of <code class="literal">ConstraintFinder</code>”</a> shows how to retrieve a
<code class="literal">ConstraintFinder</code> instance via <code class="literal">findConstraints()</code> and use the API to query for constraint metadata.</p><div class="example"><a id="example-constraint-finder"/><p class="title"><strong>Example 9.6. Usage of <code class="literal">ConstraintFinder</code></strong></p><div class="example-contents"><pre><code class="language-java">PropertyDescriptor manufacturerDescriptor = carDescriptor.getConstraintsForProperty(
		"manufacturer"
);

//"manufacturer" constraints are declared on the getter, not the field
assertTrue(
		manufacturerDescriptor.findConstraints()
				.declaredOn( ElementType.FIELD )
				.getConstraintDescriptors()
				.isEmpty()
);

//@NotNull on Vehicle#getManufacturer() is part of another group
assertEquals(
		1,
		manufacturerDescriptor.findConstraints()
				.unorderedAndMatchingGroups( Default.class )
				.getConstraintDescriptors()
				.size()
);

//@Size on Car#getManufacturer()
assertEquals(
		1,
		manufacturerDescriptor.findConstraints()
				.lookingAt( Scope.LOCAL_ELEMENT )
				.getConstraintDescriptors()
				.size()
);

//@Size on Car#getManufacturer() and @NotNull on Vehicle#getManufacturer()
assertEquals(
		2,
		manufacturerDescriptor.findConstraints()
				.lookingAt( Scope.HIERARCHY )
				.getConstraintDescriptors()
				.size()
);

//Combining several filter options
assertEquals(
		1,
		manufacturerDescriptor.findConstraints()
				.declaredOn( ElementType.METHOD )
				.lookingAt( Scope.HIERARCHY )
				.unorderedAndMatchingGroups( Vehicle.Basic.class )
				.getConstraintDescriptors()
				.size()
);</code></pre></div></div><br class="example-break"/><p>Via <code class="literal">declaredOn()</code> you can search for <code class="literal">ConstraintDescriptors</code> declared on certain element types. This is
useful to find property constraints declared on either fields or getter methods.</p><p><code class="literal">unorderedAndMatchingGroups()</code> restricts the resulting constraints to those matching the given
validation group(s).</p><p><code class="literal">lookingAt()</code> allows to distinguish between constraints directly specified on the element
(<code class="literal">Scope.LOCAL_ELEMENT</code>) or constraints belonging to the element but hosted anywhere in the class
hierarchy (<code class="literal">Scope.HIERARCHY</code>).</p><p>You can also combine the different options as shown in the last example.</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2><p>Order is not respected by <code class="literal">unorderedAndMatchingGroups()</code>, but group inheritance and inheritance via
sequence are.</p></div></div><div class="section" title="9.5. GroupConversionDescriptor"><div class="titlepage"><div><div><h2 class="title"><a id="section-group-conversion-descriptor"/>9.5. <code class="literal">GroupConversionDescriptor</code></h2></div></div></div><p>All those descriptor types that represent elements which can be subject of cascaded validation
(i.e., <code class="literal">PropertyDescriptor</code>, <code class="literal">ParameterDescriptor</code> and <code class="literal">ReturnValueDescriptor</code>) provide access to the
element’s group conversions via <code class="literal">getGroupConversions()</code>. The returned set contains a
<code class="literal"><a class="link" href="http://docs.jboss.org/hibernate/beanvalidation/spec/1.1/api/index.html?javax/validation/metadata/GroupConversionDescriptor.html">GroupConversionDescriptor</a></code>
for each configured conversion, allowing to retrieve
source and target groups of the conversion. <a class="xref" href="#metadata-example-using-groupconversiondescriptor" title="Example 9.7. Using GroupConversionDescriptor">Example 9.7, “Using <code class="literal">GroupConversionDescriptor</code>”</a>
shows an example.</p><div class="example"><a id="metadata-example-using-groupconversiondescriptor"/><p class="title"><strong>Example 9.7. Using <code class="literal">GroupConversionDescriptor</code></strong></p><div class="example-contents"><pre><code class="language-java">PropertyDescriptor driverDescriptor = carDescriptor.getConstraintsForProperty( "driver" );

Set&lt;GroupConversionDescriptor&gt; groupConversions = driverDescriptor.getGroupConversions();
assertEquals( 1, groupConversions.size() );

GroupConversionDescriptor groupConversionDescriptor = groupConversions.iterator()
		.next();
assertEquals( Default.class, groupConversionDescriptor.getFrom() );
assertEquals( Person.Basic.class, groupConversionDescriptor.getTo() );</code></pre></div></div><br class="example-break"/></div><div class="section" title="9.6. ConstraintDescriptor"><div class="titlepage"><div><div><h2 class="title"><a id="section-constraint-descriptor"/>9.6. <code class="literal">ConstraintDescriptor</code></h2></div></div></div><p>Last but not least, the
<code class="literal"><a class="link" href="http://docs.jboss.org/hibernate/beanvalidation/spec/1.1/api/index.html?javax/validation/metadata/ConstraintDescriptor.html">ConstraintDescriptor</a></code>
interface describes a
single constraint together with its composing constraints. Via an instance of this interface you get
access to the constraint annotation and its parameters.</p><p><a class="xref" href="#metadata-example-using-constraintdescriptor" title="Example 9.8. Using ConstraintDescriptor">Example 9.8, “Using <code class="literal">ConstraintDescriptor</code>”</a>
shows how to retrieve default constraint attributes (such as message template, groups etc.) as well
as custom constraint attributes (<code class="literal">piecesOfLuggagePerPassenger</code>) and other metadata such as the
constraint’s annotation type and its validators from a <code class="literal">ConstraintDescriptor</code>.</p><div class="example"><a id="metadata-example-using-constraintdescriptor"/><p class="title"><strong>Example 9.8. Using <code class="literal">ConstraintDescriptor</code></strong></p><div class="example-contents"><pre><code class="language-java">//descriptor for the @LuggageCountMatchesPassengerCount constraint on the
//load(List&lt;Person&gt;, List&lt;PieceOfLuggage&gt;) method
ConstraintDescriptor&lt;?&gt; constraintDescriptor = carDescriptor.getConstraintsForMethod(
		"load",
		List.class,
		List.class
).getCrossParameterDescriptor().getConstraintDescriptors().iterator().next();

//constraint type
assertEquals(
		LuggageCountMatchesPassengerCount.class,
		constraintDescriptor.getAnnotation().annotationType()
);

//standard constraint attributes
assertEquals( SeverityInfo.class, constraintDescriptor.getPayload().iterator().next() );
assertEquals(
		ConstraintTarget.PARAMETERS,
		constraintDescriptor.getValidationAppliesTo()
);
assertEquals( Default.class, constraintDescriptor.getGroups().iterator().next() );
assertEquals(
		"There must not be more than {piecesOfLuggagePerPassenger} pieces of luggage per " +
		"passenger.",
		constraintDescriptor.getMessageTemplate()
);

//custom constraint attribute
assertEquals(
		2,
		constraintDescriptor.getAttributes().get( "piecesOfLuggagePerPassenger" )
);

//no composing constraints
assertTrue( constraintDescriptor.getComposingConstraints().isEmpty() );

//validator class
assertEquals(
		Arrays.&lt;Class&lt;?&gt;&gt;asList( LuggageCountMatchesPassengerCount.Validator.class ),
		constraintDescriptor.getConstraintValidatorClasses()
);</code></pre></div></div><br class="example-break"/></div></div><div class="chapter" title="Chapter 10. Integrating with other frameworks"><div class="titlepage"><div><div><h2 class="title"><a id="validator-integration"/>Chapter 10. Integrating with other frameworks</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#validator-checkconstraints-orm">10.1. ORM integration</a></span></dt><dd><dl><dt><span class="section"><a href="#validator-checkconstraints-db">10.1.1. Database schema-level validation</a></span></dt><dt><span class="section"><a href="#validator-checkconstraints-orm-hibernateevent">10.1.2. Hibernate event-based validation</a></span></dt><dt><span class="section"><a href="#_jpa">10.1.3. JPA</a></span></dt></dl></dd><dt><span class="section"><a href="#section-presentation-layer">10.2. JSF &amp; Seam</a></span></dt><dt><span class="section"><a href="#section-integration-with-cdi">10.3. CDI</a></span></dt><dd><dl><dt><span class="section"><a href="#_dependency_injection">10.3.1. Dependency injection</a></span></dt><dt><span class="section"><a href="#_method_validation">10.3.2. Method validation</a></span></dt></dl></dd><dt><span class="section"><a href="#_java_ee">10.4. Java EE</a></span></dt><dt><span class="section"><a href="#_javafx">10.5. JavaFX</a></span></dt></dl></div><p>Hibernate Validator is intended to be used to implement multi-layered data validation, where
constraints are expressed in a single place (the annotated domain model) and checked in various
different layers of the application. For this reason there are multiple integration points with
other technologies.</p><div class="section" title="10.1. ORM integration"><div class="titlepage"><div><div><h2 class="title"><a id="validator-checkconstraints-orm"/>10.1. ORM integration</h2></div></div></div><p>Hibernate Validator integrates with both Hibernate and all pure Java Persistence providers.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>When lazy loaded associations are supposed to be validated it is recommended to place the constraint
on the getter of the association. Hibernate replaces lazy loaded associations with proxy instances
which get initialized/loaded when requested via the getter. If, in such a case, the constraint is
placed on field level the actual proxy instance is used which will lead to validation errors.</p></div><div class="section" title="10.1.1. Database schema-level validation"><div class="titlepage"><div><div><h3 class="title"><a id="validator-checkconstraints-db"/>10.1.1. Database schema-level validation</h3></div></div></div><p>Out of the box, Hibernate (as of version 3.5.x) will translate the constraints you have defined for
your entities into mapping metadata. For example, if a property of your entity is annotated
<code class="literal">@NotNull</code>, its columns will be declared as <code class="literal">not null</code> in the DDL schema generated by Hibernate.</p><p>If, for some reason, the feature needs to be disabled, set <code class="literal">hibernate.validator.apply_to_ddl</code> to
<code class="literal">false</code>. See also <a class="xref" href="#table-spec-constraints" title="Table 2.2. Bean Validation constraints">Table 2.2, “Bean Validation constraints”</a> and <a class="xref" href="#table-custom-constraints" title="Table 2.3. Custom constraints">Table 2.3, “Custom constraints”</a>.</p><p>You can also limit the DDL constraint generation to a subset of the defined constraints by setting
the property <code class="literal">org.hibernate.validator.group.ddl</code>. The property specifies the comma-separated, fully
specified class names of the groups a constraint has to be part of in order to be considered for DDL
schema generation.</p></div><div class="section" title="10.1.2. Hibernate event-based validation"><div class="titlepage"><div><div><h3 class="title"><a id="validator-checkconstraints-orm-hibernateevent"/>10.1.2. Hibernate event-based validation</h3></div></div></div><p>Hibernate Validator has a built-in Hibernate event listener -
<code class="literal"><a class="link" href="https://github.com/hibernate/hibernate-orm/blob/master/hibernate-core/src/main/java/org/hibernate/cfg/beanvalidation/BeanValidationEventListener.java">org.hibernate.cfg.beanvalidation.BeanValidationEventListener</a></code> -
which is part of Hibernate ORM. Whenever a <code class="literal">PreInsertEvent</code>,
<code class="literal">PreUpdateEvent</code> or <code class="literal">PreDeleteEvent</code> occurs, the listener will verify all constraints of the entity
instance and throw an exception if any constraint is violated. Per default objects will be checked
before any inserts or updates are made by Hibernate. Pre deletion events will per default not
trigger a validation. You can configure the groups to be validated per event type using the
properties <code class="literal">javax.persistence.validation.group.pre-persist</code>,
<code class="literal">javax.persistence.validation.group.pre-update</code> and <code class="literal">javax.persistence.validation.group.pre-remove</code>.
The values of these properties are the comma-separated, fully specified class names of the groups
to validate. <a class="xref" href="#example-beanvalidationeventlistener-config" title="Example 10.1. Manual configuration of BeanValidationEvenListener">Example 10.1, “Manual configuration of <code class="literal">BeanValidationEvenListener</code>”</a> shows the default values for these
properties. In this case they could also be omitted.</p><p>On constraint violation, the event will raise a runtime <code class="literal">ConstraintViolationException</code> which contains
a set of <code class="literal">ConstraintViolation</code> instances describing each failure.</p><p>If Hibernate Validator is present in the classpath, Hibernate ORM will use it transparently.
To avoid validation even though Hibernate Validator is in the classpath set
<code class="literal">javax.persistence.validation.mode</code> to none.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>If the beans are not annotated with validation annotations, there is no runtime performance cost.</p></div><p>In case you need to manually set the event listeners for Hibernate ORM, use the following
configuration in <span class="emphasis"><em>hibernate.cfg.xml</em></span>:</p><div class="example"><a id="example-beanvalidationeventlistener-config"/><p class="title"><strong>Example 10.1. Manual configuration of <code class="literal">BeanValidationEvenListener</code></strong></p><div class="example-contents"><pre><code class="language-xml">&lt;hibernate-configuration&gt;
    &lt;session-factory&gt;
        ...
        &lt;property name="javax.persistence.validation.group.pre-persist"&gt;
            javax.validation.groups.Default
        &lt;/property&gt;
        &lt;property name="javax.persistence.validation.group.pre-update"&gt;
            javax.validation.groups.Default
        &lt;/property&gt;
        &lt;property name="javax.persistence.validation.group.pre-remove"&gt;&lt;/property&gt;
        ...
        &lt;event type="pre-update"&gt;
            &lt;listener class="org.hibernate.cfg.beanvalidation.BeanValidationEventListener"/&gt;
        &lt;/event&gt;
        &lt;event type="pre-insert"&gt;
            &lt;listener class="org.hibernate.cfg.beanvalidation.BeanValidationEventListener"/&gt;
        &lt;/event&gt;
        &lt;event type="pre-delete"&gt;
            &lt;listener class="org.hibernate.cfg.beanvalidation.BeanValidationEventListener"/&gt;
        &lt;/event&gt;
    &lt;/session-factory&gt;
&lt;/hibernate-configuration&gt;</code></pre></div></div><br class="example-break"/></div><div class="section" title="10.1.3. JPA"><div class="titlepage"><div><div><h3 class="title"><a id="_jpa"/>10.1.3. JPA</h3></div></div></div><p>If you are using JPA 2 and Hibernate Validator is in the classpath the JPA2 specification requires
that Bean Validation gets enabled. The properties <code class="literal">javax.persistence.validation.group.pre-persist</code>,
<code class="literal">javax.persistence.validation.group.pre-update</code> and <code class="literal">javax.persistence.validation.group.pre-remove</code> as
described in <a class="xref" href="#validator-checkconstraints-orm-hibernateevent" title="10.1.2. Hibernate event-based validation">Section 10.1.2, “Hibernate event-based validation”</a> can in this case be configured in
<span class="emphasis"><em>persistence.xml</em></span>. <span class="emphasis"><em>persistence.xml</em></span> also defines a node validation-mode which can be set to <code class="literal">AUTO</code>,
<code class="literal">CALLBACK</code>, <code class="literal">NONE</code>. The default is <code class="literal">AUTO</code>.</p><p>In a JPA 1 you will have to create and register Hibernate Validator yourself. In case you are using
Hibernate EntityManager you can add a customized version of the <code class="literal">BeanValidationEventListener</code>
described in <a class="xref" href="#validator-checkconstraints-orm-hibernateevent" title="10.1.2. Hibernate event-based validation">Section 10.1.2, “Hibernate event-based validation”</a> to your project and register it
manually.</p></div></div><div class="section" title="10.2. JSF &amp; Seam"><div class="titlepage"><div><div><h2 class="title"><a id="section-presentation-layer"/>10.2. JSF &amp; Seam</h2></div></div></div><p>When working with JSF2 or JBoss Seam and Hibernate Validator (Bean Validation) is present in the
runtime environment, validation is triggered for every field in the application. <a class="xref" href="#example-jsf2" title="Example 10.2. Usage of Bean Validation within JSF2">Example 10.2, “Usage of Bean Validation within JSF2”</a>
shows an example of the <code class="literal">f:validateBean</code> tag in a JSF page. The <code class="literal">validationGroups</code> attribute is optional
and can be used to specify a comma separated list of validation groups. The default is
<code class="literal">javax.validation.groups.Default</code>. For more information refer to the Seam documentation or the JSF 2
specification.</p><div class="example"><a id="example-jsf2"/><p class="title"><strong>Example 10.2. Usage of Bean Validation within JSF2</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;h:form&gt;

  &lt;f:validateBean validationGroups="javax.validation.groups.Default"&gt;

    &lt;h:inputText value=#{model.property}/&gt;
    &lt;h:selectOneRadio value=#{model.radioProperty}&gt; ... &lt;/h:selectOneRadio&gt;
    &lt;!-- other input components here --&gt;

  &lt;/f:validateBean&gt;

&lt;/h:form&gt;</code></pre></div></div><br class="example-break"/><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>The integration between JSF 2 and Bean Validation is described in the "Bean Validation Integration"
chapter of <a class="link" href="http://jcp.org/en/jsr/detail?id=314">JSR-314</a>. It is interesting to know that JSF
2 implements a custom <code class="literal">MessageInterpolator</code> to ensure ensure proper localization. To encourage the use
of the Bean Validation message facility, JSF 2 will per default only display the generated Bean
Validation message. This can, however, be configured via the application resource bundle by
providing the following configuration (<code class="literal">{0}</code> is replaced with the Bean Validation message and <code class="literal">{1}</code> is
replaced with the JSF component label):</p><pre class="screen">javax.faces.validator.BeanValidator.MESSAGE={1}: {0}</pre><p>The default is:</p><pre class="screen">javax.faces.validator.BeanValidator.MESSAGE={0}</pre></div></div><div class="section" title="10.3. CDI"><div class="titlepage"><div><div><h2 class="title"><a id="section-integration-with-cdi"/>10.3. CDI</h2></div></div></div><p>As of version 1.1, Bean Validation is integrated with CDI (Contexts and Dependency Injection for
Java<sup>TM</sup> EE).</p><p>This integration provides CDI managed beans for <code class="literal">Validator</code> and <code class="literal">ValidatorFactory</code> and enables
dependency injection in constraint validators as well as custom message interpolators, traversable
resolvers, constraint validator factories and parameter name providers.</p><p>Furthermore, parameter and return value constraints on the methods and constructors of CDI managed
beans will automatically be validated upon invocation.</p><p>When your application runs on a Jave EE container, this integration is enabled by default. When
working with CDI in a Servlet container or in a pure Java SE environment, you can use the CDI
portable extension provided by Hibernate Validator. To do so, add the portable extension to your
class path as described in <a class="xref" href="#section-getting-started-cdi" title="1.1.2. CDI">Section 1.1.2, “CDI”</a>.</p><div class="section" title="10.3.1. Dependency injection"><div class="titlepage"><div><div><h3 class="title"><a id="_dependency_injection"/>10.3.1. Dependency injection</h3></div></div></div><p>CDI’s dependency injection mechanism makes it very easy to retrieve <code class="literal">ValidatorFactory</code> and <code class="literal">Validator</code>
instances and use them in your managed beans. Just annotate instance fields of your bean with
<code class="literal">@javax.inject.Inject</code> as shown in <a class="xref" href="#example-dependency-injection" title="Example 10.3. Retrieving validator factory and validator via @Inject">Example 10.3, “Retrieving validator factory and validator via <code class="literal">@Inject</code>”</a>.</p><div class="example"><a id="example-dependency-injection"/><p class="title"><strong>Example 10.3. Retrieving validator factory and validator via <code class="literal">@Inject</code></strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter10.cdi.validator;

@ApplicationScoped
public class RentalStation {

	@Inject
	private ValidatorFactory validatorFactory;

	@Inject
	private Validator validator;

	//...
}</code></pre></div></div><br class="example-break"/><p>The injected beans are the default validator factory and validator instances. In order to configure
them - e.g. to use a custom message interpolator - you can use the Bean Validation XML descriptors
as discussed in <a class="xref" href="#chapter-xml-configuration" title="Chapter 7. Configuring via XML">Chapter 7, <em>Configuring via XML</em></a>.</p><p>If you are working with several Bean Validation providers you can make sure that factory and
validator from Hibernate Validator are injected by annotating the injection points with the
<code class="literal">@HibernateValidator</code> qualifier which is demonstrated in <a class="xref" href="#example-dependency-injection-using-hv" title="Example 10.4. Using the @HibernateValidator qualifier annotation">Example 10.4, “Using the <code class="literal">@HibernateValidator</code> qualifier annotation”</a>.</p><div class="example"><a id="example-dependency-injection-using-hv"/><p class="title"><strong>Example 10.4. Using the <code class="literal">@HibernateValidator</code> qualifier annotation</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter10.cdi.validator.qualifier;

@ApplicationScoped
public class RentalStation {

	@Inject
	@HibernateValidator
	private ValidatorFactory validatorFactory;

	@Inject
	@HibernateValidator
	private Validator validator;

	//...
}</code></pre></div></div><br class="example-break"/><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>The fully-qualified name of the qualifier annotation is
<code class="literal">org.hibernate.validator.cdi.HibernateValidator</code>. Be sure to not import
<code class="literal">org.hibernate.validator.HibernateValidator</code> instead which is the <code class="literal">ValidationProvider</code> implementation
used for selecting Hibernate Validator when working with the bootstrapping API (see
<a class="xref" href="#section-retrieving-validator-factory-validator" title="8.1. Retrieving ValidatorFactory and Validator">Section 8.1, “Retrieving <code class="literal">ValidatorFactory</code> and <code class="literal">Validator</code>”</a>).</p></div><p>Via <code class="literal">@Inject</code> you also can inject dependencies into constraint validators and other Bean Validation
objects such as <code class="literal">MessageInterpolator</code> implementations etc.</p><p><a class="xref" href="#example-constraint-validator-injected-bean" title="Example 10.5. Constraint validator with injected bean">Example 10.5, “Constraint validator with injected bean”</a>
demonstrates how an injected CDI bean is used in a <code class="literal">ConstraintValidator</code> implementation to determine
whether the given constraint is valid or not. As the example shows, you also can work with the
<code class="literal">@PostConstruct</code> and <code class="literal">@PreDestroy</code> callbacks to implement any required construction and destruction
logic.</p><div class="example"><a id="example-constraint-validator-injected-bean"/><p class="title"><strong>Example 10.5. Constraint validator with injected bean</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter10.cdi.injection;

public class ValidLicensePlateValidator
		implements ConstraintValidator&lt;ValidLicensePlate, String&gt; {

	@Inject
	private VehicleRegistry vehicleRegistry;

	@PostConstruct
	public void postConstruct() {
		//do initialization logic...
	}

	@PreDestroy
	public void preDestroy() {
		//do destruction logic...
	}

	@Override
	public void initialize(ValidLicensePlate constraintAnnotation) {
	}

	@Override
	public boolean isValid(String licensePlate, ConstraintValidatorContext constraintContext) {
		return vehicleRegistry.isValidLicensePlate( licensePlate );
	}
}</code></pre></div></div><br class="example-break"/></div><div class="section" title="10.3.2. Method validation"><div class="titlepage"><div><div><h3 class="title"><a id="_method_validation"/>10.3.2. Method validation</h3></div></div></div><p>The method interception facilities of CDI allow for a very tight integration with Bean Validation’s
method validation functionality. Just put constraint annotations to the parameters and return values
of the executables of your CDI beans and they will be validated automatically before (parameter
constraints) and after (return value constraints) a method or constructor is invoked.</p><p>Note that no explicit interceptor binding is required, instead the required method validation
interceptor will automatically be registered for all managed beans with constrained methods and
constructors.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>The interceptor <code class="literal">org.hibernate.validator.internal.cdi.interceptor.ValidationInterceptor</code> is
registered by <code class="literal">org.hibernate.validator.internal.cdi.ValidationExtension</code>. This happens implicitly
within a Java EE 7 runtime environment or explicitly by adding the <span class="emphasis"><em>hibernate-validator-cdi</em></span> artifact
- see <a class="xref" href="#section-getting-started-cdi" title="1.1.2. CDI">Section 1.1.2, “CDI”</a></p></div><p>You can see an example in <a class="xref" href="#example-cdi-method-validation" title="Example 10.6. CDI managed beans with method-level constraints">Example 10.6, “CDI managed beans with method-level constraints”</a>.</p><div class="example"><a id="example-cdi-method-validation"/><p class="title"><strong>Example 10.6. CDI managed beans with method-level constraints</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter10.cdi.methodvalidation;

@ApplicationScoped
public class RentalStation {

	@Valid
	public RentalStation() {
		//...
	}

	@NotNull
	@Valid
	public Car rentCar(
			@NotNull Customer customer,
			@NotNull @Future Date startDate,
			@Min(1) int durationInDays) {
		//...
	}

	@NotNull
	List&lt;Car&gt; getAvailableCars() {
		//...
	}
}</code></pre><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter10.cdi.methodvalidation;

@RequestScoped
public class RentCarRequest {

	@Inject
	private RentalStation rentalStation;

	public void rentCar(String customerId, Date startDate, int duration) {
		//causes ConstraintViolationException
		rentalStation.rentCar( null, null, -1 );
	}
}</code></pre></div></div><br class="example-break"/><p>Here the <code class="literal">RentalStation</code> bean hosts several method constraints. When invoking one of the <code class="literal">RentalStation</code>
methods from another bean such as <code class="literal">RentCarRequest</code>, the constraints of the invoked method are
automatically validated. If any illegal parameter values are passed as in the example, a
<code class="literal">ConstraintViolationException</code> will be thrown by the method interceptor, providing detailed
information on the violated constraints. The same is the case if the method’s return value violates
any return value constraints.</p><p>Similarly, constructor constraints are validated automatically upon invocation. In the example the
<code class="literal">RentalStation</code> object returned by the constructor will be validated since the constructor return
value is marked with <code class="literal">@Valid</code>.</p><div class="section" title="10.3.2.1. Validated executable types"><div class="titlepage"><div><div><h4 class="title"><a id="_validated_executable_types"/>10.3.2.1. Validated executable types</h4></div></div></div><p>Bean Validation allows for a fine-grained control of the executable types which are automatically
validated. By default, constraints on constructors and non-getter methods are validated. Therefore
the <code class="literal">@NotNull</code> constraint on the method <code class="literal">RentalStation#getAvailableCars()</code> in
<a class="xref" href="#example-cdi-method-validation" title="Example 10.6. CDI managed beans with method-level constraints">Example 10.6, “CDI managed beans with method-level constraints”</a> gets not validated when the method is invoked.</p><p>You have the following options to configure which types of executables are validated upon
invocation:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Configure the executable types globally via the XML descriptor <span class="emphasis"><em>META-INF/validation.xml</em></span>;
see <a class="xref" href="#section-configuration-validation-xml" title="7.1. Configuring the validator factory in validation.xml">Section 7.1, “Configuring the validator factory in <span class="emphasis"><em>validation.xml</em></span>”</a> for an example</li><li class="listitem">Use the <code class="literal">@ValidateOnExecution</code> annotation on the executable or type level</li></ul></div><p>If several sources of configuration are specified for a given executable, <code class="literal">@ValidateOnExecutionn on
the executable level takes precedence over `@ValidateOnExecution</code> on the type level and
<code class="literal">@ValidateOnExecution</code> generally takes precedence over the globally configured types in <span class="emphasis"><em>META-
INF/validation.xml</em></span>.</p><p><a class="xref" href="#example-using-validateonexecution" title="Example 10.7. Using @ValidateOnExecution">Example 10.7, “Using <code class="literal">@ValidateOnExecution</code>”</a> shows how to use the <code class="literal">@ValidateOnExecution</code> annotation:</p><div class="example"><a id="example-using-validateonexecution"/><p class="title"><strong>Example 10.7. Using <code class="literal">@ValidateOnExecution</code></strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter10.cdi.methodvalidation.configuration;

@ApplicationScoped
@ValidateOnExecution(type = ExecutableType.ALL)
public class RentalStation {

	@Valid
	public RentalStation() {
		//...
	}

	@NotNull
	@Valid
	@ValidateOnExecution(type = ExecutableType.NONE)
	public Car rentCar(
			@NotNull Customer customer,
			@NotNull @Future Date startDate,
			@Min(1) int durationInDays) {
		//...
	}

	@NotNull
	public List&lt;Car&gt; getAvailableCars() {
		//...
	}
}</code></pre></div></div><br class="example-break"/><p>Here the method <code class="literal">rentCar()</code> won’t be validated upon invocation because it is annotated with
<code class="literal">@ValidateOnExecution(type = ExecutableType.NONE)</code>. In contrast, the constructor and the
method <code class="literal">getAvailableCars()</code> will be validated due to <code class="literal">@ValidateOnExecution(type =
ExecutableType.ALL)</code> being given on the type level. <code class="literal">ExecutableType.ALL</code> is a more compact form for
explicitly specifying all the types <code class="literal">CONSTRUCTORS</code>, <code class="literal">GETTER_METHODS</code> and <code class="literal">NON_GETTER_METHODS</code>.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>Executable validation can be turned off globally by specifying
<code class="literal">&lt;executable-validation enabled="false"/&gt;</code> in <span class="emphasis"><em>META-INF/validation.xml</em></span>. In this case, any
<code class="literal">@ValidateOnExecution</code> annotations are ignored.</p></div><p>Note that when a method overrides or implements a super-type method the configuration will be taken
from that overridden or implemented method (as given via <code class="literal">@ValidateOnExecution</code> on the method itself
or on the super-type). This protects a client of the super-type method from an unexpected alteration
of the configuration, e.g. disabling validation of an overridden executable in a sub-type.</p><p>In case a CDI managed bean overrides or implements a super-type method and this super-type method
hosts any constraints, it can happen that the validation interceptor is not properly registered with
the bean, resulting in the bean’s methods not being validated upon invocation. In this case you can
specify the executable type <code class="literal">IMPLICIT</code> on the sub-class as shown in
<a class="xref" href="#example-using-executabletype-implicit" title="Example 10.8. Using ExecutableType.IMPLICIT">Example 10.8, “Using <code class="literal">ExecutableType.IMPLICIT</code>”</a>, which makes sure that all required metadata is discovered
an the validation interceptor kicks in when the methods on <code class="literal">ExpressRentalStation</code> are invoked.</p><div class="example"><a id="example-using-executabletype-implicit"/><p class="title"><strong>Example 10.8. Using <code class="literal">ExecutableType.IMPLICIT</code></strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter10.cdi.methodvalidation.implicit;

@ValidateOnExecution(type = ExecutableType.ALL)
public interface RentalStation {

	@NotNull
	@Valid
	Car rentCar(
			@NotNull Customer customer,
			@NotNull @Future Date startDate,
			@Min(1) int durationInDays);
}</code></pre><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter10.cdi.methodvalidation.implicit;

@ApplicationScoped
@ValidateOnExecution(type = ExecutableType.IMPLICIT)
public class ExpressRentalStation implements RentalStation {

	@Override
	public Car rentCar(Customer customer, Date startDate, @Min(1) int durationInDays) {
		//...
	}
}</code></pre></div></div><br class="example-break"/></div></div></div><div class="section" title="10.4. Java EE"><div class="titlepage"><div><div><h2 class="title"><a id="_java_ee"/>10.4. Java EE</h2></div></div></div><p>When your application runs on a Java EE application server such as <a class="link" href="WildFly"/><a class="link" href="http://wildfly.org/">http://wildfly.org/</a><a class="link" href="WildFly"/>,
you also can obtain <code class="literal">Validator</code> and <code class="literal">ValidatorFactory</code> instances via <code class="literal">@Resource</code> injection in
managed objects such as EJBs etc., as shown in <a class="xref" href="#example-validator-resource-injection" title="Example 10.9. Retrieving Validator and ValidatorFactory via @Resource injection">Example 10.9, “Retrieving <code class="literal">Validator</code> and <code class="literal">ValidatorFactory</code> via <code class="literal">@Resource</code> injection”</a>.</p><div class="example"><a id="example-validator-resource-injection"/><p class="title"><strong>Example 10.9. Retrieving <code class="literal">Validator</code> and <code class="literal">ValidatorFactory</code> via <code class="literal">@Resource</code> injection</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter10.javaee;

@Stateless
public class RentalStationBean {

	@Resource
	private ValidatorFactory validatorFactory;

	@Resource
	private Validator validator;

	//...
}</code></pre></div></div><br class="example-break"/><p>Alternatively you can obtain a validator and a validator factory from JNDI under the names
"<span class="emphasis"><em>java:comp/Validator</em></span>" and "<span class="emphasis"><em>java:comp/ValidatorFactory</em></span>", respectively.</p><p>Similar to CDI-based injection via <code class="literal">@Inject</code>, these objects represent default validator and validator
factory and thus can be configured using the XML descriptor <span class="emphasis"><em>META-INF/validation.xml</em></span> (see
<a class="xref" href="#chapter-xml-configuration" title="Chapter 7. Configuring via XML">Chapter 7, <em>Configuring via XML</em></a>).</p><p>When your application is CDI-enabled, the injected objects are CDI-aware as well and e.g. support
dependency injection in constraint validators.</p></div><div class="section" title="10.5. JavaFX"><div class="titlepage"><div><div><h2 class="title"><a id="_javafx"/>10.5. JavaFX</h2></div></div></div><p>Hibernate Validator also provides support for the unwrapping of JavaFX properties. If JavaFX is present
on the classpath a <code class="literal">ValidatedValueUnwrapper</code> for JavaFX properties is automatically registered. In some
cases, however, it is also necessary to explicitly use <code class="literal">@UnwrapValidatedValue</code>. This is required if
the constraint validator resolution is not unique and there is a potential constraint validator for
the actual JavaFX property as well as the contained property value itself.
See <a class="xref" href="#section-javafx-unwrapper" title="11.11.2. JavaFX unwrapper">Section 11.11.2, “JavaFX unwrapper”</a> for examples and further discussion.</p></div></div><div class="chapter" title="Chapter 11. Hibernate Validator Specifics"><div class="titlepage"><div><div><h2 class="title"><a id="validator-specifics"/>Chapter 11. Hibernate Validator Specifics</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#_public_api">11.1. Public API</a></span></dt><dt><span class="section"><a href="#section-fail-fast">11.2. Fail fast mode</a></span></dt><dt><span class="section"><a href="#section-programmatic-api">11.3. Programmatic constraint declaration</a></span></dt><dt><span class="section"><a href="#section-programmatic-api-contributor">11.4. Applying programmatic constraint declarations to the default validator factory</a></span></dt><dt><span class="section"><a href="#section-advanced-constraint-composition">11.5. Advanced constraint composition features</a></span></dt><dd><dl><dt><span class="section"><a href="#_validation_target_specification_for_purely_composed_constraints">11.5.1. Validation target specification for purely composed constraints</a></span></dt><dt><span class="section"><a href="#section-boolean-constraint-composition">11.5.2. Boolean composition of constraints</a></span></dt></dl></dd><dt><span class="section"><a href="#section-extensions-path-api">11.6. Extensions of the Path API</a></span></dt><dt><span class="section"><a href="#non-el-message-interpolator">11.7. <code class="literal">ParameterMessageInterpolator</code></a></span></dt><dt><span class="section"><a href="#__literal_resourcebundlelocator_literal">11.8. <code class="literal">ResourceBundleLocator</code></a></span></dt><dt><span class="section"><a href="#_custom_contexts">11.9. Custom contexts</a></span></dt><dd><dl><dt><span class="section"><a href="#section-hibernateconstraintvalidatorcontext">11.9.1. <code class="literal">HibernateConstraintValidatorContext</code></a></span></dt><dt><span class="section"><a href="#__literal_hibernatemessageinterpolatorcontext_literal">11.9.2. <code class="literal">HibernateMessageInterpolatorContext</code></a></span></dt></dl></dd><dt><span class="section"><a href="#section-paranamer-parameternameprovider">11.10. ParaNamer based <code class="literal">ParameterNameProvider</code></a></span></dt><dt><span class="section"><a href="#section-value-handling">11.11. Unwrapping values</a></span></dt><dd><dl><dt><span class="section"><a href="#section-optional-unwrapper">11.11.1. Optional unwrapper</a></span></dt><dt><span class="section"><a href="#section-javafx-unwrapper">11.11.2. JavaFX unwrapper</a></span></dt><dt><span class="section"><a href="#_unwrapping_object_graphs">11.11.3. Unwrapping object graphs</a></span></dt></dl></dd><dt><span class="section"><a href="#section-constraint-definition-contribution">11.12. Providing constraint definitions</a></span></dt><dd><dl><dt><span class="section"><a href="#_constraint_definitions_via_literal_serviceloader_literal">11.12.1. Constraint definitions via <code class="literal">ServiceLoader</code></a></span></dt><dt><span class="section"><a href="#section-constraint-definition-contributor">11.12.2. Constraint definitions via <code class="literal">ConstraintDefinitionContributor</code></a></span></dt></dl></dd><dt><span class="section"><a href="#section-constraint-customizing-class-loading">11.13. Customizing class-loading</a></span></dt><dt><span class="section"><a href="#section-time-provider">11.14. Time providers for <code class="literal">@Future</code> and <code class="literal">@Past</code></a></span></dt></dl></div><p>In this chapter you will learn how to make use of several features provided by Hibernate Validator
in addition to the functionality defined by the Bean Validation specification. This includes the
fail fast mode, the API for programmatic constraint configuration and the boolean composition of
constraints.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>Using the features described in the following sections may result in application code which is not
portable between Bean Validation providers.</p></div><div class="section" title="11.1. Public API"><div class="titlepage"><div><div><h2 class="title"><a id="_public_api"/>11.1. Public API</h2></div></div></div><p>Let’s start, however, with a look at the public API of Hibernate Validator. <a class="xref" href="#validator-public-api" title="Table 11.1. Hibernate Validator public API">Table 11.1, “Hibernate Validator public API”</a>
lists all packages belonging to this API and describes their purpose. Note that when a package is
part of the public this is not necessarily true for its sub-packages.</p><div class="table"><a id="validator-public-api"/><p class="title"><strong>Table 11.1. Hibernate Validator public API</strong></p><div class="table-contents"><table summary="Hibernate Validator public API" border="1"><colgroup><col width="50*" class="col_1"/><col width="50*" class="col_2"/></colgroup><thead><tr><th align="left" valign="top">Packages</th><th align="left" valign="top">Description</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">org.hibernate.validator</code></p></td><td align="left" valign="top"><p>Classes used by the Bean Validation bootstrap mechanism
            (eg. validation provider, configuration class); For more details
            see <a class="xref" href="#chapter-bootstrapping" title="Chapter 8. Bootstrapping">Chapter 8, <em>Bootstrapping</em></a>.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">org.hibernate.validator.cfg</code>,
            <code class="literal">org.hibernate.validator.cfg.context</code>,
            <code class="literal">org.hibernate.validator.cfg.defs</code>,
            <code class="literal">org.hibernate.validator.spi.cfg</code></p></td><td align="left" valign="top"><p>Hibernate Validator’s fluent API for constraint
            declaration; In <code class="literal">org.hibernate.validator.cfg</code> you
            will find the <code class="literal">ConstraintMapping</code> interface,
            in <code class="literal">org.hibernate.validator.cfg.defs</code> all
            constraint definitions and in <code class="literal">org.hibernate.validator.spi.cfg</code> a
            callback for using the API for configuring the default validator factory.
            Refer to <a class="xref" href="#section-programmatic-api" title="11.3. Programmatic constraint declaration">Section 11.3, “Programmatic constraint declaration”</a> for the details.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">org.hibernate.validator.constraints</code>,
            <code class="literal">org.hibernate.validator.constraints.br</code></p></td><td align="left" valign="top"><p>Some useful custom constraints provided by Hibernate
            Validator in addition to the built-in constraints defined by the
            Bean Validation specification; The constraints are described in
            detail in <a class="xref" href="#validator-defineconstraints-hv-constraints" title="2.3.2. Additional constraints">Section 2.3.2, “Additional constraints”</a>.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">org.hibernate.validator.constraintvalidation</code></p></td><td align="left" valign="top"><p>Extended constraint validator context which allows to set
            custom attributes for message interpolation. <a class="xref" href="#section-hibernateconstraintvalidatorcontext" title="11.9.1. HibernateConstraintValidatorContext">Section 11.9.1, “<code class="literal">HibernateConstraintValidatorContext</code>”</a> describes
            how to make use of that feature.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">org.hibernate.validator.group</code>,
            <code class="literal">org.hibernate.validator.spi.group</code></p></td><td align="left" valign="top"><p>The group sequence provider feature which allows you to
            define dynamic default group sequences in function of the
            validated object state; The specifics can be found in <a class="xref" href="#section-default-group-class" title="5.3. Redefining the default group sequence">Section 5.3, “Redefining the default group sequence”</a>.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">org.hibernate.validator.messageinterpolation</code>,
            <code class="literal">org.hibernate.validator.resourceloading</code>,
            <code class="literal">org.hibernate.validator.spi.resourceloading</code></p></td><td align="left" valign="top"><p>Classes related to constraint message interpolation; The
            first package contains Hibernate Validator’s default message
            interpolator,
            <code class="literal">ResourceBundleMessageInterpolator</code>. The
            latter two packages provide the
            <code class="literal">ResourceBundleLocator</code> SPI for the loading of resource
            bundles (see <a class="xref" href="#section-resource-bundle-locator" title="4.2.1. ResourceBundleLocator">Section 4.2.1, “<code class="literal">ResourceBundleLocator</code>”</a>)
            and its default implementation.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">org.hibernate.validator.parameternameprovider</code></p></td><td align="left" valign="top"><p>A <code class="literal">ParameterNameProvider</code> based on the
            ParaNamer library, see <a class="xref" href="#section-paranamer-parameternameprovider" title="11.10. ParaNamer based ParameterNameProvider">Section 11.10, “ParaNamer based <code class="literal">ParameterNameProvider</code>”</a>.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">org.hibernate.validator.propertypath</code></p></td><td align="left" valign="top"><p>Extensions to the <code class="literal">javax.validation.Path</code> API,
            see <a class="xref" href="#section-extensions-path-api" title="11.6. Extensions of the Path API">Section 11.6, “Extensions of the Path API”</a>.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">org.hibernate.validator.spi.constraintdefinition</code></p></td><td align="left" valign="top"><p>An SPI for registering additional constraint validators programmatically,
            see <a class="xref" href="#section-constraint-definition-contribution" title="11.12. Providing constraint definitions">Section 11.12, “Providing constraint definitions”</a>.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">org.hibernate.validator.spi.time</code></p></td><td align="left" valign="top"><p>An SPI for customizing the retrieval of the current time when validating <code class="literal">@Future</code> and <code class="literal">@Past</code>,
            see <a class="xref" href="#section-time-provider" title="11.14. Time providers for @Future and @Past">Section 11.14, “Time providers for <code class="literal">@Future</code> and <code class="literal">@Past</code>”</a>.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">org.hibernate.validator.valuehandling</code>, <code class="literal">org.hibernate.validator.spi.valuehandling</code></p></td><td align="left" valign="top"><p>Classes related to the processing
            of values prior to thei validation, see <a class="xref" href="#section-value-handling" title="11.11. Unwrapping values">Section 11.11, “Unwrapping values”</a>.</p></td></tr></tbody></table></div></div><br class="table-break"/><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>The public packages of Hibernate Validator fall into two categories: while the actual API parts are
intended to be <span class="emphasis"><em>invoked</em></span> or <span class="emphasis"><em>used</em></span> by clients (e.g. the API for programmatic constraint declaration
or the custom constraints), the SPI (service provider interface) packages contain interfaces which
are intended to be <span class="emphasis"><em>implemented</em></span> by clients (e.g. <code class="literal">ResourceBundleLocator</code>).</p></div><p>Any packages not listed in that table are internal packages of Hibernate Validator and are not
intended to be accessed by clients. The contents of these internal packages can change from release
to release without notice, thus possibly breaking any client code relying on it.</p></div><div class="section" title="11.2. Fail fast mode"><div class="titlepage"><div><div><h2 class="title"><a id="section-fail-fast"/>11.2. Fail fast mode</h2></div></div></div><p>Using the fail fast mode, Hibernate Validator allows to return from the current validation as soon
as the first constraint violation occurs. This can be useful for the validation of large object
graphs where you are only interested in a quick check whether there is any constraint violation at
all.</p><p><a class="xref" href="#example-using-fail-fast" title="Example 11.1. Using the fail fast validation mode">Example 11.1, “Using the fail fast validation mode”</a> shows how to bootstrap and use a fail fast enabled validator.</p><div class="example"><a id="example-using-fail-fast"/><p class="title"><strong>Example 11.1. Using the fail fast validation mode</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter11.failfast;

public class Car {

	@NotNull
	private String manufacturer;

	@AssertTrue
	private boolean isRegistered;

	public Car(String manufacturer, boolean isRegistered) {
		this.manufacturer = manufacturer;
		this.isRegistered = isRegistered;
	}

	//getters and setters...
}</code></pre><pre><code class="language-java">Validator validator = Validation.byProvider( HibernateValidator.class )
        .configure()
        .failFast( true )
        .buildValidatorFactory()
        .getValidator();

Car car = new Car( null, false );

Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate( car );

assertEquals( 1, constraintViolations.size() );</code></pre></div></div><br class="example-break"/><p>Here the validated object actually fails to satisfy both the constraints declared on the <code class="literal">Car</code> class,
yet the validation call yields only one <code class="literal">ConstraintViolation</code> since the fail fast mode is enabled.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>There is no guarantee in which order the constraints are evaluated, i.e. it is not deterministic
whether the returned violation originates from the <code class="literal">@NotNull</code> or the <code class="literal">@AssertTrue</code> constraint. If
required, a deterministic evaluation order can be enforced using group sequences as described in
<a class="xref" href="#section-defining-group-sequences" title="5.2. Defining group sequences">Section 5.2, “Defining group sequences”</a>.</p></div><p>Refer to <a class="xref" href="#section-provider-specific-settings" title="8.2.6. Provider-specific settings">Section 8.2.6, “Provider-specific settings”</a> to learn about the different ways of enabling the
fail fast mode when bootstrapping a validator.</p></div><div class="section" title="11.3. Programmatic constraint declaration"><div class="titlepage"><div><div><h2 class="title"><a id="section-programmatic-api"/>11.3. Programmatic constraint declaration</h2></div></div></div><p>As per the Bean Validation specification, you can declare constraints using Java annotations and XML
based constraint mappings.</p><p>In addition, Hibernate Validator provides a fluent API which allows for the programmatic
configuration of constraints. Use cases include the dynamic addition of constraints at runtime
depending on some application state or tests where you need entities with different constraints in
different scenarios but don’t want to implement actual Java classes for each test case.</p><p>By default, constraints added via the fluent API are additive to constraints configured via the
standard configuration capabilities. But it is also possible to ignore annotation and XML configured
constraints where required.</p><p>The API is centered around the <code class="literal">ConstraintMapping</code> interface. You obtain a new mapping via
<code class="literal">HibernateValidatorConfiguration#createConstraintMapping()</code> which you then can configure in a fluent
manner as shown in <a class="xref" href="#example-constraint-mapping" title="Example 11.2. Programmatic constraint declaration">Example 11.2, “Programmatic constraint declaration”</a>.</p><div class="example"><a id="example-constraint-mapping"/><p class="title"><strong>Example 11.2. Programmatic constraint declaration</strong></p><div class="example-contents"><pre><code class="language-java">HibernateValidatorConfiguration configuration = Validation
        .byProvider( HibernateValidator.class )
        .configure();

ConstraintMapping constraintMapping = configuration.createConstraintMapping();

constraintMapping
    .type( Car.class )
        .property( "manufacturer", FIELD )
            .constraint( new NotNullDef() )
        .property( "licensePlate", FIELD )
            .ignoreAnnotations()
            .constraint( new NotNullDef() )
            .constraint( new SizeDef().min( 2 ).max( 14 ) )
    .type( RentalCar.class )
        .property( "rentalStation", METHOD )
            .constraint( new NotNullDef() );

Validator validator = configuration.addMapping( constraintMapping )
        .buildValidatorFactory()
        .getValidator();</code></pre></div></div><br class="example-break"/><p>Constraints can be configured on multiple classes and properties using method chaining. The
constraint definition classes <code class="literal">NotNullDef</code> and SizeDef are helper classes which allow to configure
constraint parameters in a type-safe fashion. Definition classes exist for all built-in constraints
in the <code class="literal">org.hibernate.validator.cfg.defs</code> package. By calling <code class="literal">ignoreAnnotations()</code> any constraints
configured via annotations or XML are ignored for the given element.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>Each element (type, property, method etc.) may only be configured once within all the constraint
mappings used to set up one validator factory. Otherwise a <code class="literal">ValidationException</code> is raised.</p></div><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>It is not supported to add constraints to non-overridden supertype properties and methods by
configuring a subtype. Instead you need to configure the supertype in this case.</p></div><p>Having configured the mapping, you must add it back to the configuration object from which you then
can obtain a validator factory.</p><p>For custom constraints you can either create your own definition classes extending <code class="literal">ConstraintDef</code> or
you can use <code class="literal">GenericConstraintDef</code> as seen in <a class="xref" href="#example-generic-constraint-mapping" title="Example 11.3. Programmatic declaration of a custom constraint">Example 11.3, “Programmatic declaration of a custom constraint”</a>.</p><div class="example"><a id="example-generic-constraint-mapping"/><p class="title"><strong>Example 11.3. Programmatic declaration of a custom constraint</strong></p><div class="example-contents"><pre><code class="language-java">ConstraintMapping constraintMapping = configuration.createConstraintMapping();

constraintMapping
    .type( Car.class )
        .property( "licensePlate", FIELD )
            .constraint( new GenericConstraintDef&lt;CheckCase&gt;( CheckCase.class )
                .param( "value", CaseMode.UPPER )
            );</code></pre></div></div><br class="example-break"/><p>By invoking <code class="literal">valid()</code> you can mark a member for cascaded validation which is equivalent to annotating
it with <code class="literal">@Valid</code>. Configure any group conversions to be applied during cascaded validation using the
<code class="literal">convertGroup()</code> method (equivalent to <code class="literal">@ConvertGroup</code>). An example can be seen in
<a class="xref" href="#example-cascading-constraints" title="Example 11.4. Marking a property for cascaded validation">Example 11.4, “Marking a property for cascaded validation”</a>.</p><div class="example"><a id="example-cascading-constraints"/><p class="title"><strong>Example 11.4. Marking a property for cascaded validation</strong></p><div class="example-contents"><pre><code class="language-java">ConstraintMapping constraintMapping = configuration.createConstraintMapping();

constraintMapping
    .type( Car.class )
        .property( "driver", FIELD )
            .constraint( new NotNullDef() )
            .valid()
            .convertGroup( Default.class ).to( PersonDefault.class )
    .type( Person.class )
        .property( "name", FIELD )
            .constraint( new NotNullDef().groups( PersonDefault.class ) );</code></pre></div></div><br class="example-break"/><p>You can not only configure bean constraints using the fluent API but also method and constructor
constraints. As shown in <a class="xref" href="#example-method-constraint-mapping" title="Example 11.5. Programmatic declaration of method and constructor constraints">Example 11.5, “Programmatic declaration of method and constructor constraints”</a> constructors are identified by their
parameter types and methods by their name and parameter types. Having selected a method or
constructor, you can mark its parameters and/or return value for cascaded validation and add
constraints as well as cross-parameter constraints.</p><div class="example"><a id="example-method-constraint-mapping"/><p class="title"><strong>Example 11.5. Programmatic declaration of method and constructor constraints</strong></p><div class="example-contents"><pre><code class="language-java">ConstraintMapping constraintMapping = configuration.createConstraintMapping();

constraintMapping
    .type( Car.class )
        .constructor( String.class )
            .parameter( 0 )
                .constraint( new SizeDef().min( 3 ).max( 50 ) )
            .returnValue()
                .valid()
        .method( "drive", int.class )
            .parameter( 0 )
                .constraint( new MaxDef().value ( 75 ) )
        .method( "load", List.class, List.class )
            .crossParameter()
                .constraint( new GenericConstraintDef&lt;LuggageCountMatchesPassengerCount&gt;(
                        LuggageCountMatchesPassengerCount.class ).param(
                            "piecesOfLuggagePerPassenger", 2
                        )
                )
        .method( "getDriver" )
            .returnValue()
                .constraint( new NotNullDef() )
                .valid();</code></pre></div></div><br class="example-break"/><p>Last but not least you can configure the default group sequence or the default group sequence
provider of a type as shown in the following example.</p><div class="example"><a id="example-sequences"/><p class="title"><strong>Example 11.6. Configuration of default group sequence and default group sequence provider</strong></p><div class="example-contents"><pre><code class="language-java">ConstraintMapping constraintMapping = configuration.createConstraintMapping();

constraintMapping
    .type( Car.class )
        .defaultGroupSequence( Car.class, CarChecks.class )
    .type( RentalCar.class )
        .defaultGroupSequenceProviderClass( RentalCarGroupSequenceProvider.class );</code></pre></div></div><br class="example-break"/></div><div class="section" title="11.4. Applying programmatic constraint declarations to the default validator factory"><div class="titlepage"><div><div><h2 class="title"><a id="section-programmatic-api-contributor"/>11.4. Applying programmatic constraint declarations to the default validator factory</h2></div></div></div><p>If you are not bootstrapping a validator factory manually
but work with the default factory as configured via <span class="emphasis"><em>META-INF/validation.xml</em></span>
(see <a class="xref" href="#chapter-xml-configuration" title="Chapter 7. Configuring via XML">Chapter 7, <em>Configuring via XML</em></a>),
you can add one or more constraint mappings by creating a constraint mapping contributor.
To do so, implement the <code class="literal">ConstraintMappingContributor</code> contract:</p><div class="example"><a id="example-constraint-mapping-contributor"/><p class="title"><strong>Example 11.7. Custom <code class="literal">ConstraintMappingContributor</code> implementation</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter11.constraintapi;

public class MyConstraintMappingContributor implements ConstraintMappingContributor {

	@Override
	public void createConstraintMappings(ConstraintMappingBuilder builder) {
		builder.addConstraintMapping()
			.type( Marathon.class )
				.property( "name", METHOD )
					.constraint( new NotNullDef() )
				.property( "numberOfHelpers", FIELD )
					.constraint( new MinDef().value( 1 ) );

		builder.addConstraintMapping()
			.type( Runner.class )
				.property( "paidEntryFee", FIELD )
					.constraint( new AssertTrueDef() );
	}
}</code></pre></div></div><br class="example-break"/><p>You then need to specify the fully-qualified class name of the contributor implementation in <span class="emphasis"><em>META-INF/validation.xml</em></span>,
using the property key <code class="literal">hibernate.validator.constraint_mapping_contributor</code>.</p></div><div class="section" title="11.5. Advanced constraint composition features"><div class="titlepage"><div><div><h2 class="title"><a id="section-advanced-constraint-composition"/>11.5. Advanced constraint composition features</h2></div></div></div><div class="section" title="11.5.1. Validation target specification for purely composed constraints"><div class="titlepage"><div><div><h3 class="title"><a id="_validation_target_specification_for_purely_composed_constraints"/>11.5.1. Validation target specification for purely composed constraints</h3></div></div></div><p>In case you specify a purely composed constraint - i.e. a constraint which has no validator itself but is solely made
up from other, composing constraints - on a method declaration, the validation engine cannot determine whether that
constraint is to be applied as a return value constraint or as a cross-parameter constraint.</p><p>Hibernate Validator allows to resolve such ambiguities by specifying the <code class="literal">@SupportedValidationTarget</code> annotation on the
declaration of the composed constraint type as shown in <a class="xref" href="#example-purely-composed-constraint-validation-target" title="Example 11.8. Specifying the validation target of a purely composed constraint">Example 11.8, “Specifying the validation target of a purely composed constraint”</a>.
The <code class="literal">@ValidInvoiceAmount</code> does not declare any validator, but it is solely composed by the <code class="literal">@Min</code> and <code class="literal">@NotNull</code>
constraints. The <code class="literal">@SupportedValidationTarget</code> ensures that the constraint is applied to the method return value when
given on a method declaration.</p><div class="example"><a id="example-purely-composed-constraint-validation-target"/><p class="title"><strong>Example 11.8. Specifying the validation target of a purely composed constraint</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter11.purelycomposed;

@Min(value = 0)
@NotNull
@Target({ METHOD, FIELD, ANNOTATION_TYPE, CONSTRUCTOR, PARAMETER })
@Retention(RUNTIME)
@Documented
@Constraint(validatedBy = {})
@SupportedValidationTarget(ValidationTarget.ANNOTATED_ELEMENT)
@ReportAsSingleViolation
public @interface ValidInvoiceAmount {

	String message() default "{org.hibernate.validator.referenceguide.chapter11.purelycomposed."
			+ "ValidInvoiceAmount.message}";

	Class&lt;?&gt;[] groups() default {};

	Class&lt;? extends Payload&gt;[] payload() default {};

	@OverridesAttribute(constraint = Min.class, name = "value")
	long value();
}</code></pre></div></div><br class="example-break"/></div><div class="section" title="11.5.2. Boolean composition of constraints"><div class="titlepage"><div><div><h3 class="title"><a id="section-boolean-constraint-composition"/>11.5.2. Boolean composition of constraints</h3></div></div></div><p>Bean Validation specifies that the constraints of a composed constraint (see
<a class="xref" href="#section-constraint-composition" title="6.4. Constraint composition">Section 6.4, “Constraint composition”</a>) are all combined via a logical <span class="emphasis"><em>AND</em></span>. This means all of the
composing constraints need to return true in order for an overall successful validation.</p><p>Hibernate Validator offers an extension to this and allows you to compose constraints via a logical
<span class="emphasis"><em>OR</em></span> or <span class="emphasis"><em>NOT</em></span>. To do so you have to use the ConstraintComposition annotation and the enum
CompositionType with its values <span class="emphasis"><em>AND</em></span>, <span class="emphasis"><em>OR</em></span> and <span class="emphasis"><em>ALL_FALSE</em></span>.</p><p><a class="xref" href="#example-boolean-constraint-composition" title="Example 11.9. OR composition of constraints">Example 11.9, “OR composition of constraints”</a> shows how to build a composed constraint <code class="literal">@PatternOrSize</code>
where only one of the composing constraints needs to be valid in order to pass the validation.
Either the validated string is all lower-cased or it is between two and three characters long.</p><div class="example"><a id="example-boolean-constraint-composition"/><p class="title"><strong>Example 11.9. OR composition of constraints</strong></p><div class="example-contents"><pre><code class="language-java">package org.hibernate.validator.referenceguide.chapter11.booleancomposition;

@ConstraintComposition(OR)
@Pattern(regexp = "[a-z]")
@Size(min = 2, max = 3)
@ReportAsSingleViolation
@Target({ METHOD, FIELD })
@Retention(RUNTIME)
@Constraint(validatedBy = { })
public @interface PatternOrSize {
	String message() default "{org.hibernate.validator.referenceguide.chapter11." +
			"booleancomposition.PatternOrSize.message}";

	Class&lt;?&gt;[] groups() default { };

	Class&lt;? extends Payload&gt;[] payload() default { };
}</code></pre></div></div><br class="example-break"/><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>Using <span class="emphasis"><em>ALL_FALSE</em></span> as composition type implicitly enforces that only a single violation will get
reported in case validation of the constraint composition fails.</p></div></div></div><div class="section" title="11.6. Extensions of the Path API"><div class="titlepage"><div><div><h2 class="title"><a id="section-extensions-path-api"/>11.6. Extensions of the Path API</h2></div></div></div><p>Hibernate Validator provides an extension to the <code class="literal">javax.validation.Path</code> API.
For nodes of <code class="literal">ElementKind.PROPERTY</code> it allows to obtain the value of the represented property.
To do so, narrow down a given node to the type <code class="literal">org.hibernate.validator.path.PropertyNode</code> using <code class="literal">Node#as()</code>, as shown in the following example:</p><div class="example"><a id="example-property-node-get-value"/><p class="title"><strong>Example 11.10. Getting the value from property nodes</strong></p><div class="example-contents"><pre><code class="language-java">Building building = new Building();

// Assume the name of the person violates a @Size constraint
Person bob = new Person( "Bob" );
Apartment bobsApartment = new Apartment( bob );
building.getApartments().add( bobsApartment );

Set&lt;ConstraintViolation&lt;Building&gt;&gt; constraintViolations = validator.validate( building );

Path path = constraintViolations.iterator().next().getPropertyPath();
Iterator&lt;Path.Node&gt; nodeIterator = path.iterator();

Path.Node node = nodeIterator.next();
assertEquals( node.getName(), "apartments" );
assertSame( node.as( PropertyNode.class ).getValue(), bobsApartment );

node = nodeIterator.next();
assertEquals( node.getName(), "resident" );
assertSame( node.as( PropertyNode.class ).getValue(), bob );

node = nodeIterator.next();
assertEquals( node.getName(), "name" );
assertEquals( node.as( PropertyNode.class ).getValue(), "Bob" );</code></pre></div></div><br class="example-break"/><p>This is specifically useful to obtain the element of <code class="literal">Set</code> properties on the property path (e.g. <code class="literal">apartments</code> in the example) which otherwise could not be identified (unlike for <code class="literal">Map</code> and <code class="literal">List</code>, there is no key nor index in this case).</p></div><div class="section" title="11.7. ParameterMessageInterpolator"><div class="titlepage"><div><div><h2 class="title"><a id="non-el-message-interpolator"/>11.7. <code class="literal">ParameterMessageInterpolator</code></h2></div></div></div><p>Hibernate Validator requires per default an implementation of the Unified EL (see
<a class="xref" href="#validator-gettingstarted-uel" title="1.1.1. Unified EL">Section 1.1.1, “Unified EL”</a>) to be available. This is needed to allow the interpolation
of constraint error messages using EL expressions as defined by Bean Validation 1.1.</p><p>For environments where you cannot or do not want to provide an EL implementation, Hibernate Validators
offers a non EL based message interpolator - <code class="literal">org.hibernate.validator.messageinterpolation.ParameterMessageInterpolator</code>.</p><p>Refer to <a class="xref" href="#section-custom-message-interpolation" title="4.2. Custom message interpolation">Section 4.2, “Custom message interpolation”</a> to see how to plug in custom message interpolator
implementations.</p><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2><p>Constraint messages containing EL expressions will be returned un-interpolated by
<code class="literal">org.hibernate.validator.messageinterpolation.ParameterMessageInterpolator</code>. This also affects
built-in default constraint messages which use EL expressions. At the moment <code class="literal">DecimalMin</code> and <code class="literal">DecimalMax</code> are affected.</p></div></div><div class="section" title="11.8. ResourceBundleLocator"><div class="titlepage"><div><div><h2 class="title"><a id="__literal_resourcebundlelocator_literal"/>11.8. <code class="literal">ResourceBundleLocator</code></h2></div></div></div><p>With <code class="literal">ResourceBundleLocator</code>, Hibernate Validator provides an additional SPI which allows to retrieve
error messages from other resource bundles than <span class="emphasis"><em>ValidationMessages</em></span> while still using the actual
interpolation algorithm as defined by the specification. Refer to
<a class="xref" href="#section-resource-bundle-locator" title="4.2.1. ResourceBundleLocator">Section 4.2.1, “<code class="literal">ResourceBundleLocator</code>”</a> to learn how to make use of that SPI.</p></div><div class="section" title="11.9. Custom contexts"><div class="titlepage"><div><div><h2 class="title"><a id="_custom_contexts"/>11.9. Custom contexts</h2></div></div></div><p>The Bean Validation specification offers at several points in its API the possibility to unwrap a
given interface to a implementor specific subtype. In the case of constraint violation creation in
<code class="literal">ConstraintValidator</code> implementations as well as message interpolation in <code class="literal">MessageInterpolator</code>
instances, there exist <code class="literal">unwrap()</code> methods for the provided context instances -
<code class="literal">ConstraintValidatorContext</code> respectively <code class="literal">MessageInterpolatorContext</code>. Hibernate Validator provides
custom extensions for both of these interfaces.</p><div class="section" title="11.9.1. HibernateConstraintValidatorContext"><div class="titlepage"><div><div><h3 class="title"><a id="section-hibernateconstraintvalidatorcontext"/>11.9.1. <code class="literal">HibernateConstraintValidatorContext</code></h3></div></div></div><p><a id="section-custom-constraint-validator-context"/><code class="literal">HibernateConstraintValidatorContext</code> is a subtype of <code class="literal">ConstraintValidatorContext</code> which allows you to:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">set arbitrary parameters for interpolation via the Expression Language message interpolation
facility (see <a class="xref" href="#section-interpolation-with-message-expressions" title="4.1.2. Interpolation with message expressions">Section 4.1.2, “Interpolation with message expressions”</a>)</li><li class="listitem">obtain the <code class="literal">TimeProvider</code> for getting the current time when validating the <code class="literal">Future</code> and <code class="literal">@Past</code> constraints
(see <a class="xref" href="#section-time-provider" title="11.14. Time providers for @Future and @Past">Section 11.14, “Time providers for <code class="literal">@Future</code> and <code class="literal">@Past</code>”</a>)</li></ul></div><p>This is useful if you for instance would like to customize the message of the <code class="literal">@Future</code> constraint.
By default the message just is "must be in the future". <a class="xref" href="#example-custom-message-parameter" title="Example 11.11. Custom @Future validator with message parameters">Example 11.11, “Custom <code class="literal">@Future</code> validator with message parameters”</a> shows
how to include the current date in order to make the message more explicit.</p><div class="example"><a id="example-custom-message-parameter"/><p class="title"><strong>Example 11.11. Custom <code class="literal">@Future</code> validator with message parameters</strong></p><div class="example-contents"><pre><code class="language-java">public class MyFutureValidator implements ConstraintValidator&lt;Future, Date&gt; {

	@Override
	public void initialize(Future constraintAnnotation) {
	}

	@Override
	public boolean isValid(Date value, ConstraintValidatorContext context) {
		if ( value == null ) {
			return true;
		}

		HibernateConstraintValidatorContext hibernateContext = context.unwrap(
				HibernateConstraintValidatorContext.class
		);

		Date now = new Date( hibernateContext.getTimeProvider().getCurrentTime() );

		if ( !value.after( now ) ) {
			hibernateContext.disableDefaultConstraintViolation();
			hibernateContext.addExpressionVariable( "now", now )
					.buildConstraintViolationWithTemplate( "Must be after ${now}" )
					.addConstraintViolation();

			return false;
		}

		return true;
	}
}</code></pre></div></div><br class="example-break"/><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>Note that the parameters specified via <code class="literal">addExpressionVariable(String, Object)</code> are global and apply
for all constraint violations created by this <code class="literal">isValid()</code> invocation. This includes the default
constraint violation, but also all violations created by the <code class="literal">ConstraintViolationBuilder</code>. You can,
however, update the parameters between invocations of
<code class="literal">ConstraintViolationBuilder#addConstraintViolation()</code>.</p></div><div class="warning" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Warning</h2><p>This functionality is currently experimental and might change in future versions.</p></div></div><div class="section" title="11.9.2. HibernateMessageInterpolatorContext"><div class="titlepage"><div><div><h3 class="title"><a id="__literal_hibernatemessageinterpolatorcontext_literal"/>11.9.2. <code class="literal">HibernateMessageInterpolatorContext</code></h3></div></div></div><p>Hibernate Validator also offers a custom extension of <code class="literal">MessageInterpolatorContext</code>, namely
<code class="literal">HibernateMessageInterpolatorContext</code> (see <a class="xref" href="#example-custom-message-interpolator-context" title="Example 11.12. HibernateMessageInterpolatorContext">Example 11.12, “<code class="literal">HibernateMessageInterpolatorContext</code>”</a>). This
subtype was introduced to allow a better integration of Hibernate Validator into the Glassfish. The
root bean type was in this case needed to determine the right classloader for the message resource
bundle. If you have any other usecases, let us know.</p><div class="example"><a id="example-custom-message-interpolator-context"/><p class="title"><strong>Example 11.12. <code class="literal">HibernateMessageInterpolatorContext</code></strong></p><div class="example-contents"><pre><code class="language-java">public interface HibernateMessageInterpolatorContext extends MessageInterpolator.Context {

	/**
	 * Returns the currently validated root bean type.
	 *
	 * @return The currently validated root bean type.
	 */
	Class&lt;?&gt; getRootBeanType();
}</code></pre></div></div><br class="example-break"/></div></div><div class="section" title="11.10. ParaNamer based ParameterNameProvider"><div class="titlepage"><div><div><h2 class="title"><a id="section-paranamer-parameternameprovider"/>11.10. ParaNamer based <code class="literal">ParameterNameProvider</code></h2></div></div></div><p>Hibernate Validator comes with a <code class="literal">ParameterNameProvider</code> implementation which leverages the
<a class="link" href="http://paranamer.codehaus.org/">ParaNamer</a> library.</p><p>This library provides several ways for obtaining parameter names at runtime, e.g. based on debug
symbols created by the Java compiler, constants with the parameter names woven into the bytecode in
a post-compile step or annotations such as the <code class="literal">@Named</code> annotation from JSR 330.</p><p>In order to use <code class="literal">ParanamerParameterNameProvider</code>, either pass an instance when bootstrapping a
validator as shown in <a class="xref" href="#example-using-custom-parameter-name-provider" title="Example 8.8. Using a custom ParameterNameProvider">Example 8.8, “Using a custom <code class="literal">ParameterNameProvider</code>”</a> or specify
<code class="literal">org.hibernate.validator.parameternameprovider.ParanamerParameterNameProvider</code> as value for the
<code class="literal">&lt;parameter-name-provider&gt;</code> element in the <span class="emphasis"><em>META-INF/validation.xml</em></span> file.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>When using this parameter name provider, you need to add the ParaNamer library to your classpath. It
is available in the Maven Central repository with the group id <code class="literal">com.thoughtworks.paranamer</code> and the
artifact id <code class="literal">paranamer</code>.</p></div><p>By default <code class="literal">ParanamerParameterNameProvider</code> retrieves parameter names from constants added to the byte
code at build time (via <code class="literal">DefaultParanamer</code>) and debug symbols (via <code class="literal">BytecodeReadingParanamer</code>).
Alternatively you can specify a <code class="literal">Paranamer</code> implementation of your choice when creating a
<code class="literal">ParanamerParameterNameProvider</code> instance.</p></div><div class="section" title="11.11. Unwrapping values"><div class="titlepage"><div><div><h2 class="title"><a id="section-value-handling"/>11.11. Unwrapping values</h2></div></div></div><p>Sometimes it is required to unwrap values prior to validating them. For example, in
<a class="xref" href="#example-using-unwrapvalidatedvalue" title="Example 11.13. Applying a constraint to wrapped value of a JavaFX property">Example 11.13, “Applying a constraint to wrapped value of a JavaFX property”</a> a <a class="link" href="http://docs.oracle.com/javafx/">JavaFX</a> property type
is used to define an element of a domain model. The <code class="literal">@Size</code> constraint is meant to be applied to the
string value not the wrapping <code class="literal">Property</code> instance.</p><div class="example"><a id="example-using-unwrapvalidatedvalue"/><p class="title"><strong>Example 11.13. Applying a constraint to wrapped value of a JavaFX property</strong></p><div class="example-contents"><pre><code class="language-java">@Size(min = 3)
private Property&lt;String&gt; name = new SimpleStringProperty( "Bob" );</code></pre></div></div><br class="example-break"/><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>The concept of value unwrapping is considered experimental at this time and may evolve into more
general means of value handling in future releases. Please let us know about your use cases for such
functionality.</p></div><p>Bean properties in JavaFX are typically not of simple data types like <code class="literal">String</code> or <code class="literal">int</code>, but are
wrapped in <code class="literal">Property</code> types which allows to make them observable, use them for data binding etc. When
applying a constraint such as <code class="literal">@Size</code> to an element of type <code class="literal">Property&lt;String&gt;</code> without further
preparation, an exception would be raised, indicating that no suitable validator for that constraint
and data type can be found. Thus the validated value must be unwrapped from the containing property
object before looking up a validator and invoking it.</p><p>For unwrapping to occur a <code class="literal">ValidatedValueUnwrapper</code> needs to be registered for the type
requiring unwrapping. Example <a class="xref" href="#example-implementation-of-validatedvalueunwrapper" title="Example 11.14. Implementing the ValidatedValueUnwrapper interface">Example 11.14, “Implementing the ValidatedValueUnwrapper interface”</a> shows how this
schematically looks for a JavaFX <code class="literal">PropertyValueUnwrapper</code>. You just need to extend the SPI class
<code class="literal">ValidatedValueUnwrapper</code> and implement its abstract methods.</p><div class="example"><a id="example-implementation-of-validatedvalueunwrapper"/><p class="title"><strong>Example 11.14. Implementing the ValidatedValueUnwrapper interface</strong></p><div class="example-contents"><pre><code class="language-java">public class PropertyValueUnwrapper extends ValidatedValueUnwrapper&lt;Property&lt;?&gt;&gt; {

	@Override
	public Object handleValidatedValue(Property&lt;?&gt; value) {
		//...
	}

	@Override
	public Type getValidatedValueType(Type valueType) {
		//...
	}
}</code></pre></div></div><br class="example-break"/><p>The <code class="literal">ValidatedValueUnwrapper</code> needs also to be registered with the <code class="literal">ValidatorFactory</code>:</p><div class="example"><a id="example-registering-validatedvalueunwrapper"/><p class="title"><strong>Example 11.15. Registering a ValidatedValueUnwrapper</strong></p><div class="example-contents"><pre><code class="language-java">Validator validator = Validation.byProvider( HibernateValidator.class )
		.configure()
		.addValidatedValueHandler( new PropertyValueUnwrapper() )
		.buildValidatorFactory()
		.getValidator();</code></pre></div></div><br class="example-break"/><p>Several unwrapper implementations can be registered. During constraint validator resolution
Hibernate Validator automatically checks whether a <code class="literal">ValidatedValueUnwrapper</code> exists for the validated
value. If so, unwrapping occurs automatically. In some cases, however, constraint validator instances
for a given constraint might exist for the wrapper as well as the wrapped value (<code class="literal">@NotNull</code> for example
applies to all objects). In this case Hibernate Validator needs to be explicitly told which value
to validate. This can be done via <code class="literal">@UnwrapValidatedValue(true)</code> respectively
<code class="literal">@UnwrapValidatedValue(false)</code>.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>Note that it is not specified which of the unwrapper implementations is
chosen when more than one implementation is suitable to unwrap a given element.</p></div><p>Instead of programmatically registering <code class="literal">ValidatedValueUnwrapper</code> types, the fully-qualified names
of one ore more unwrapper implementations can be specified
via the configuration property <code class="literal">hibernate.validator.validated_value_handlers</code> which can be useful when
configuring the default validator factory using the descriptor <span class="emphasis"><em>META-INF/validation.xml</em></span> (see
<a class="xref" href="#chapter-xml-configuration" title="Chapter 7. Configuring via XML">Chapter 7, <em>Configuring via XML</em></a>).</p><div class="section" title="11.11.1. Optional unwrapper"><div class="titlepage"><div><div><h3 class="title"><a id="section-optional-unwrapper"/>11.11.1. Optional unwrapper</h3></div></div></div><p>Hibernate Validator provides built-in unwrapping for <code class="literal">Optional</code> introduced in Java 8.
The unwrapper is registered automatically in Java 8 environments, and no further configuration is
required. An example of unwrapping an <code class="literal">Optional</code> instance is shown in
<a class="xref" href="#example-using-unwrapvalidatedvalue-and-optional" title="Example 11.16. Unwrapping Optional instances">Example 11.16, “Unwrapping <code class="literal">Optional</code> instances”</a>.</p><div class="example"><a id="example-using-unwrapvalidatedvalue-and-optional"/><p class="title"><strong>Example 11.16. Unwrapping <code class="literal">Optional</code> instances</strong></p><div class="example-contents"><pre><code class="language-java">@Size(min = 3)
private Optional&lt;String&gt; firstName = Optional.of( "John" );

@NotNull
@UnwrapValidatedValue // UnwrapValidatedValue required since otherwise unclear which value to validate
private Optional&lt;String&gt; lastName = Optional.of( "Doe" );</code></pre></div></div><br class="example-break"/><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p><code class="literal">Optional.empty()</code> is treated as <code class="literal">null</code> during validation. This means that for constraints where
<code class="literal">null</code> is considered valid, <code class="literal">Optional.empty()</code> is similarly valid.</p></div></div><div class="section" title="11.11.2. JavaFX unwrapper"><div class="titlepage"><div><div><h3 class="title"><a id="section-javafx-unwrapper"/>11.11.2. JavaFX unwrapper</h3></div></div></div><p>Hibernate Validator also provides built-in unwrapping for JavaFX property values. The unwrapper is
registered automatically for environments where JavaFX is present, and no further configuration is
required. <code class="literal">ObservableValue</code> and its sub-types are supported.
An example of some of the different ways in which <code class="literal">JavaFX</code> property values can be unwrapped is
shown in <a class="xref" href="#example-using-unwrapvalidatedvalue-and-javafx" title="Example 11.17. Unwrapping JavaFX properties">Example 11.17, “Unwrapping <code class="literal">JavaFX</code> properties”</a>.</p><div class="example"><a id="example-using-unwrapvalidatedvalue-and-javafx"/><p class="title"><strong>Example 11.17. Unwrapping <code class="literal">JavaFX</code> properties</strong></p><div class="example-contents"><pre><code class="language-java">@Min(value = 3)
IntegerProperty integerProperty1 = new SimpleIntegerProperty( 4 );

@Min(value = 3)
Property&lt;Number&gt; integerProperty2 = new SimpleIntegerProperty( 4 );

@Min(value = 3)
ObservableValue&lt;Number&gt; integerProperty3 = new SimpleIntegerProperty( 4 );</code></pre></div></div><br class="example-break"/></div><div class="section" title="11.11.3. Unwrapping object graphs"><div class="titlepage"><div><div><h3 class="title"><a id="_unwrapping_object_graphs"/>11.11.3. Unwrapping object graphs</h3></div></div></div><p>Unwrapping can also be used with object graphs (cascaded validation) as shown in
<a class="xref" href="#example-using-unwrapvalidatedvalue-and-optional-with-valid" title="Example 11.18. Unwrapping Optional prior to cascaded validation via @Valid">Example 11.18, “Unwrapping <code class="literal">Optional</code> prior to cascaded validation via <code class="literal">@Valid</code>”</a>.
When validating the object holding the <code class="literal">Optional&lt;Person&gt;</code>, a cascaded validation of the <code class="literal">Person</code>
object would be performed.</p><div class="example"><a id="example-using-unwrapvalidatedvalue-and-optional-with-valid"/><p class="title"><strong>Example 11.18. Unwrapping <code class="literal">Optional</code> prior to cascaded validation via <code class="literal">@Valid</code></strong></p><div class="example-contents"><pre><code class="language-java">@Valid
private Optional&lt;Person&gt; person = Optional.of( new Person() );</code></pre><pre><code class="language-java">public class Person {
	@Size(min =3)
	private String name = "Bob";
}</code></pre></div></div><br class="example-break"/></div></div><div class="section" title="11.12. Providing constraint definitions"><div class="titlepage"><div><div><h2 class="title"><a id="section-constraint-definition-contribution"/>11.12. Providing constraint definitions</h2></div></div></div><p>Bean Validation allows to (re-)define constraint definitions via XML in its constraint mapping
files. See <a class="xref" href="#section-mapping-xml-constraints" title="7.2. Mapping constraints via constraint-mappings">Section 7.2, “Mapping constraints via <code class="literal">constraint-mappings</code>”</a> for more information and <a class="xref" href="#example-constraints-car" title="Example 7.2. Bean constraints configured via XML">Example 7.2, “Bean constraints configured via XML”</a>
for an example. While this approach is sufficient for many use cases,  it has it shortcomings
in others. Imagine for example a constraint library wanting to contribute constraint
definitions for custom types. This library could provide a mapping file with their library, but this
file still would need to be referenced by the user of the library. Luckily there are better ways.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>The following concepts are considered experimental at this time. Let us know whether you find them
useful and whether they meet your needs.</p></div><div class="section" title="11.12.1. Constraint definitions via ServiceLoader"><div class="titlepage"><div><div><h3 class="title"><a id="_constraint_definitions_via_literal_serviceloader_literal"/>11.12.1. Constraint definitions via <code class="literal">ServiceLoader</code></h3></div></div></div><p>Hibernate Validator allows to utilize Java’s
<a class="link" href="http://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html/">ServiceLoader</a>
mechanism to register additional constraint definitions. All you have to do is to add the file
<span class="emphasis"><em>javax.validation.ConstraintValidator</em></span> to <span class="emphasis"><em>META-INF/services</em></span>. In this service file you list the
fully qualified classnames of your constraint validator classes (one per line). Hibernate Validator
will automatically infer the constraint types they apply to.
See <a class="link" href="#example-using-service-file-for-constraint-definitions" title="Example 11.19. META-INF/services/javax.validation.ConstraintValidator">Constraint definition via service file</a>
for an example.</p><div class="example"><a id="example-using-service-file-for-constraint-definitions"/><p class="title"><strong>Example 11.19. <span class="emphasis"><em>META-INF/services/javax.validation.ConstraintValidator</em></span></strong></p><div class="example-contents"><pre class="screen"># Assuming a custom constraint annotation @org.mycompany.CheckCase
org.mycompany.CheckCaseValidator</pre></div></div><br class="example-break"/><p>To contribute default messages for your custom constraints, place a file <span class="emphasis"><em>ContributorValidationMessages.properties</em></span>
and/or its locale-specific specializations at the root your JAR. Hibernate Validator will consider the
entries from all the bundles with this name found on the classpath in addition to those given in <span class="emphasis"><em>ValidationMessages.properties</em></span>.</p><p>This mechanism is also helpful when creating large multi-module applications: Instead of putting all the constraint
messages into one single bundle, you can have one resource bundle per module containing only those messages of that module.</p></div><div class="section" title="11.12.2. Constraint definitions via ConstraintDefinitionContributor"><div class="titlepage"><div><div><h3 class="title"><a id="section-constraint-definition-contributor"/>11.12.2. Constraint definitions via <code class="literal">ConstraintDefinitionContributor</code></h3></div></div></div><p>While the service loader approach works in many scenarios, but not in all (think for example
OSGi where service files are not visible), there is yet another way of contributing constraint
definitions. You can provide one or more implementations of <code class="literal">ConstraintDefinitionContributor</code> to
<code class="literal">HibernateConfiguration</code> during bootstrapping of the <code class="literal">ValidatorFactory</code> - see
<a class="xref" href="#example-using-constraint-definition-contributor" title="Example 11.20. Using ConstraintDefinitionContributor to register constraint definitions">Example 11.20, “Using <code class="literal">ConstraintDefinitionContributor</code> to register constraint definitions”</a>.</p><div class="example"><a id="example-using-constraint-definition-contributor"/><p class="title"><strong>Example 11.20. Using <code class="literal">ConstraintDefinitionContributor</code> to register constraint definitions</strong></p><div class="example-contents"><pre><code class="language-java">public class CarTest {

	private static Validator validator;

	public static class MyConstraintDefinitionContributor
			implements ConstraintDefinitionContributor {

		@Override
		public void collectConstraintDefinitions(ConstraintDefinitionBuilder builder) {
			builder.constraint( ValidPassengerCount.class )
					.validatedBy( ValidPassengerCountValidator.class );
		}
	}

	@BeforeClass
	public static void setUpValidator() {

		HibernateValidatorConfiguration configuration = Validation
				.byProvider( HibernateValidator.class )
				.configure();

		ConstraintDefinitionContributor contributor = new MyConstraintDefinitionContributor();
		configuration.addConstraintDefinitionContributor( contributor );

		validator = configuration.buildValidatorFactory().getValidator();
	}

    // ...
}</code></pre></div></div><br class="example-break"/><p>Instead of programmatically registering <code class="literal">ConstraintDefinitionContributor</code> instances, the
fully-qualified classnames of one or more implementations can be specified via the
property <code class="literal">hibernate.validator.constraint_definition_contributors</code>. This can be useful when
configuring the default validator factory using <span class="emphasis"><em>META-INF/validation.xml</em></span> (see
<a class="xref" href="#chapter-xml-configuration" title="Chapter 7. Configuring via XML">Chapter 7, <em>Configuring via XML</em></a>).</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>One use case for <code class="literal">ConstraintDefinitionContributor</code> is the ability to specify an alternative
constraint validator for the <code class="literal">@URL</code> constraint. Historically, Hibernate Validator’s default constraint
validator for this constraint uses the <code class="literal">java.net.URL</code> constructor to validate an URL.
However, there is also a purely regular expression based version available which can be configured using
a <code class="literal">ConstraintDefinitionContributor</code>:</p><p title="Using a ConstraintDefinitionContributor to register a regular expression based constraint definition for @URL"><strong>Using a <code class="literal">ConstraintDefinitionContributor</code> to register a regular expression based constraint definition for <code class="literal">@URL</code>. </strong>
</p><pre><code class="language-java">HibernateValidatorConfiguration configuration = Validation
	.byProvider( HibernateValidator.class )
	.configure();

configuration.addConstraintDefinitionContributor(
	new ConstraintDefinitionContributor() {
		@Override
		public void collectConstraintDefinitions(ConstraintDefinitionBuilder builder) {
			builder.constraint( URL.class )
				.includeExistingValidators( false )
				.validatedBy( RegexpURLValidator.class );
		}
	}
);</code></pre><p title="Using a ConstraintDefinitionContributor to register a regular expression based constraint definition for @URL">
</p></div></div></div><div class="section" title="11.13. Customizing class-loading"><div class="titlepage"><div><div><h2 class="title"><a id="section-constraint-customizing-class-loading"/>11.13. Customizing class-loading</h2></div></div></div><p>There are several cases in which Hibernate Validator needs to load resources or classes given by name:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">XML descriptors (<span class="emphasis"><em>META-INF/validation.xml</em></span> as well as XML constraint mappings)</li><li class="listitem">classes specified by name in XML descriptors (e.g. custom message interpolators etc.)</li><li class="listitem">the <span class="emphasis"><em>ValidationMessages</em></span> resource bundle</li></ul></div><p>By default Hibernate Validator tries to load these resources via the current thread context classloader.
If that’s not successful, Hibernate Validator’s own classloader will be tried as a fallback.</p><p>For cases where this strategy is not appropriate (e.g. modularized environments such as OSGi),
you may provide a specific classloader for loading these resources when bootstrapping the validator factory:</p><div class="example"><a id="example-using-external-class-loader"/><p class="title"><strong>Example 11.21. Providing a classloader for loading external resources and classes</strong></p><div class="example-contents"><pre><code class="language-java">ClassLoader classLoader = ...;

Validator validator = Validation.byProvider( HibernateValidator.class )
		.configure()
		.externalClassLoader( classLoader )
		.buildValidatorFactory()
		.getValidator();</code></pre></div></div><br class="example-break"/><p>In the case of OSGi, you could e.g. pass the loader of a class from the bundle bootstrapping Hibernate Validator
or a custom classloader implementation which delegates to <code class="literal">Bundle#loadClass()</code> etc.</p><div class="note" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Note</h2><p>Call <code class="literal">ValidatorFactory#close()</code> if a given validator factory instance is not needed any longer.
Failure to do so may result in a classloader leak in cases where applications/bundles are re-deployed and a non-closed
validator factory still is referenced by application code.</p></div></div><div class="section" title="11.14. Time providers for @Future and @Past"><div class="titlepage"><div><div><h2 class="title"><a id="section-time-provider"/>11.14. Time providers for <code class="literal">@Future</code> and <code class="literal">@Past</code></h2></div></div></div><p>By default the current system time is used when validating the <code class="literal">@Future</code> and <code class="literal">@Past</code> constraints.
In some cases it can be necessary though to work with another "logical" date rather than the system time,
e.g. for testing purposes or in the context of batch applications which may require to run with
yesterday’s date when re-running a failed job execution.</p><p>To address such scenarios, Hibernate Validator provides a custom contract for obtaining the current time, <code class="literal">TimeProvider</code>.
<a class="xref" href="#example-using-time-provider" title="Example 11.22. Using a custom TimeProvider">Example 11.22, “Using a custom <code class="literal">TimeProvider</code>”</a> shows an implementation of this contract and its registration when bootstrapping a validator factory.</p><div class="example"><a id="example-using-time-provider"/><p class="title"><strong>Example 11.22. Using a custom <code class="literal">TimeProvider</code></strong></p><div class="example-contents"><pre><code class="language-java">public class CustomTimeProvider implements TimeProvider {

	@Override
	public long getCurrentTime() {
		Calendar now = ...;
		return now.getTimeInMillis();
	}
}</code></pre><pre><code class="language-java">ValidatorFactory validatorFactory = Validation.byProvider( HibernateValidator.class )
		.configure()
		.timeProvider( timeProvider )
		.buildValidatorFactory();</code></pre></div></div><br class="example-break"/><p>Alternatively, you can specify the fully-qualified classname of a <code class="literal">TimeProvider</code> implementation using the property
<code class="literal">hibernate.validator.time_provider</code> when configuring the default validator factory via <span class="emphasis"><em>META-INF/validation.xml</em></span>
(see <a class="xref" href="#chapter-xml-configuration" title="Chapter 7. Configuring via XML">Chapter 7, <em>Configuring via XML</em></a>).</p></div></div><div class="chapter" title="Chapter 12. Annotation Processor"><div class="titlepage"><div><div><h2 class="title"><a id="validator-annotation-processor"/>Chapter 12. Annotation Processor</h2></div></div></div><div class="toc"><dl><dt><span class="section"><a href="#validator-annotationprocessor-prerequisites">12.1. Prerequisites</a></span></dt><dt><span class="section"><a href="#validator-annotationprocessor-features">12.2. Features</a></span></dt><dt><span class="section"><a href="#validator-annotationprocessor-options">12.3. Options</a></span></dt><dt><span class="section"><a href="#validator-annotationprocessor-usage">12.4. Using the Annotation Processor</a></span></dt><dd><dl><dt><span class="section"><a href="#validator-annotationprocessor-commandline">12.4.1. Command line builds</a></span></dt><dt><span class="section"><a href="#validator-annotationprocessor-ide">12.4.2. IDE builds</a></span></dt></dl></dd><dt><span class="section"><a href="#validator-annotationprocessor-known-issues">12.5. Known issues</a></span></dt></dl></div><p>Have you ever caught yourself by unintentionally doing things like</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">specifying constraint annotations at unsupported data types (e.g. by annotating a String with <code class="literal">@Past</code>)</li><li class="listitem">annotating the setter of a JavaBeans property (instead of the getter method)</li><li class="listitem">annotating static fields/methods with constraint annotations (which is not supported)?</li></ul></div><p>Then the Hibernate Validator Annotation Processor is the right thing for you. It helps preventing
such mistakes by plugging into the build process and raising compilation errors whenever constraint
annotations are incorrectly used.</p><div class="tip" style="margin-left: 0.5in; margin-right: 0.5in;"><h2>Tip</h2><p>You can find the Hibernate Validator Annotation Processor as part of the distribution bundle on
<a class="link" href="http://sourceforge.net/projects/hibernate/files/hibernate-validator">Sourceforge</a> or in the
usual Maven repositories such as Maven Central under the GAV <code class="literal">org.hibernate:hibernate-validator-
annotation-processor:5.2.4.Final</code>.</p></div><div class="section" title="12.1. Prerequisites"><div class="titlepage"><div><div><h2 class="title"><a id="validator-annotationprocessor-prerequisites"/>12.1. Prerequisites</h2></div></div></div><p>The Hibernate Validator Annotation Processor is based on the "Pluggable Annotation Processing API"
as defined by <a class="link" href="http://jcp.org/en/jsr/detail?id=269">JSR 269</a> which is part of the Java
Platform since Java 6.</p></div><div class="section" title="12.2. Features"><div class="titlepage"><div><div><h2 class="title"><a id="validator-annotationprocessor-features"/>12.2. Features</h2></div></div></div><p>As of Hibernate Validator 5.2.4.Final the Hibernate Validator Annotation Processor checks that:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">constraint annotations are allowed for the type of the annotated element</li><li class="listitem">only non-static fields or methods are annotated with constraint annotations</li><li class="listitem">only non-primitive fields or methods are annotated with <code class="literal">@Valid</code></li><li class="listitem">only such methods are annotated with constraint annotations which are valid JavaBeans
getter methods (optionally, see below)</li><li class="listitem">only such annotation types are annotated with constraint annotations which are constraint
annotations themselves</li><li class="listitem">definition of dynamic default group sequence with @GroupSequenceProvider is valid</li></ul></div></div><div class="section" title="12.3. Options"><div class="titlepage"><div><div><h2 class="title"><a id="validator-annotationprocessor-options"/>12.3. Options</h2></div></div></div><p>The behavior of the Hibernate Validator Annotation Processor can be controlled using the
<a class="link" href="http://java.sun.com/javase/6/docs/technotes/tools/windows/javac.html#options">processor options</a>
listed in table <a class="xref" href="#table_processor_options" title="Table 12.1. Hibernate Validator Annotation Processor options">Table 12.1, “Hibernate Validator Annotation Processor options”</a>:</p><div class="table"><a id="table_processor_options"/><p class="title"><strong>Table 12.1. Hibernate Validator Annotation Processor options</strong></p><div class="table-contents"><table summary="Hibernate Validator Annotation Processor options" border="1"><colgroup><col width="50*" class="col_1"/><col width="50*" class="col_2"/></colgroup><thead><tr><th align="left" valign="top">Option</th><th align="left" valign="top">Explanation</th></tr></thead><tbody><tr><td align="left" valign="top"><p><code class="literal">diagnosticKind</code></p></td><td align="left" valign="top"><p>Controls how constraint problems are reported. Must be the
            string representation of one of the values from the enum <code class="literal">javax.tools.Diagnostic.Kind</code>,
            e.g. <code class="literal">WARNING</code>. A value of <code class="literal">ERROR</code> will cause compilation to halt whenever the AP detects
            a constraint problem. Defaults to <code class="literal">ERROR</code>.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">methodConstraintsSupported</code></p></td><td align="left" valign="top"><p>Controls whether constraints are allowed at methods of any
            kind. Must be set to <code class="literal">true</code> when working with method level constraints as supported by
            Hibernate Validator. Can be set to <code class="literal">false</code> to allow constraints only at
            JavaBeans getter methods as defined by the Bean Validation API. Defaults to <code class="literal">true</code>.</p></td></tr><tr><td align="left" valign="top"><p><code class="literal">verbose</code></p></td><td align="left" valign="top"><p>Controls whether detailed processing information shall be
            displayed or not, useful for debugging purposes. Must be either
            <code class="literal">true</code> or <code class="literal">false</code>. Defaults to <code class="literal">false</code>.</p></td></tr></tbody></table></div></div><br class="table-break"/></div><div class="section" title="12.4. Using the Annotation Processor"><div class="titlepage"><div><div><h2 class="title"><a id="validator-annotationprocessor-usage"/>12.4. Using the Annotation Processor</h2></div></div></div><p>This section shows in detail how to integrate the Hibernate Validator Annotation Processor into
command line builds (javac, Ant, Maven) as well as IDE-based builds (Eclipse, IntelliJ IDEA,
NetBeans).</p><div class="section" title="12.4.1. Command line builds"><div class="titlepage"><div><div><h3 class="title"><a id="validator-annotationprocessor-commandline"/>12.4.1. Command line builds</h3></div></div></div><div class="section" title="12.4.1.1. javac"><div class="titlepage"><div><div><h4 class="title"><a id="validator-annotationprocessor-javac"/>12.4.1.1. javac</h4></div></div></div><p>When compiling on the command line using
<a class="link" href="http://java.sun.com/javase/6/docs/technotes/guides/javac/index.html">javac</a>, specify the JAR
<span class="emphasis"><em>hibernate-validator-annotation-processor-5.2.4.Final.jar</em></span> using the "processorpath" option as shown in
the following listing. The processor will be detected automatically by the compiler and invoked
during compilation.</p><div class="example"><a id="d0e7112"/><p class="title"><strong>Example 12.1. Using the annotation processor with javac</strong></p><div class="example-contents"><pre class="screen">javac src/main/java/org/hibernate/validator/ap/demo/Car.java \
   -cp /path/to/validation-api-1.1.0.Final.jar \
   -processorpath /path/to/hibernate-validator-annotation-processor-5.2.4.Final.jar</pre></div></div><br class="example-break"/></div><div class="section" title="12.4.1.2. Apache Ant"><div class="titlepage"><div><div><h4 class="title"><a id="validator-annotationprocessor-ant"/>12.4.1.2. Apache Ant</h4></div></div></div><p>Similar to directly working with javac, the annotation processor can be added as as compiler
argument when invoking the <a class="link" href="http://ant.apache.org/manual/CoreTasks/javac.html">javac task</a>
for <a class="link" href="http://ant.apache.org/">Apache Ant</a>:</p><div class="example"><a id="d0e7128"/><p class="title"><strong>Example 12.2. Using the annotation processor with An</strong></p><div class="example-contents"><pre><code class="language-xml">&lt;javac srcdir="src/main"
       destdir="build/classes"
       classpath="/path/to/validation-api-1.1.0.Final.jar"&gt;
       &lt;compilerarg value="-processorpath" /&gt;
       &lt;compilerarg value="/path/to/hibernate-validator-annotation-processor-5.2.4.Final.jar"/&gt;
&lt;/javac&gt;</code></pre></div></div><br class="example-break"/></div><div class="section" title="12.4.1.3. Maven"><div class="titlepage"><div><div><h4 class="title"><a id="_maven"/>12.4.1.3. Maven</h4></div></div></div><p>There are several options for integrating the annotation processor with
<a class="link" href="http://maven.apache.org/">Apache Maven</a>. Generally it is sufficient to add the Hibernate
Validator Annotation Processor as dependency to your project:</p><div class="example"><a id="d0e7141"/><p class="title"><strong>Example 12.3. Adding the HV Annotation Processor as dependency</strong></p><div class="example-contents"><pre><code class="language-xml">...
&lt;dependency&gt;
    &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
    &lt;artifactId&gt;hibernate-validator-annotation-processor&lt;/artifactId&gt;
    &lt;version&gt;5.2.4.Final&lt;/version&gt;
&lt;/dependency&gt;
...</code></pre></div></div><br class="example-break"/><p>The processor will then be executed automatically by the compiler. This basically works, but comes
with the disadavantage that in some cases messages from the annotation processor are not displayed
(see <a class="link" href="http://jira.codehaus.org/browse/MCOMPILER-66">MCOMPILER-66</a>).</p><p>Another option is using the <a class="link" href="http://code.google.com/p/maven-annotation-plugin">Maven Annotation Plugin</a>.
To work with this plugin, disable the standard annotation processing performed
by the compiler plugin and configure the annotation plugin by specifying an execution and adding the
Hibernate Validator Annotation Processor as plugin dependency (that way the processor is not visible
on the project’s actual classpath):</p><div class="example"><a id="d0e7156"/><p class="title"><strong>Example 12.4. Configuring the Maven Annotation Plugin</strong></p><div class="example-contents"><pre><code class="language-xml">...
&lt;plugin&gt;
    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;
    &lt;configuration&gt;
        &lt;source&gt;1.6&lt;/source&gt;
        &lt;target&gt;1.6&lt;/target&gt;
        &lt;compilerArgument&gt;-proc:none&lt;/compilerArgument&gt;
    &lt;/configuration&gt;
&lt;/plugin&gt;
&lt;plugin&gt;
    &lt;groupId&gt;org.bsc.maven&lt;/groupId&gt;
    &lt;artifactId&gt;maven-processor-plugin&lt;/artifactId&gt;
    &lt;version&gt;2.2.1&lt;/version&gt;
    &lt;executions&gt;
        &lt;execution&gt;
            &lt;id&gt;process&lt;/id&gt;
            &lt;goals&gt;
                &lt;goal&gt;process&lt;/goal&gt;
            &lt;/goals&gt;
            &lt;phase&gt;process-sources&lt;/phase&gt;
        &lt;/execution&gt;
    &lt;/executions&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.hibernate&lt;/groupId&gt;
            &lt;artifactId&gt;hibernate-validator-annotation-processor&lt;/artifactId&gt;
            &lt;version&gt;5.2.4.Final&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/plugin&gt;
...</code></pre></div></div><br class="example-break"/></div></div><div class="section" title="12.4.2. IDE builds"><div class="titlepage"><div><div><h3 class="title"><a id="validator-annotationprocessor-ide"/>12.4.2. IDE builds</h3></div></div></div><div class="section" title="12.4.2.1. Eclipse"><div class="titlepage"><div><div><h4 class="title"><a id="_eclipse"/>12.4.2.1. Eclipse</h4></div></div></div><p>Do the following to use the annotation processor within the <a class="link" href="http://www.eclipse.org/">Eclipse</a> IDE:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Right-click your project, choose "Properties"</li><li class="listitem">Go to "Java Compiler" and make sure, that "Compiler compliance level" is set to "1.6".
Otherwise the processor won’t be activated</li><li class="listitem">Go to "Java Compiler - Annotation Processing" and choose "Enable annotation processing"</li><li class="listitem">Go to "Java Compiler - Annotation Processing - Factory Path" and add the JAR
hibernate-validator-annotation-processor-5.2.4.Final.jar</li><li class="listitem">Confirm the workspace rebuild</li></ul></div><p>You now should see any annotation problems as regular error markers within the editor and in the
"Problem" view:</p><div class="informalfigure"><div class="mediaobject"><img src="images/annotation_processor_eclipse.png" alt="annotation processor eclipse"/></div></div></div><div class="section" title="12.4.2.2. IntelliJ IDEA"><div class="titlepage"><div><div><h4 class="title"><a id="validator-annotationprocessor-idea"/>12.4.2.2. IntelliJ IDEA</h4></div></div></div><p>The following steps must be followed to use the annotation processor within
<a class="link" href="http://www.jetbrains.com/idea/">IntelliJ IDEA</a> (version 9 and above):</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Go to "File", then "Settings",</li><li class="listitem">Expand the node "Compiler", then "Annotation Processors"</li><li class="listitem">Choose "Enable annotation processing" and enter the following as "Processor path":
/path/to/hibernate-validator-annotation-processor-5.2.4.Final.jar</li><li class="listitem">Add the processor’s fully qualified name org.hibernate.validator.ap.ConstraintValidationProcessor
to the "Annotation Processors" list</li><li class="listitem">If applicable add you module to the "Processed Modules" list</li></ul></div><p>Rebuilding your project then should show any erronous constraint annotations:</p><div class="informalfigure"><div class="mediaobject"><img src="images/annotation_processor_intellij.png" alt="annotation processor intellij"/></div></div></div><div class="section" title="12.4.2.3. NetBeans"><div class="titlepage"><div><div><h4 class="title"><a id="validator-annotationprocessor-netbeans"/>12.4.2.3. NetBeans</h4></div></div></div><p>Starting with version 6.9, also the <a class="link" href="http://www.netbeans.org/">NetBeans</a> IDE supports using
annotation processors within the IDE build. To do so, do the following:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem">Right-click your project, choose "Properties"</li><li class="listitem">Go to "Libraries", tab "Processor", and add the JAR hibernate-validator-annotation-processor-5.2.4.Final.jar</li><li class="listitem">Go to "Build - Compiling", select "Enable Annotation Processing" and "Enable Annotation Processing
in Editor". Add the annotation processor by specifying its fully qualified name
org.hibernate.validator.ap.ConstraintValidationProcessor</li></ul></div><p>Any constraint annotation problems will then be marked directly within the editor:</p><div class="informalfigure"><div class="mediaobject"><img src="images/annotation_processor_netbeans.png" alt="annotation processor netbeans"/></div></div></div></div></div><div class="section" title="12.5. Known issues"><div class="titlepage"><div><div><h2 class="title"><a id="validator-annotationprocessor-known-issues"/>12.5. Known issues</h2></div></div></div><p>The following known issues exist as of May 2010:</p><div class="itemizedlist"><ul class="itemizedlist"><li class="listitem"><a class="link" href="https://hibernate.atlassian.net/browse/HV-308">HV-308</a>: Additional validators
registered for a constraint
<a class="link" href="http://docs.jboss.org/hibernate/stable/validator/reference/en-US/html_single/#chapter-xml-configuration">using XML</a> are
not evaluated by the annotation processor.</li><li class="listitem">Sometimes custom constraints can’t be
<a class="link" href="https://hibernate.atlassian.net/browse/HV-293">properly evaluated</a> when
using the processor within Eclipse. Cleaning the project can help in these situations. This seems to
be an issue with the Eclipse JSR 269 API implementation, but further investigation is required here.</li><li class="listitem">When using the processor within Eclipse, the check of dynamic default group sequence definitions
doesn’t work. After further investigation, it seems to be an issue with the Eclipse JSR 269 API
implementation.</li></ul></div></div></div><div class="chapter" title="Chapter 13. Further reading"><div class="titlepage"><div><div><h2 class="title"><a id="validator-further-reading"/>Chapter 13. Further reading</h2></div></div></div><p>Last but not least, a few pointers to further information.</p><p>A great source for examples is the Bean Validation TCK which is available for anonymous access on
<a class="link" href="https://github.com/beanvalidation/beanvalidation-tck">GitHub</a>. In particular the TCK’s
<a class="link" href="https://github.com/beanvalidation/beanvalidation-tck/tree/1.1.0.Final/tests">tests</a> might be
of interest. <a class="link" href="http://beanvalidation.org/1.1/spec/1.1.0.cr3">The JSR 349</a> specification itself
is also a great way to deepen your understanding of Bean Validation resp. Hibernate Validator.</p><p>If you have any further questions to Hibernate Validator or want to share some of your use cases
have a look at the <a class="link" href="http://community.jboss.org/en/hibernate/validator">Hibernate Validator
Wiki</a> and the <a class="link" href="https://forum.hibernate.org/viewforum.php?f=9">Hibernate Validator Forum</a>.</p><p>In case you would like to report a bug use
<a class="link" href="http://opensource.atlassian.com/projects/hibernate/browse/HV">Hibernate’s Jira</a> instance.
Feedback is always welcome!</p></div></div><script xmlns="" xmlns:d="http://docbook.org/ns/docbook" type="text/javascript" src="highlight.js/highlight.pack.js"> </script><script xmlns="" xmlns:d="http://docbook.org/ns/docbook" type="text/javascript">hljs.initHighlightingOnLoad();</script><script type="text/javascript">
dataLayer = [{'channel' : 'Hibernate', 'additional_tracking_code' : 'UA-45270411-3'}];
(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':
new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],
j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src=
'//www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);
})(window,document,'script','dataLayer','GTM-NJWS5L');</script><noscript><iframe src="//www.googletagmanager.com/ns.html?id=GTM-NJWS5L" height="0" width="0" style="display:none;visibility:hidden"> </iframe></noscript><hr xmlns="" xmlns:d="http://docbook.org/ns/docbook"/><a xmlns="" xmlns:d="http://docbook.org/ns/docbook" href="legalnotice.html"/></body></html>